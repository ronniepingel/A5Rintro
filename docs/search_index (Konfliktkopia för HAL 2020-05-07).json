[
["binära-variabler.html", "Kapitel 6 Binära variabler 6.1 Deskriptiv analys en binär variabel 6.2 Analys av två binära variabler 6.3 Inferens för binära variabler 6.4 Export av figurer och tabeller", " Kapitel 6 Binära variabler Detta avsnitt fokuserar på analys av binära kategorivariabler. I princip alla datamaterial innehåller variabler med två kategorier och även om det inte finns binära från början är det vanligt att av olika skäl omkoda kvantitativa variabler till variabler med två kategorier. Något som kan vara förvirrande inledningsvis är att det finns åtminstone två alternativ hur man väljer att arbeta med binära, som bägge är viktiga för den som analyserar data att hantera. En binär kategoriabel kan definieras som datatypen faktor, vilket görs med funktionen factor(). En faktors kategorier benämns i R för levels (nivåer). Fördelen med att definiera en variabel som faktor är att R kan använda information om kategorivariabeln i analyser och och resultat. Till exempel kan kategoriernas namn presenteras i resultat. Dessutom finns det metoder i R som kräver att variabeln är en faktor-variabel. Observera att det av förklarliga skäl inte går utföra räkneoperationer på variabler definierade som datatypen faktor. En binär kategorivariabel hanteras numeriskt genom de olika kategorierna tilldelats numeriska värden. Till exempel 0-1 till en variabel med två kategorier. Observera att huruvida det är möjligt att använda dessa värden sedan används beror på analysmetod. Eftersom bägge varianterna har för- och nackdelar återfinns ofta bägge varianter av kodning för en och samma binär variabel i ett dataset, där en version är kodad som faktor kallad variabelnamn_cat och en numerisk version kodad 0-1 kallad för variabelnamn_bin. 6.1 Deskriptiv analys en binär variabel Oavsett om en binär variabel har kategorier som inte går att rangordna (till exempel variabeln \\(kön\\) med kategorierna \\(kvinna\\) och \\(man\\)) eller har kategorier som går att rangordna (till exempel \\(utbildning\\) med kategorierna \\(låg\\) och \\(hög\\)) hanteras och analyseras en binär variabel på samma sätt. Som tidigare nämnt arbetar man i praktiskt i R på två sätt. Det är viktigt vid dataanalys att kunna arbeta på bägge sätten och förstå när det enda sättet är att föredra framför det andra. De två kategorierna i den binära variabeln tilldelas numeriska värden och variabeln analyseras sedan som en numerisk variabel. Vanligast är att ge kategorierna värdena 0 och 1. Anledningen är tolkningen blir i termer av andelar av den kategori som är kodad 1. Dessutom förenklas tolkning i sambandsanalyser, vilket vi ska komma att se senare. Exemplet nedan illustrerar. # Ursprungsvariabel education &lt;- c(&quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;low&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;low&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;low&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;low&quot;, &quot;high&quot;, &quot;low&quot;, &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;low&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;low&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;low&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;low&quot;, &quot;high&quot;, &quot;low&quot;, &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;) str(education) &gt; chr [1:280] &quot;high&quot; &quot;high&quot; &quot;low&quot; &quot;high&quot; &quot;high&quot; &quot;low&quot; &quot;high&quot; &quot;low&quot; &quot;low&quot; ... # Numerisk kodning: 0 = low, 1 = high edu_bin &lt;- rep(NA, length(education)) edu_bin[education == &quot;high&quot;] &lt;- 1 edu_bin[education == &quot;low&quot;] &lt;- 0 str(edu_bin) &gt; num [1:280] 1 1 0 1 1 0 1 0 0 1 ... # Numerisk kodning: 1 = low, 2 = high edu_12 &lt;- rep(NA, length(education)) edu_12[education == &quot;high&quot;] &lt;- 2 edu_12[education == &quot;low&quot;] &lt;- 1 str(edu_12) &gt; num [1:280] 2 2 1 2 2 1 2 1 1 2 ... # Beräkna medelvärdet (andelen) mean(edu_bin) &gt; [1] 0.4142857 mean(edu_12) &gt; [1] 1.414286 Medelvärdet när variabelns kategorier är kodade 1-2 inte är tolkningsbart på samma uppenbara sätt som vid kodningen 0-1. Med kommandot str() undersöker vi datatypen och vi ser att education är av typen character medan edu_01 och edu_12 är av datatypen numeric. Det är viktigt att undersöka datatyp, emellertid är detta ingen kod man vanligtvis sparar i scriptet. Efter datatypen är undersökt kan dessa rader tas bort. Den binära variabeln definieras som datatypen faktor med funktionen factor(). Med argumentet levels kan vi ändra nivåerna. Vidare kan vi använda funktionen levels kan vi ändra kategorinamn. Vi nedan illusterar med R. # Skapa en faktorvariabel edu_cat &lt;- factor(education) str(edu_cat) &gt; Factor w/ 2 levels &quot;high&quot;,&quot;low&quot;: 1 1 2 1 1 2 1 2 2 1 ... summary(edu_cat) &gt; high low &gt; 116 164 # Test att utföra en räkneoperation på en faktorvariabel mean(edu_cat) &gt; Warning in mean.default(edu_cat): argument is not numeric or logical: returning &gt; NA &gt; [1] NA Vi har nu definierat en faktor-variabel med två kategorier “high” and “low”. Vi kan även se att R även tilldelat kategorierna nivåer, där “high” är level 1 och “low” är level 2. Nivåernas ordning bestäms utifrån ordning de först dyker upp i objektet såvida inte vi gör om en numerisk variabel till en faktor. Även om vi nu arbetar med en binär variabel där nominal- eller ordinalskala teoretiskt saknar betydelse, är det viktigt att se till att ordningen stämmer eftersom med sin tänkta analys eftersom ordningen påverkar analyser i R. I detta exempel är det dessutom förmodligen förvirrande för användaren att “high” har tilldelats nivå 1 medan “low” är nivå 2. Av dessa skäl ändras därför ordningen med hjälp av argumentet levels. # Ändra ordningen på nivåerna edu_cat &lt;- factor(education, levels = c(&quot;low&quot;, &quot;high&quot;)) str(edu_cat) &gt; Factor w/ 2 levels &quot;low&quot;,&quot;high&quot;: 2 2 1 2 2 1 2 1 1 2 ... summary(edu_cat) &gt; low high &gt; 164 116 # Gör en numerisk variabel med två värden till en faktor. Notera att nivåerna i detta fall inte bestäms # av ordningen i vektorn utan av de numeriska värdens storlek. x &lt;- c(3, 1, 1, 3, 3) x_cat &lt;- factor(x) str(x_cat) &gt; Factor w/ 2 levels &quot;1&quot;,&quot;3&quot;: 2 1 1 2 2 Avslutningsvis illustrerar vi nu att vi ändrar namn från low till L samt high till H. OBS! Nedanstående kod är inget som är uppenbart för nybörjaren och det går att mer kompakt ändra namn på kategorier i en faktor-variabel med hjälp av argumentet labels. Dock gäller det då att vara nogrann med ordningen och därför rekommenderas den kod som presenteras här. Enklast är att kopiera koden och klistra in och ändra. # Funktionen levels() skapar en character-vektor med namn på kategorierna levels(edu_cat) &gt; [1] &quot;low&quot; &quot;high&quot; # Ändra för valt element namn i vektor levels(education_cat) levels(edu_cat)[levels(edu_cat) == &quot;low&quot;] &lt;- &quot;Low education&quot; levels(edu_cat)[levels(edu_cat) == &quot;high&quot;] &lt;- &quot;High education&quot; edu_cat &gt; [1] High education High education Low education High education High education &gt; [6] Low education High education Low education Low education High education &gt; [11] High education High education High education High education High education &gt; [16] Low education High education High education High education High education &gt; [21] High education High education High education High education High education &gt; [26] Low education High education High education High education Low education &gt; [31] High education High education Low education High education High education &gt; [36] High education Low education Low education High education Low education &gt; [41] High education High education Low education High education High education &gt; [46] Low education High education Low education Low education High education &gt; [51] High education High education High education High education High education &gt; [56] Low education High education High education High education High education &gt; [61] High education High education High education High education High education &gt; [66] Low education High education High education High education Low education &gt; [71] High education High education Low education High education High education &gt; [76] High education Low education Low education High education Low education &gt; [81] Low education Low education Low education Low education Low education &gt; [86] Low education Low education Low education Low education Low education &gt; [91] Low education Low education Low education Low education Low education &gt; [96] Low education Low education Low education Low education Low education &gt; [101] Low education Low education Low education Low education Low education &gt; [106] Low education Low education Low education Low education Low education &gt; [111] Low education Low education Low education Low education Low education &gt; [116] Low education Low education Low education Low education Low education &gt; [121] Low education Low education Low education Low education Low education &gt; [126] Low education Low education Low education Low education Low education &gt; [131] Low education Low education Low education Low education Low education &gt; [136] Low education Low education Low education Low education Low education &gt; [141] High education High education Low education High education High education &gt; [146] Low education High education Low education Low education High education &gt; [151] High education High education High education High education High education &gt; [156] Low education High education High education High education High education &gt; [161] High education High education High education High education High education &gt; [166] Low education High education High education High education Low education &gt; [171] High education High education Low education High education High education &gt; [176] High education Low education Low education High education Low education &gt; [181] High education High education Low education High education High education &gt; [186] Low education High education Low education Low education High education &gt; [191] High education High education High education High education High education &gt; [196] Low education High education High education High education High education &gt; [201] High education High education High education High education High education &gt; [206] Low education High education High education High education Low education &gt; [211] High education High education Low education High education High education &gt; [216] High education Low education Low education High education Low education &gt; [221] Low education Low education Low education Low education Low education &gt; [226] Low education Low education Low education Low education Low education &gt; [231] Low education Low education Low education Low education Low education &gt; [236] Low education Low education Low education Low education Low education &gt; [241] Low education Low education Low education Low education Low education &gt; [246] Low education Low education Low education Low education Low education &gt; [251] Low education Low education Low education Low education Low education &gt; [256] Low education Low education Low education Low education Low education &gt; [261] Low education Low education Low education Low education Low education &gt; [266] Low education Low education Low education Low education Low education &gt; [271] Low education Low education Low education Low education Low education &gt; [276] Low education Low education Low education Low education Low education &gt; Levels: Low education High education Om en variabel har bortfall krävs viss försiktighet. Nedanstående kodning för att koda om high till 1 och low till 0. # Skapa en variabel med missing data (NA) i element 3, 10, 100 education_mis &lt;- education education_mis[3] &lt;- NA education_mis[10] &lt;- NA education_mis[100] &lt;- NA # Numerisk kodning: 0 = low, 1 = high edu_bin_mis &lt;- rep(NA, length(education_mis)) edu_bin_mis[education_mis == &quot;high&quot;] &lt;- 1 edu_bin_mis[education_mis == &quot;low&quot;] &lt;- 0 # Genom att ta summary ser vi om det finns 3 missing i edu_bin summary(edu_bin_mis) &gt; Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s &gt; 0.0000 0.0000 0.0000 0.4152 1.0000 1.0000 3 # Medelvärdet (andelen) beräknas med argumentet na.rm = TRUE mean(edu_bin_mis) &gt; [1] NA mean(edu_bin_mis, na.rm = TRUE) &gt; [1] 0.4151625 6.1.1 Tabeller och en binär variabel Det går även att redovisa en binär variabel med hjälp av funktionen table(), som är en grundläggande funktion i R för skapa tabeller. Denna funktion har flexibilitet att hantera både en och flera variabler och du kommer att bekanta dig ytterligare med table() när vi introducerar analysis av variabler med fler än två kategorier. Genom att lära sig tillämpa funktionen på en binär variabel går det dock få kläm på funktionens grundläggande funktionalitet och vi börjar med se vad som händer när vi tillämpar table() på tidigare skapade våra binära variabler. Denna presenterar frekvenser och dessutom bortfall om vi använder argumentet useNA. table(edu_cat) &gt; edu_cat &gt; Low education High education &gt; 164 116 table(edu_bin) &gt; edu_bin &gt; 0 1 &gt; 164 116 table(edu_bin_mis) &gt; edu_bin_mis &gt; 0 1 &gt; 162 115 table(edu_bin_mis, useNA = &quot;ifany&quot;) &gt; edu_bin_mis &gt; 0 1 &lt;NA&gt; &gt; 162 115 3 I regel sparas tabeller i objekt. Tabell-objekt kan dock vara något omständliga att arbeta och det kan i ibland vara fördelaktigt att konvertera tabellen till en data frame för att kunna hämta element från tabellen. Se koden nedan för att undersöka skillnaden mellan tabell-objekt och data frame. När tabellen är konverterad till data frame går det använda sedvanlig metod för att ändra namn på variabler. freq_table_edu_cat &lt;- table(edu_cat) freq_table_edu_cat &gt; edu_cat &gt; Low education High education &gt; 164 116 str(freq_table_edu_cat) &gt; &#39;table&#39; int [1:2(1d)] 164 116 &gt; - attr(*, &quot;dimnames&quot;)=List of 1 &gt; ..$ edu_cat: chr [1:2] &quot;Low education&quot; &quot;High education&quot; freq_table_edu &lt;- data.frame(freq_table_edu_cat) freq_table_edu &gt; edu_cat Freq &gt; 1 Low education 164 &gt; 2 High education 116 Genom att en tabell-sparat i ett tabell-objekt går det att tillämpa funktioner avsedda för tabell-objekt. En vanlig funktion att tillämpa på tabell-objekt prop.table() som beräknar andelar utifrån tabellens frekvenser. Genom att kombinera frekvenser och andelar kan vi skapa en frekvenstabell. &gt; # Skapa tabell med andelar från tabell-objektetet &gt; prop_table_edu_cat &lt;- prop.table(freq_table_edu_cat) &gt; prop_table_edu_cat &gt; edu_cat &gt; Low education High education &gt; 0.5857143 0.4142857 &gt; # Kombinera frekvenser och andelar. Passa samtidigt på att avrunda och göra om variabeln till procent. &gt; table_edu &lt;- cbind(freq_table_edu_cat, round(100*prop_table_edu_cat,1)) &gt; # Ge tabellens kolumner namn &gt; colnames(table_edu) &lt;- c(&quot;Frekvens&quot;, &quot;Procent (%)&quot;) Ofta är det önskvärt att i tabeller redovisa relevanta marginaler. Genom att tillämpa funktionen addmargins() på ett tabellobjekt summeras cellerna i en tabell. Default för denna funktion är att summera cellerna både radvis och kolumnvis, men med argumentet margin går det att ange att cellerna i tabellen ska summeras enbart radvis (1), eller enbart kolumnsvis (2). &gt; table_edu &gt; Frekvens Procent (%) &gt; Low education 164 58.6 &gt; High education 116 41.4 &gt; table_edu_final &lt;- addmargins(table_edu, margin = 1) &gt; rownames(table_edu_final) &lt;- c(&quot;Låg utbildning&quot;, &quot;Hög utbildning&quot;, &quot;Summa&quot;) &gt; table_edu_final &gt; Frekvens Procent (%) &gt; Låg utbildning 164 58.6 &gt; Hög utbildning 116 41.4 &gt; Summa 280 100.0 6.1.2 Figurer och en binär variabel För att illustrera aggregerad data, som antal och andelar används stapeldiagram som man R konstruerar med funktionen barplot(). Det går att betrakta stapeldiagram som en grafisk representation av en tabell. Vi konstruerar utifrån tabellen med frekvenser och tabeller med andelar två stapeldiagram. Observera att nedanstående är avsett att illustrera stapeldiagram, och beträffande en statistisk beskrivning av en enda binär variabel ges fullständigt information genom att numeriskt redovisa redovisa antalet och andel, vilket ofta är fullt tillräckligt. # stapeldiagram baserat på tabellen med frekvenser barplot(freq_table_edu_cat, ylab = &quot;Antal&quot;, col = c(&quot;brown1&quot;, &quot;brown1&quot;), names.arg = c(&quot;Låg utbildning&quot;, &quot;Hög utbildning&quot;)) # stapeldiagram baserat på tabellen med andelar barplot(prop_table_edu_cat, ylab = &quot;Andel&quot;, col = c(&quot;brown1&quot;, &quot;brown1&quot;), names.arg = c(&quot;Låg utbildning&quot;, &quot;Hög utbildning&quot;)) 6.1.3 Inferens och en binär variabel Vi börjar med att se hur vi kan konstruera ett konfidensintervall för andelen \\(p\\) i en stor population, där vi antar att observationerna är dragna med ett OSU. Huruvida urvalet är gjort med eller utan återlägning saknar praktisk betydelse då urvalsstorleken antas vara liten relativt populationsstorleken. Givet OSU gäller följande: Stickprovsandelen \\(\\hat{p}\\) är en väntevärdesriktig skattning av \\(p\\). Andelen beräknas med \\(\\hat{p}=\\dfrac{k}{n}\\) där \\(n\\) är antal försök (antalet observationer) och \\(k\\) är antalet lyckade försök (antalet 1or). Andelsestimatorns varians \\[V(\\hat{p}) = \\dfrac{p(1-p)}{n}\\] skattas med \\[\\hat{V}(\\hat{p}) = \\dfrac{\\hat{p}(1-\\hat{p})}{n}.\\] För konfidensintervall krävs att samplingfördelningen är känd. Om \\(np(1-p)&gt;5\\) är andelsestimatorn approximativt normalfördelad. Ett konfidensintervall ges då av \\[ \\hat{p}\\pm z_{\\alpha/2}\\sqrt{\\hat{V}(\\hat{p})} \\] Anta att urvalet är från en stor population och vi vill skatta andelen högutbildade i populationen med ett tillhörande 95% konfidensintervall. Följande kod kan då användas för att beräkna detta i R. # Beräkna antalet lyckade försök (antal 1or) x &lt;- sum(edu_bin == 1) # Beräkna antal försök (1or or 0r). Denna kodning gör att eventuella NA inte tas med i beräkningen av n n &lt;- sum(edu_bin == 1) + sum(edu_bin == 0) # Skattning av andelen med hög utbildning. Det går även att använda mean(edu_bin) phat &lt;- x/n # Skatta variansen vphat &lt;- phat*(1-phat)/n # Välja konfidensgrad 100*(1-alpha)% alpha &lt;- 0.05 z_alpha &lt;- qnorm((1-alpha/2)) LB &lt;- phat - z_alpha*sqrt(vphat) UB &lt;- phat + z_alpha*sqrt(vphat) p_KI &lt;- c(LB, UB) p_KI [1] 0.3565876 0.4719839 # Undersöker förutsättningen n*phat*(1-phat) [1] 67.94286 Vi skattar att 41.4% är högutbildade i populationen. Med 95% säkerhet är andelen högutbildade i populationen mellan 35.7% och 47.2% Vi ska nu se på hur inferens kan göras i form av hypotesprövning. Givet samma förutsättningar som vid konfidensintervall ovan gäller följande: Vid hypotesprövning av \\(H_0: p = p_{H_0}\\) är under nollhypotesen \\[z = \\dfrac{\\hat{p} - p_{H_0}}{\\sqrt{\\dfrac{p_{H_0}(1-p_{H_0})}{n}}}\\] approximativt \\(N(0,1)\\) om \\(np(1-p)&gt;5\\). Anta att vi på 5% signifikansnivå \\((\\alpha=0.05)\\) vill testa \\(H_0: p = 0.4\\) vs \\(H_0: p \\neq 0.4\\). Vi kan implementera ovanstående kod, beräkna observerat \\(z\\)-värde och se hur extremt det är i en standardnormalfördelning för att få fram p-värdet. Vi jämför sedan \\(p\\)-värdet mot en förvald signifikansnivå. # p givet nollhypotesen pH0 &lt;- 0.4 # Variansen givet nollhypotesen vpH0 &lt;- pH0*(1-pH0)/n # Teststatistika zobs &lt;- (phat - pH0)/sqrt(vpH0) zobs [1] 0.48795 # zobs pnorm ger vänstersvans-sannolikhet. p_value &lt;- 2*(1 - pnorm(zobs)) p_value [1] 0.6255852 Vi kan konstatera att eftersom \\(p=\\) 0.626 kan vi inte förkasta nollhypotesen. Det finns dock en inbyggd funktion i R för att göra motsvarande analys, nämligen prop.test(). Vi ska nu se hur du kan använda denna funktion för att skapa ett konfidensintervall för andelen \\(p\\) i en stor population samt genomföra en hypotesprövning. I funktionen prop.test() anges först antalet lyckade försök (1or) samt det totala antalet försök (1or och 0r). Med argumentet p anges nollhypotesen och med argumentet alternative specificeras mothypotesen. Argumentet conf.level anger konfidensgrad för konfidensintervallet. Slutligen bestämmer argumentet correct kontinuitetsskorrektion ska användas. Vi använder inte kontinuitetskorrektion på denna kurs. # Använd funktionen prop.test() för att skapa konfidensintervall utan korrigering edu_analysis &lt;- prop.test(x = x, n = n, p = 0.4, alternative = &quot;two.sided&quot;, correct = FALSE) edu_analysis 1-sample proportions test without continuity correction data: x out of n, null probability 0.4 X-squared = 0.2381, df = 1, p-value = 0.6256 alternative hypothesis: true p is not equal to 0.4 95 percent confidence interval: 0.3581276 0.4727639 sample estimates: p 0.4142857 Vi börjar med att se på resultatet från hypotesprövningen och upptäcker exakt samma \\(p\\)-värde som förut! Vårt tidigare observerade \\(z\\)-värde, 0.488 erhålls genom att ta roten ur 0.2380952. Vidare är konfidensintervallet mycket likt det tidigare framräknade intervallet. De överensstämmer dock inte exakt, vilket beror på att R använder en annan formel för konfidensintervallet som har något bättre egenskaper om andelen är nära 0 eller 1 och stickprovet är litet. div.green{ background-color:#abd4b3; border-radius: 5px; padding: 20px;} Inferens när \\(p\\) är nära 0 eller 1 Om andelen i populationen är nära 0 eller 1 krävs stort stickprov för att inferensen ska bli korrekt! Visserligen har vi tumregeln \\(np(1-p)&gt;5\\), men om andelen i populationen är mycket nära 0 eller 1 fungerar denna tumregel inte väl om inte stickprovsstorleken är stor. Beträffande konfidensintervall är då Wilson score interval, som R använder i prop.test, ett något bättre alternativ än den formeln som vi använder. I de absolut flesta fall har det inget betydelse om vi väljer prop.test() eller intervallet som baseras på normalapproximation (vilket vi såg eftersom intervallen var så lika). För hypotesprövning finns alternativet att använda ett så kallat exakt binomial-test. Detta test introduceras emellertid inte här utan vi hänvisar till funktionen binom.test() och tillhörande dokumentation. Var som sagt uppmärksam om andelen är nära 0 eller nära 1! div.yellow{ background-color:#FFFA94; border-radius: 5px; padding: 20px;} \\(\\chi^2\\)-test och test av \\(p\\) I prop.test() används \\(\\chi^2\\)-test för test av andelar. \\(\\chi^2\\)-testet är nämligen direkt relaterat till det \\(z\\)-test som vi använder vid test av andelar (vilket vi såg när vi förut tog roten ur \\(\\chi^2\\)-värdet!). Problemet med test av \\(p\\) kan nämligen formuleras utifrån observerade frekvenser (\\(116\\) 1or och \\(164\\) 0or) och under nollhypotesen förväntade frekvenser (\\(np_{H_0}=112\\) 1or och \\(n(1-p_{H_0})=168\\) 0r). Vi illusterar i en tabell: 1or 0or 116 (112) 164 (168) Formeln för \\(\\chi^2\\)-testet går det sedan att tillämpa \\[\\chi^2 = \\sum \\dfrac{(O_i-E_i)^2}{E_i} = \\dfrac{(116-112)^2}{112} + \\dfrac{(164-168)^2}{168}=0.2381\\] vilket i detta fall jämförs med en \\(\\chi^2\\)-fördelning med 1 frihetsgrad. Nu när vi har beräknat konfidensintervall kan det avslutningvis vara illustrativt att addera konfidensintervall till stapeldiagramet med hjälp av funktionen arrows. Se koden nedan. # Spara koordinat för stapel till my_edu_plot my_edu_plot &lt;- barplot(phat, ylab = &quot;Andel&quot;, col = c(&quot;lightblue&quot;), ylim = c(0, 0.6), names.arg = c(&quot;Hög utbildning&quot;)) # Pilen går från x-koordinat (my_edu_plot) och y-koordinat (UB). # till x-koordinat (my_edu_plot) till y-koordinat (LB). # Vinkeln på pilen sätts till 90 grader # Piltypen är 3 arrows(my_edu_plot, UB, my_edu_plot, LB, angle=90, code=3) 6.2 Analys av två binära variabler Även om funktionen table() kan användas vid analys av en enda variabel, så är den framför allt användbar för att skapa korstabeller, dvs analys av två eller flera kategorivariabler samtidigt. Vi ska nu se hur table() kan användas för analysera samband mellan två binära variabler. Skapande av korstabeller kräver också att vi funderar på hur sambandet presenteras. I table() anges variabeln som ska finnas på raden först, sedan variabeln redovisas. Tabellen som erhålls kallas i fallet med två variabler för tvåvägs-korstabell. Om det går att översätta variablerna i termer av oberoende variabel och beroende variabel, sätts den oberoende variabeln i regel kolumnsvis (x-axel) och den beroende variabeln radvis (y-axel). Detta är analogt med hur man resonerar vid spridningsdiagram. Vi exemplifierar nedan med R-kod och vi ska nu beskriva sambandet mellan utbildningsnivå och rökning. Först skapas en korstabell med frekvenser och baserat på denna skapas en korstabell med relativa frekvenser baserat på kolumnprocent. Notera att det kräver en del pusslande, men i gengäld erhålls stor flexibilitet vad gäller den slutliga utformningen av tabellen. Vi börjar med att skapa en rudimentär korstabell som anger frekvenerna i de fyra cellerna. # Skapa en variabel smoker som är 1 om rökare och 0 om icke-rökare smoker &lt;- c(0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1, 1,1,1,1,0,0,0,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1, 1,1,1,1,0,0,0,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,1) # Korstabulering av edu_bin och smoker (vi sätter rökning kolumnvis) freq_table_edu_smoke &lt;- table(smoker, edu_bin) För att använda tabellen måste den emellertid modifieras. Dels måste rader och kolumner tydligare namnges så att inga missförstånd uppstår vad gäller tolkning, dels måste sambandsanalys tydliggöras om detta är målet för analys. Det är nämligen svårt att analysera samband från tabeller innehållande enbart frekvenser, därför måste vi på ett lämpligt sätt beskriva andelar (eller procent). Precis som tidigare används därför funktionen prop.table() på ett objekt från table(). Eftersom vi nu har en två-vägs kortstabell ger prop.table() tre möjligheter att beräkna andelar: Andelar baserade på totala antalet (default) Andelar beräknade utifrån radvisa totaler i nämnarna, genom att sätta argumentet margin = 1 Andelar baserade på kolumnvisa totaler i nämnarna, genom sätta argumentet marin = 2. Notera att det är mycket viktigt att välja rätt andelar att beräkna eftersom dessa styr tolkningen av resultaten. Vi illustrerar nu hur andelarna beräknas i R och tolkar dem sen. # Andelar baserat alla table_all &lt;- prop.table(freq_table_edu_smoke) table_all &gt; edu_bin &gt; smoker 0 1 &gt; 0 0.2714286 0.2857143 &gt; 1 0.3142857 0.1285714 # Procent baserat rader table_row_percent &lt;- prop.table(freq_table_edu_smoke, margin = 1) table_row_percent &gt; edu_bin &gt; smoker 0 1 &gt; 0 0.4871795 0.5128205 &gt; 1 0.7096774 0.2903226 # Andelar baserat kolumner table_column_percent &lt;- prop.table(freq_table_edu_smoke, margin = 2) table_column_percent &gt; edu_bin &gt; smoker 0 1 &gt; 0 0.4634146 0.6896552 &gt; 1 0.5365854 0.3103448 Den första tabellen visar att av alla i undersökningen är 27.1% icke-rökare och har låg utbildning. Om urvalet är slumpmässigt är detta således en skattning av sannolikheten \\(\\Pr(\\text{Icke-rökare}\\,\\, \\&amp; \\,\\, \\text{Låg utbildning})\\). På motsvarande sätt är 28.6%, 31.4% och 12.9% skattningar av \\(\\Pr(\\text{Icke-rökare}\\,\\, \\&amp; \\,\\, \\text{Hög utbildning})\\), \\(\\Pr(\\text{Rökare}\\,\\, \\&amp; \\,\\, \\text{Låg utbildning})\\) och \\(\\Pr(\\text{Rökare}\\,\\, \\&amp; \\,\\, \\text{Hög utbildning})\\). Huruvida dessa skattningar är relevanta beror på syftet med undersökningen, men oftast är det mer relevant att skatta de betingade sannolikheter och sedan jämföra dessa. I den andra tabellen ser vi att bland icke-rökarna har 48.7% låg utbildning. Det innebär naturligtvis att bland icke-rökarna har 51.3% hög utbildning. Om urvalet är slumpmässigt är dessa skattningar av \\(\\Pr(\\text{Låg utbildning}|\\text{Icke-rökare})\\) och \\(\\Pr(\\text{Hög utbildning}|\\text{Icke-rökare})\\). På motsvarande sätt har 71% låg utbildning respektive 29% hög utbildning bland rökarna. \\(\\Pr(\\text{Låg utbildning}|\\text{Rökare})\\) och \\(\\Pr(\\text{Hög utbildning}|\\text{Rökare})\\). Vi kan alltså med denna analys jämföra utbildningsnivån bland icke-rökare och rökare. Den tredje tabellen redovisar, genom att beräkna kolumnprocent, att bland de lågutbildade röker 53.7% medan bland de högutbildade röker 31%. Detta är således skattningar av \\(\\Pr(\\text{Rökare} | \\text{Låg utbildning})\\) respektive \\(\\Pr(\\text{Rökare} | \\text{Hög utbildning})\\). På motsvarande sätt är 46.3% och 69% skattningar av \\(\\Pr(\\text{Icke-rökare}|\\text{Låg utbildning})\\) och \\(\\Pr(\\text{Icke-rökare}|\\text{Hög utbildning})\\). Vi kan konstatera att i stickprovet är andelen rökare större bland lågutbildade än högutbildade. Vilken tabell vi väljer att redovisa beror således på frågeställningen. Om vi tänker oss att vi vill studera om utbildning påverkar benägenheten att röka, vilket förmodligen är den frågan som ställs, så är den tredje tabellen den som ska redovisas. Det är då enkelt att jämföra andelarna som röker i respektive utbildningskategori. Vi konstruerar därför en korstabell som på beskriver detta samband och som, för fullständighets skull, innehåller både frekvenser och andelar. Tabellen konstrueras på motsvarande sätt som när vi konstruerade en tabell med en enda binär variabel. # Skapa tabell för presentation av analys table_edu_smoke &lt;- cbind(freq_table_edu_smoke[,1], round(100*table_column_percent[,1], 1), freq_table_edu_smoke[,2], round(100*table_column_percent[,2], 1)) table_edu_smoke_final &lt;- addmargins(table_edu_smoke, 1) table_edu_smoke_final &gt; [,1] [,2] [,3] [,4] &gt; 0 76 46.3 80 69 &gt; 1 88 53.7 36 31 &gt; Sum 164 100.0 116 100 colnames(table_edu_smoke_final) &lt;- c(&quot;Låg (n)&quot;, &quot;Låg (%)&quot;, &quot;Hög (n)&quot;, &quot;Låg (%)&quot;) rownames(table_edu_smoke_final) &lt;- c(&quot;Icke-rökare&quot;, &quot;Rökare&quot;, &quot;Summa&quot;) table_edu_smoke_final &gt; Låg (n) Låg (%) Hög (n) Låg (%) &gt; Icke-rökare 76 46.3 80 69 &gt; Rökare 88 53.7 36 31 &gt; Summa 164 100.0 116 100 barplot( freq_table_edu_smoke, names.arg = c(&quot;Låg utbildning&quot;, &quot;Hög utbildning&quot;), ylab = &quot;Antal&quot;, legend = c(&quot;Icke-rökare&quot;, &quot;Rökare&quot;) ) barplot( table_column_percent, names.arg = c(&quot;Låg utbildning&quot;, &quot;Hög utbildning&quot;), ylab = &quot;Andel&quot;, legend = c(&quot;Icke-rökare&quot;, &quot;Rökare&quot;)) barplot( table_column_percent, beside=TRUE, names.arg = c(&quot;Låg utbildning&quot;, &quot;Hög utbildning&quot;), ylab = &quot;Andel&quot;, legend = c(&quot;Icke-rökare&quot;, &quot;Rökare&quot;)) # Beräkna andelen rökare bland högutbildade # (Alternativt hämta andelarna från tabellen med table_row_percent[2,2]) p1 &lt;- mean( smoker[edu_bin == 1] ) # Beräkna andelen rökare bland lågutbildade # (Alternativt hämta andelarna från tabellen med table_row_percent[2,1]) p0 &lt;- mean( smoker[edu_bin == 0] ) barplot( c(p0, p1), names.arg = c(&quot;Låg utbildning&quot;, &quot;Hög utbildning&quot;), ylab = &quot;Andel rökare&quot; ) Överkurs För att ytterligare en publikationsredo figur kan vi tweaka figuren ytterligen genom att lägga till procent ovanför staplarna med hjälp av funktionen text(). I denna funktion anges koordinater (x,y) för var texten ska in, där x-koordinaten är staplarnas placering i objektet my_bar. Med argumentet labels bestäms vad som ska stå över staplarna. Funktionen paste används för att sammanfoga numeriska värden och text, i detta fall procenttecknet. Vi ändrar också färgen på figuren. # Gör om andelar till procent percentages_smoker &lt;- round(100*c(p0, p1), 1) # Skapa objekt så vi kan hämta information från figurobjekt my_bar &lt;- barplot( percentages_smoker, names.arg = c(&quot;Låg utbildning&quot;, &quot;Hög utbildning&quot;), ylim=c(0,70), col = &quot;lightblue&quot;, border = &quot;lightblue&quot;, ylab = &quot;Röker (%)&quot;) # Lägg till text i figuren text(x = my_bar, y = percentages_smoker + 6, labels = paste(percentages_smoker, &quot;%&quot;, sep=&quot;&quot;)) 6.3 Inferens för binära variabler När val av analys som är relevant är gjord är det enkelt att kvantifiera sambandet utifrån skattningarna av de betingade sannolikheterna. De tre vanligaste måtten för att kvantifiera sambandet mellan två binära variabler är: Skillnaden i andelar eller riskdifferensen: \\(RD = \\Pr(Y=1|X=1) - \\Pr(Y=0|X=1)\\) Kvoten av andelar eller relativ risk: \\(RR = \\Pr(Y=1|X=1)/\\Pr(Y=0|X=1)\\) Oddskvoten: \\(OR = \\dfrac{\\dfrac{\\Pr(Y=1|X=1)}{1 - \\Pr(Y=1|X=1)}}{\\dfrac{\\Pr(Y=1|X=0)}{1 - \\Pr(Y=1|X=0)}}\\) Alla dessa mått går enkelt att beräkna efter skattning av \\(\\Pr(Y=1|X=1)\\) samt \\(\\Pr(Y=1|X=0)\\). # Beräkna andelen rökare bland högutbildade # (Alternativt hämta andelarna från tabellen med table_row_percent[2,2]) p1 &lt;- mean( smoker[edu_bin == 1] ) # Beräkna andelen rökare bland lågutbildade # (Alternativt hämta andelarna från tabellen med table_row_percent[2,1]) p0 &lt;- mean( smoker[edu_bin == 0] ) # Skillnad i andelar (riskdifferens) rd &lt;- p1 - p0 # kvot av andelar (relativ risk) rr &lt;- p1/p0 # oddskvot or &lt;- (p1/(1-p1)) / ((p0/(1-p0))) rd [1] -0.2262405 rr [1] 0.5783699 or [1] 0.3886364 Vilket mått som är mest relevant beror på syftet med undersökningen, men ofta är skillnaden i andelar mest policy-relevant, medan relativ risk är relevant för individen. Oddskvoten är ett mått som också som vi har olika skäl måste använda eftersom det finns studiedesigner och statistiska metoder som ger oss denna typ av samband. \\[\\hat{p_1} - \\hat{p_0}\\pm z_{\\alpha/2}\\sqrt{\\dfrac{\\hat{p_1}(1-\\hat{p_1})}{n_1} + \\dfrac{\\hat{p_0}(1-\\hat{p_0})}{n_0}}\\] x1 &lt;- sum(smoker[edu_bin == 1]) x0 &lt;- sum(smoker[edu_bin == 0]) n1 &lt;- sum(edu_bin == 1) n0 &lt;- sum(edu_bin == 0) x &lt;- c(x1, x0) n &lt;- c(n1, n0) prop.test(x, n, correct = FALSE) 2-sample test for equality of proportions without continuity correction data: x out of n X-squared = 14.095, df = 1, p-value = 0.0001738 alternative hypothesis: two.sided 95 percent confidence interval: -0.3398732 -0.1126079 sample estimates: prop 1 prop 2 0.3103448 0.5365854 se_rd &lt;- sqrt( p1*(1-p1)/(n1-1) + p0*(1-p0)/(n0-1) ) z_alpha &lt;- qnorm(0.975) ul &lt;- rd + z_alpha*se_rd ll &lt;- rd - z_alpha*se_rd ll [1] -0.3403008 ul [1] -0.1121802 Hur tolkar du resultatet? Vad gäller tolkning av resultat borde det kanske vara rimligt ur presentationsperspektiv att vända på analysen, dvs i vilken utsträckning ökar låg utbildning benägenheten att röka? 6.4 Export av figurer och tabeller Det kan vara omständligt att exportera data från R till Word. En smidig lösning är att spara tabellerna i html-format, vilket gör tabellerna program och plattformsoberoende. Du kan sedan när manuset närmar sig att bli klart, öppna html-filen, markera allt, och klistra in. Kom ihåg att det inte är nödvändigt att lägga in tabellerna i Word förrän manuset närmar sig att bli klart. För att exportera tabeller använder vi paketet xtable och funktionen xtable() tillsammans med funktionen print() (som finns i basversionen av R). Installera därför nödvändigt paket install.packages(\"xtable\"). library(&quot;xtable&quot;) print(xtable(table_edu_smoke), type=&quot;html&quot;, file=&quot;D://table_edu_smoke.html&quot;) För att sedan föra in tabellerna i ordbehandlingsprogram öppnas tabellen i en webläsare, du högerklickar någonstans i webläsaren och väljer markera allt, kopiera, och klistra in. "]
]
