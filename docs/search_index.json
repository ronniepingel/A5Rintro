[
["index.html", "Tillämpad statistik med R Kapitel 1 Introduktion 1.1 Om statistisk programmering med R 1.2 Allmänna tips om R på kursen 1.3 Sammanfattning 1.4 Referenser", " Tillämpad statistik med R Ronnie Pingel 2020-04-20 Kapitel 1 Introduktion Denna material utgör en viktig del av en kurs i tillämpad statistik. 1.1 Om statistisk programmering med R På denna kurs arbetar vi med R, som är ett programspråk och en miljö för statistisk dataanalys (https://www.r-project.org/) som fungerar på UNIX plattformar, Windows och MacOS. Det finns flera anledningar till att vi valt R: R är gratis och har en öppen källkod. R ger tillgång till avancerade verktyg för dataanalys och datavisualisering. Användare av R bidrar ofta med egen programkod och egna paket, vilket innebär att en omfattande mängd funktioner enkelt går att implementera. Många läroböcker skrivs med utgångspunkt från R. Online-resurserna är mycket stora. Det finns många forum där användare av R kan få hjälp (t ex https://stackoverflow.com/). R är ett av de absolut vanligaste programmen för statistisk dataanalys. (http://r4stats.com/2019/04/01/scholarly-datasci-popularity-2019/) Finns det anledningar till att inte välja R? Det finns ingen officiell support. Eftersom R bygger på användarnas bidrag finns ingen garanti att funktioner fungerar som de ska. Jämfört med andra programspråk kan R uppfattas som långsamt. För den som van vid menybaserade system (sk point-and-click) kan dessutom kodning uppfattas som en nackdel. Det finns emellertid etiska och praktiska skäl att lära sig programmera i statistikprogram (dvs att i kod skriva ange hur data ska hanteras och analyseras), och inte förlita sig på menyer. Programmering är nödvändig för att tillförlitligt upprepa (replikera) dataanalyser. På företag och på myndigheter ska kolleger kunna ta över datamaterial och tillhörande analyser och på nytt genomföra dessa med samma resultat. Samma sak gäller inom forskning, där andra forskare ska erhålla samma resultat givet samma data och analys. Notera att detta även gäller för dig själv, dvs det är inte ovanligt att som analytiker på nytt upprepa en analys. spar tid för repetativa moment, t ex om många liknande analyser ska genomföras. ger möjlighet till avancerade analyser samt frihet att utforma egna analyser. bidrar till ökad förståelse för dataanalys. Kruxet? Statistisk programmering tar längre tid att lära sig jämfört med att lära sig menybaserad datahantering och analyser! Tabell 2.1 redovisar några reflektioner över ett antal vanliga statistikprogram. Table 1.1: En jämförelse av några vanliga statistikprogram Minitab Mycket enkelt att lära sig. Används främst inom kvalitetskontroll i industri samt planering av randomiserade försök. Billigt. Begränsat urval av statistiska metoder SPSS Enkelt att lära sig. Stor spridning bland samhällsvetare och utredare. Ganska stort urval av statistiska metoder som är organiserade på ett något rörigt sätt. Krånglig programkod. Stata Enkelt att lära sig och mycket enkel programkod. Spridning bland forskare inom ekonometri och epidemiologi. Stort urval av, även de senaste, statistiska metoderna SAS Medelsvårt att lära sig, med en föråldrad programkod. Kan hantera stora dataset. Används av myndigheter, industri och forskare inom alla områden. Standard för läkemdelsbolag. Stort urval av statistiska metoder, men inte de allra senaste. Dyrt. Svårt att göra bra figurer. R Svårt att lära sig. Gratis. Flexibelt. Mycket stor spridning inom alla områden för dataanalys. Enkel programkod. Python Mycket svårt att lära sig. Gratis. Flexibelt. Stor spridning inom maskininlärning och AI. Varför är inte Excel, Open Office Calc, Google Docs och andra kalkylprogram inkluderade i jämförelsen? SVaret är enkelt. Dessa är nämligen inga statistikprogram! Ofta saknas i sådana program viktiga statistiska funktioner och dessutom är den numeriska tillförlitligheten lägre än för konventionella statistiskprogram (Keeling, K. B., &amp; Pavur, R. J., 2011). 1.2 Allmänna tips om R på kursen Det tar tid att lära sig R. Det kan även vara frustrerande, inte minst eftersom programmering är inte förlåtande vad gäller fel. Men misströsta inte, i slutändan är det värt det och är i högsta grad tidsbesparande. Här följer några tips vad gäller inlärningen och användandet av R under kursens gång: Se till att snabbt få grunderna på plats. R kommer att användas löpande under kursens gång. Arbeta aktivt med R. Programmering lär man sig genom tillämpning, inte genom att läsa. Det krävs normalt sett många timmar av aktivt arbete för att lära sig ett programspråk. Använd därför R till att lösa övningsuppgifter och att replikera exempel från föreläsningar. På så vis får du rutin vad gäller användandet av R. Använd kod som presenterats på kursen. Ändra och laborera i färdig kod för att se vad som händer. Det är inte viktigt att kunna skriva all kod utantill, däremot ska man förstå skriven kod och kunna manipulera denna för sitt syfte. Lös övningsuppgifter på följande vis: 1. Läs uppgiften och skissa därefter på papper upp en lösning, men gör inga beräkningar inte. Skriv ner antaganden och formler. 2. Lös sedan uppgiften med hjälp av beräkningar i R. Om du fastnar, studera R-koden i lösningsförslaget förstå hur hur uppgiften har lösts med hjälp R alternativt använd kod som presenterats på kursen. 3. Räkna därefter igenom uppgiften för hand. När du känner dig helt trygg med att räkna för hand kan du så småningom hoppa över detta moment. 4. Fyll i din papperslösning och avsluta med ett svar. Var inte rädd för att använda resurser på nätet. Se ovan. Kontakta lärare och lärarassistenter på kursen om ni fastnar och har frågor. Utnyttja de lärarledda sessionerna. Samarbeta och diskutera i de diskussionsforum som skapats för er studenter. På denna kurs rekommenderas att ni endast skriver kod på det sätt som det presenteras på kursen. Visserligen är R oerhört flexibelt och en uppgift går att lösa på en mängd sätt. Koden som presenteras på kursen är emellertid framtagen för att vara tydlig och tillförlitlig och syftet är att du ska bli trygg med att beräkningarna är korrekta snarare än effektiva. Slutligen, så är det bra att som läsare ha i åtanke att all beskrivning av kodens funktionalitet inte är uttömmande. Syftet är nämligen att lära ut vad som är nödvändigt för denna kurs och då behövs inte en fullständig beskrivning av till exempel vad ett verktyg i R kan göra. Lycka till! 1.3 Sammanfattning div.red{ background-color:#F5B7B1; border-radius: 5px; padding: 20px;} Du ska kunna motivera varför statistisk programmering är nödvändig för arbete med data och dataanalyser. 1.4 Referenser Keeling, K. B., &amp; Pavur, R. J. (2011). Statistical accuracy of spreadsheet software. The American Statistician, 65(4), 265-273. "],
["att-börja-använda-r.html", "Kapitel 2 Att börja använda R 2.1 Installation av R och RStudio 2.2 Installation av RStudio 2.3 Första sessionen 2.4 Paket 2.5 Sammanfattning 2.6 Övningar", " Kapitel 2 Att börja använda R I detta kapitel ska du inledningsvis installera R samt ett gränssnitt som kallas för RStudio. RStudio kan liknas vid en avancerad textredigerare som underlättar arbetet med R. Det går visserligen alldeles utmärkt att använda R som det är, men RStudio förenklar i många avseenden programmeringen. 2.1 Installation av R och RStudio Vid programmering är det mycket viktigt att noga följa instruktioner. Du ska nu först installera R. Därefter ska du installera RStudio. 2.1.1 Installation av R på MacOS Ladda ner den senaste versionen från https://cran.r-project.org/bin/macosx/. Notera att versionen måste passa för ditt MacOS. Leta upp den version som passar till ditt MacOS om du har en äldre Mac. Ladda ner pkg-filen under Latest release. Öppna den nedladdade .pkg-filen och installera R. 2.1.2 Installation av R på Windows Gå till hemsidan https://cran.r-project.org/bin/windows/base/. Klicka på ‘’Download R (versionnummer) for Windows’’. Eventuellt fungerar inte den senaste versionen ditt Window om du har en äldre Windows-versions. Prova då en tidigare version av R. Du kanske även upptäcker att senaste versionnummer på Rs hemsida inte är samma som används i detta exempel eftersom det kan ha kommit senare versioner. För din del saknar just detta praktisk betydelse. Dubbelklicka på ‘’R installer’’ för att starta installationen. Välj språk och tryck OK. Välj Next. Välj sökväg för din installation. Låt default vara. Klicka Next. För att förenkla, välj alla komponenter för installation. Klicka Next. Klicka No (accept defaults). För att lägga till R i Startmenyn, klicka bort kryssrutan nedan. Klicka Next. Välj om du vill ha genvägar. Klicka Next. Installation börjar! Starta R när den är klar. Starta R för första gången. På Windows ser det ut så här. 2.2 Installation av RStudio Av olika anledningar väljer vi att inte arbeta i R Editor utan vi väljer RStudio. Stäng därför ner R. Gå till https://rstudio.com/products/rstudio/download/}. 2 Välj RStudio Desktop Free. 3 Välj sedan den version stämmer överens med ditt operativsystem. Installera (på Windows) genom att klicka Next-&gt;Next-&gt;Install Starta RStudio. Du ska nu fått upp nedanstående. Vi ska i detalj beskriva vad de olika panelerna till höger kommer vi återkomma till när det är aktuellt. Avsluta RStudio. Om du mot förmodan inte skulle lyckas installera R och RStudio, så finns möjligheten att koppla upp sig till Statistiska institutionens datorer via fjärrskrivbordet och på så sätt få tillgång nödvändig programvara. 2.3 Första sessionen I denna session ska du bekanta dig med R och prova använda R som en miniräknare. Starta RStudio. Till vänster ska du ha en panel som heter Console. I denna panel redovisas resultat. Vad övriga paneler gör kommer vi återkomma till när det blir aktuellt. Välj i menyn File &gt; New File &gt; R Script. Ett nytt fönster (Untitled1) öppnas ovanför Console Detta är ett script-fönster eller en editor. I editorn skrivs kommandon in som sedan kan utvärderas av R. Resultaten redovisas i Console. Ha för vana att aldrig skriva kod direkt i R Console. I princip är en script-fil inte annorlunda än en vanlig textfil, förutom att filen har tillägget .R. Spara script med jämna mellanrum eftersom det är önskvärt att inte förlora sin kod ifall något oförutsett händer. Skapa därför en mapp med namnet A5Rkod på din dator. Välj File &gt; Save As… och spara i A5Rkod scriptet Untitled med namnet myfirstscript.R. Efter att vi har skrivit koden i editorn måste vi meddela R att koden ska utvärderas. Kod i scriptfilen körs (exekveras) på tre olika sätt: En rad: Raden där markören är placerad körs med Ctrl+Enter (command + Enter på Mac) eller Run ovanför scriptet. Flera rader: Markera kodavsnittet och tryck Ctrl+Enter (command + Enter på Mac) eller Run. Hela scriptet: Ctrl+Shift+Enter Det finns några viktiga punkter att ha i åtanke: Om avsikten är att köra kod som sträcker sig över flera rader måste man avsluta raden med räknetecken \\((+,-,*,/)\\), kommatecken \\(,\\) eller vänsterparentes \\((\\). En rad inleds aldrig med räknetecken eller kommatecken. En rad som inleds med # exekveras inte. Tecknet # används för att kommentera koden, vilket viktigt eftersom vi då i text kan förklara vad koden gör. Skriv in nedanstående script till myfirstscript.R. Spara. # Detta är mitt första R-script som heter myfirstscript.R. # I detta script använder jag R som miniräknare samt # exekverar kod från scriptet. 1+1 1+3 2-7 2*3 4/5 3^2 Använd R som miniräknare genom att prova alla tre sätt att köra kod. Det är nödvändigt att bekanta sig med hur kod körs för att bli bekväm med att simultant arbeta i script-fönstret och se resultat i Console. Återigen, skriv aldrig i Console. 1+1 [1] 2 1+3 [1] 4 2-7 [1] -5 2*3 [1] 6 4/5 [1] 0.8 3^2 [1] 9 Matematiska funktioner, t ex kvadratroten, finns implementerade i R. Skriv sqrt(6) i scriptet och spara. Kör koden och erhåll följande i Console. sqrt(6) [1] 2.44949 Även exponentialfunktionen \\(\\exp(x)\\) finns i R. Skriv exp(3) i script-filen, spara och kör. exp(3) [1] 20.08554 Konstanten \\(\\pi\\) finns i R. Skriv pi i script-filen, spara och kör. pi [1] 3.141593 Kod finns ofta på flera rader. Anta att vi önskar beräkna \\(2 + 2+ 3+ 5\\) men att koden inte får plats på en rad utan måste delas upp på två rader. Skriv in följande rader i scriptet, spara, markera bägge raderna och kör. # Kod över 2 rader 2 + 2 + 3 + 5 Följande resultat ska presenteras i Console. # Kod över 2 rader 2 + 2 + 3 + 5 [1] 12 Kod finns ofta på flera rader. Skriv in följande rader i scriptet, spara, markera bägge raderna och kör. Jämför resultatet med punkt 6! 2 + 2 + 3 + 5 Nu utvärderas raderna var för sig, vilket inte var avsikten med analysen. 2 + 2 [1] 4 + 3 + 5 [1] 8 Grattis! Du har nu genomfört din första session i R. Scriptet ska se ut enligt nedan. Spara och stäng R. # Detta är mitt första R-script som heter myfirstscript.R. # I detta script använder jag R som miniräknare samt # exekverar kod från scriptet. 1+1 1+3 2-7 2*3 4/5 3^2 # Kvadratroten sqrt(6) # Exponentialfunktionen exp(3) # Pi pi # Kod över 2 rader 2 + 2 + 3 + 5 2 + 2 + 3 + 5 2.4 Paket En viktig styrka med R är det stora antalet tillgängliga paket utvecklade av användare. Grundinstallationen av R är nämligen tämligen begränsad vad gäller funktionalitet, men med alla paket utvidgas den statistiska verktygslådan, de grafiska möjligheterna och förmågan att hantera olika typer av data rejält. Det finns ungefär 15000 paket på “The Comprehensive R Archive Network” (CRAN) som är Rs arkiv för paket: https://cran.r-project.org/web/packages/available_packages_by_name.html Det finns ytterligare tusentals andra paket som dock inte genomgått samma granskning som paketen på CRAN, till exempel på github. Eftersom antalet paket är överväldigande för nybörjaren kan det vara ett stöd att känna till de vanligaste paketen. Ett förslag på en lista över viktiga paket finns här: https://support.rstudio.com/hc/en-us/articles/201057987-Quick-list-of-useful-R-packages För att installera ett paket skriver man in paketnamnet med ett kommando alternativt använda menyn i RStudio under *Tools &gt; Install Packages**. Vi exemplifierar nu med ett paket som hjälper oss att läsa data från Excel-filer. Funktionalitet för inläsning från Excel-filer finns inte i basversionen av R, därför är detta paket nödvändigt om data är sparat i en Excelfil. Vi installerar paketet readxl genom att i Console skriva in install.packages(\"readxl\") och trycka enter. Som tidigare nämnt går det även att installera paket via menyn. Efter installationen finns paketet sparat på din dator. R har emellertid inte ännu aktiverat det. Genom att skriva library(\"readxl\") och trycka enter aktiveras paketet. Nu kan analyser i R utnyttja paketets funktionalitet. Observera att ett paket måste aktiveras på nytt varje gång RStudio öppnas. Dock behövs det bara installeras en enda gång. 2.5 Sammanfattning div.red{ background-color:#F5B7B1; border-radius: 5px; padding: 20px;} Du ska kunna installera R och Rstudio och starta det utan felmeddelanden. använda R som miniräknare och använda de olika metoderna för att exekvera kod i editorn. installera ett R-paket och aktivera det. 2.6 Övningar Övning 2.1 Du har ett stickprov betående av observationerna \\(4,-2,5,6,8\\). Beräkna medelvärdet. Beräkna standardavvikelsen. Beräkna variationsbredden. Beräkna det geometriska medelvärdet för de positiva värden \\(4, 5, 6, 8\\). Beräkna det geometriska medelvärdet för alla värden \\(4, -2, 5, 6, 8\\). Svar 2.1 Medelvärdet \\(\\bar{x}\\) beräknas i R i editorn med (4 + (-2) + 5 + 6 + 8)/5 vilket i Console ger svaret ## [1] 4.2 Svar: Medelvärdet är 4.2 Standardavvikelsen \\(s\\) beräknas i R i editorn antingen genom att direkt tillämpa formeln för stickprovets standardavvikelse \\[s=\\sqrt{\\dfrac{\\sum_{i=1}^n (x_i -\\bar{x})^2}{n-1}}\\] sqrt( ( ( 4 - (4 + (-2) + 5 + 6 + 8)/5 )^2 + ( (-2) - (4 + (-2) + 5 + 6 + 8)/5 )^2 + ( 5 - (4 + (-2) + 5 + 6 + 8)/5 )^2 + ( 6 - (4 + (-2) + 5 + 6 + 8)/5 )^2 + ( 8 - (4 + (-2) + 5 + 6 + 8)/5 )^2 ) / (5-1) ) eller genom att använda beräkningsformeln \\[s=\\sqrt{\\dfrac{\\sum_{i=1}^{n}x_i ^2 - (\\sum_{i=1}^n x_i)^2/n}{n-1}}\\]. sqrt( ( 4^2 + (-2)^2 + 5^2 + 6^2 + 8^2 - (4 + (-2) + 5 + 6 + 8)^2/5 )/ (5-1) ) Oavsett formel erhålls i Console svaret ## [1] 3.768289 Svar: Standardavvikelsen är 3.768 Variationsbredden, dvs skillnaden mellan det största och det minsta värdet är 8 - (-2) ## [1] 10 Svar: Variationsbredden är är 10. Det geometriska medelvärdet \\[\\bar{x}_g=(x_1\\cdot x_2 \\cdot \\cdots \\cdot x_n)^{1/n}\\] kan i R beräknas med (4 * 5 * 6 * 8)^(1/4) ## [1] 5.566315 Svar: Det geometriska medelvärdet är 3.95. Det geometriska medelvärdet \\[\\bar{x}_g=(x_1\\cdot x_2 \\cdot \\cdots \\cdot x_n)^{1/n}\\] kan i R beräknas med (4 * (-2) * 5 * 6 * 8)^(1/5) ## [1] NaN Svar: Eftersom en observation är negativ blir NaN, vilket betyder ‘’Not a Number’’. Det går alltså inte att beräkna. Övning 2.2 Ett slumpmässigt urval ger följande observationer \\(0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1\\),där \\(1=Arbetslös\\) och \\(0=Förvärvsarbetande\\). Beräkna andelen arbetslösa i stickprovet. Svar 2.2 Andelen arbetslösa beräkna i R med (0 + 1 + 1 + 0 + 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 1)/13 ## [1] 0.3846154 Svar: Andelen arbetslösa i stickprovet är 0.38. Övning 2.3 Kosumentpriset 2006-2011 är Table 2.1: Konsumentprisindex (KPI) 2006-2011 2006 284.2 2007 290.5 2008 300.6 2009 299.7 2010 303.5 2011 311.4 Med hur många procent har prisnivån förändrats från 2007 till 2010? Svar 2.3 Beräkning i R ger 303.46/290.51 ## [1] 1.044577 Svar: Prisnivån har ökat med 4.5%. Övning 2.4 Denna övningar handlar om potentslagarna. Då \\(x\\) och \\(y\\) är reella och \\(a,b&gt;0\\) gäller följande likheter: \\(a^x\\cdot a^y=a^{x+y}\\) \\((a^x)^y=a^{xy}\\) \\(\\left(\\frac{a}{b}\\right)^x=\\frac{a^x}{b^x}\\) \\(\\frac{a^x}{a^y}=a^{x-y}\\) \\(a^x \\cdot b^x=(ab)^x\\) \\(a^0=1\\) Beräkna nedanstående uttryck relatera svaren till potenslagarna. \\(4^2 + 4^3\\) \\(4^2*4^3\\) \\(4^5\\) \\((4^2)^3\\) \\(4^15\\) \\(4^2/4^3\\) \\(4^{-1}\\) \\(4^{-2}\\) \\(1/(4^2)\\) \\(1/16\\) \\(3^4*4^4\\) \\(12^4\\) Svar 2.4 I R kan uttrycken enkelt beräknas. 4^2 + 4^3 [1] 80 4^2*4^3 [1] 1024 4^5 [1] 1024 (4^2)^3 [1] 4096 4^15 [1] 1073741824 4^2/4^3 [1] 0.25 4^{-1} [1] 0.25 4^{-2} [1] 0.0625 1/(4^2) [1] 0.0625 1/16 [1] 0.0625 3^4*4^4 [1] 20736 12^4 [1] 20736 Vi ser att för \\(b= c\\) pga 1. \\(d= e\\) pga 2. \\(k=l\\) pga 5. Vidare gäller… Övning 2.5 Den naturliga logaritmen, dvs logaritmen med basen \\(e \\approx 2.718282\\), används ofta i statistiska beräkningar. Några logaratimlagar som gäller för naturliga logaritmen är: \\(\\ln\\, \\left (x\\cdot y \\right )=\\ln\\,x+\\ln\\,y\\) \\(\\ln\\, \\left (x/ y \\right )=\\ln\\,x-\\ln\\,y\\) \\(\\ln\\,x^{a}=a\\cdot \\ln\\,x\\) \\(\\ln e = 1\\) \\(e^{\\ln x} = x\\) \\(\\ln^{e^x} = x\\) Beräkna nedanstående uttryck och relatera svaren till logaritmlagarna \\(\\ln(3*4)\\) \\(\\ln(3) + \\ln(4)\\) \\(\\ln(3/4)\\) \\(\\ln(3) - \\ln(4)\\) \\(\\ln e\\) \\(\\ln e^5\\) \\(e^{5+6}\\) \\(e^5*e^6\\) $5 5 + 6 6 Svar 2.5 I R kan uttrycken enkelt beräknas. log(3*4) [1] 2.484907 log(3) + log(4) [1] 2.484907 log(3/4) [1] -0.2876821 log(3) - log(4) [1] -0.2876821 log(exp(1)) [1] 1 log(exp(5)) [1] 5 exp(5+6) [1] 59874.14 exp(5)*exp(6) [1] 59874.14 5*log(5) + 6*log(6) [1] 18.79775 Övning 2.6 Låt observationerna \\(4,-2,5,6,8\\) vara obundet slumpmässigt urval från en normalfördelad population. Genomför en hypotesprövning på 5% signifikansnivå för att testa medelvärdet i population är skild från 1. Svar 2.6 Vi observerar \\(x=\\{4,-2,5,6,8\\}.\\) Hypoteser: \\(H_0:\\mu=0\\) vs \\(H_1:\\mu \\neq 0\\) Antaganden: Variabeln \\(x\\) är normalfördelad i populationen. Populationsvariansen \\(\\sigma^2\\) är okänd i populationen. Vi har ett litet stickprov, \\(n=5\\). Testfunktionen ges av \\(t=\\dfrac{\\bar{x}-\\mu}{\\sqrt{s^2/n}}\\). Denna teststatistika är \\(t\\)-fördelad med \\(n-1\\) frihetsgrader om nollhypotesen är sann. Beslutregel: \\(\\alpha=0.05\\). Tvåsidigt test, förkasta därför \\(H_0\\) om \\(|t_{obs}| &gt; t_{krit} = t_{4,\\alpha/2=0.025} = 2.776\\) ( (4 + (-2) + 5 + 6 + 8)/5 - 1 )/sqrt( ( 4^2 + (-2)^2 + 5^2 + 6^2 + 8^2 - (4 + (-2) + 5 + 6 + 8)^2/5 )/ (5-1)/5 ) [1] 1.898851 Eftersom \\(t_{obs}=\\) 1.8988507 \\(&lt; 2.776 = t_{krit}\\) kan vi inte förkasta nollhypotesen. Svar: Vi kan på 5% signifikansnivå inte påvisa att medelvärdet i populationen är skilt från 1. Notera att detta inte innebär att vi visar att medelvärdet är 1. Övning 2.7 Du observerar följande datapunkter \\(x = \\{4,7,2,4,6\\}\\) och $y={7,3, 2, 5,6}$. Använd minsta-kvadratmetoden och beräkna koefficienterna \\(a\\) och \\(b\\) i regressionslinjen \\(y=a + bx\\). Använd koefficienterna och ge en prediktion för \\(y\\) givet att \\(x=7\\). Beräkna residualen för \\(x=7\\) Beräkna residualspridningen. Svar 2.7 Riktningskoefficienten ges av \\[b=\\dfrac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i - \\bar{x})^2}\\] # Direkt tillämpning av formeln ger ( (4 - (4 + 7 + 2 + 4 + 6)/5) * (7 - (7 + 3 + 2 + 5 + 6)/5) + (7 - (4 + 7 + 2 + 4 + 6)/5) * (3 - (7 + 3 + 2 + 5 + 6)/5) + (2 - (4 + 7 + 2 + 4 + 6)/5) * (2 - (7 + 3 + 2 + 5 + 6)/5) + (4 - (4 + 7 + 2 + 4 + 6)/5) * (5 - (7 + 3 + 2 + 5 + 6)/5) + (6 - (4 + 7 + 2 + 4 + 6)/5) * (6 - (7 + 3 + 2 + 5 + 6)/5) ) / ( (4 - (4 + 7 + 2 + 4 + 6)/5)^2 + (7 - (4 + 7 + 2 + 4 + 6)/5)^2 + (2 - (4 + 7 + 2 + 4 + 6)/5)^2 + (4 - (4 + 7 + 2 + 4 + 6)/5)^2 + (6 - (4 + 7 + 2 + 4 + 6)/5)^2 ) [1] 0.2105263 # Det går att räkna ut detta i flera steg genom att # t ex beräkna täljare och nämnare separat. # Alternativt använda beräkningsformeln ( 4*7 + 7*3 + 2*2 + 4*5 + 6*6 - (4+7+2+4+6)*(7+3+2+5+6)/5 )/ ( (4^2 + 7^2 + 2^2 + 4^2 + 6^2) - (4 + 7 + 2 + 4 + 6)^2/5 ) [1] 0.2105263 # En kommentar: Dessa beräkningar kommer förenklas betydligt i R, vilket vi ska se senare. Interceptet är \\(a=\\bar{y} - b\\bar{x}\\) (7 + 3 + 2 + 5 + 6)/5 - 0.2105*(4 + 7 + 2 + 4 + 6)/5 [1] 3.6317 Svar: Riktningskoefficienten beräknas till \\(b=0.2105\\), vilket tolkas som att om \\(x\\) ökar en enhet så ökar \\(y\\) i genomsnitt med \\(0.2105\\) enheter. Interceptet beräknas till \\(a=3.632\\), vilket tolkas som medelvärdet för \\(y\\) när \\(x=0\\). Använd koefficienterna från regressionslinjen och sätt in värdet \\(x=7\\). 3.6316 + 0.2105*7 [1] 5.1051 Svar: Prediktionen \\(\\hat{y}=\\) 5.1051. Detta är punkten på regressionslinjen när \\(x=7\\) och vår bästa gissning för det \\(y\\)-värde en individ med värdet \\(x=7\\) kommer att ha. En residual är skillnaden mellan ett predicerat värde och det faktiska observerade värdet, \\(\\hat{\\varepsilon}=y_i - \\hat{y}\\). Eftersom \\(y=3\\) när \\(x=7\\) så residualen 3 - (3.6316 + 0.2105*7) [1] -2.1051 Svar: Residualen för \\(x=7\\) är -2.1051. Residualspridningen ges av \\[s_\\varepsilon=\\sqrt{\\dfrac{\\sum_{i=1}^n(y_i - \\hat{y}_i)^2}{n-2}}= \\sqrt{\\dfrac{\\sum_{i=1}^n\\hat{\\varepsilon}_i^2}{n-2}}\\]. Vi beräknar på samma sätt som i c) övriga residualer, kvadrerar och summerar. sqrt( ( (7 - (3.6316 + 0.2105*4))^2 + (3 - (3.6316 + 0.2105*7))^2 + (2 - (3.6316 + 0.2105*2))^2 + (5 - (3.6316 + 0.2105*4))^2 + (6 - (3.6316 + 0.2105*6))^2 ) / (5 - 2) ) [1] 2.347077 Svar: Residualspridningen är 2.347 (Notera att \\(\\sum_{i=1}^n \\hat{\\varepsilon}_i^2\\) kallas för residualkvadratsumman.) Övning 2.8 Installera paketet MASS som innehåller funktioner som kan vara användbara senare på kursen. Aktivera det installerade paketet MASS. Svar 2.8 # Installera paket install.packages(&quot;psych&quot;) # Aktivera paket library(&quot;psych&quot;) "],
["data-objekt-och-funktioner.html", "Kapitel 3 Data, objekt och funktioner 3.1 Data och objekt 3.2 Vektorer 3.3 Matriser 3.4 Data frames 3.5 Funktioner 3.6 Sammanfattning 3.7 Övningar", " Kapitel 3 Data, objekt och funktioner För att kunna arbeta med statistik och dataanalys är det viktigt att inte enbart förstå den statistiska metoden och kunna lösa problem med hjälp av en miniräknare. I praktiken är det även nödvändigt att förstå hur data hanteras, lagras och struktureras. I detta kapitel introduceras typer av data som normalt hanteras i R, sedan följer avsnitt om de olika typer av objekt som finns i R. Kapitlet avslutas med se på vad en funktion i R är för något och hur funkioner kan användas för att hantera objekt. Detta är ett omfattande kapitel, men det är viktigt att du kan hantera allt som presenteras. Avsikten med kaptitlet är nämligen att ta upp de allra vanligaste. 3.1 Data och objekt Utan data är statistik innehållslöst. På samma sätt är data grundläggande för arbete i R. De vanligaste datatyperna i R är character (text), som anges med citationstecken t ex “a”, “3”. numeric (decimaltal), t ex är 3, 32.1. Notera att 3 kan skriva 3.0. integer (heltal). 3, 32. Skillnaden mellan numeric och integer är att inga decimaler sparas, vilket spar minne. logical (data indikerar om något är sant eller falskt, TRUE/FALSE). Observera att dessa datatyper beskriver hur data är lagrad och hur R ska tolka data. Det säger sig kanske självt att det inte går att använda räkneoperation om data är character (text). Datatyper ska inte förväxlas med de datanivåer (nominal, ordinal, intervall och kvotskala) som man normalt förknippar med statistiska analyser. Datatyper ska inte heller förväxlas med om data är diskreta, kontinuerliga, kategorier eller kvantitativa. Det är mycket viktigt för alla som arbetar med statistiska analyser av data att kunna tillämpa alla ovanstående begrepp på rätt situation. Ofta överlappar begreppen, men det är vanligt att begreppen inte gör det. Tabellen nedan ger en översikt av begreppen som används, men notera att det finns undantag från denna klassificering och det finns andra sätt att klassificera. Mätskala Variabeltyp Datatyp i R Nominal Kategori, kvalitativ Character, factor med ordered = FALSE Ordinal Kategori, kvalitativ Character, factor med ordered = TRUE Intervall Kvantitativ, kontinuerlig, heltal, diskret Numeric, integer Kvot Kvantitativ, kontinuerlig, heltal, diskret Numeric, integer Data hanteras och sparas som objekt. För att skapa ett objekt används assignment-operatorn &lt;-. Objektet sparas därmed i minnet i R, men inget resultat redovisas i Console. Om R stängs ner måste objektet skapas på nytt såvida användaren inte har angett att objektet ska sparas. I regel arbetar man i R med flera olika objekt samtidigt. Objekten måste därför namnges och precis som Vid all programmering är noggrannhet a och o. Objektnamn inleds med en bokstav och får endast innehålla bokstäver, siffror, _ och .. Dessutom skiljer R på versaler och gemener. Det är inte alltid enkelt att namnge objekt, men det viktigaste är att vara konsekvent. På denna kurs rekommenderas följande principer för namngivning av objekt. Använd endast gemener. korta och logiska namn, t ex kan objektet population förkortas till pop. gärna understreck _ för sammanbinda långa objektnamn. Objektet ålder för kvinnor skulle kunna betecknas age_women och motsvarande för män är då age_men. Använd inte å, ä och ö. inte namn som redan är upptagna i R, t ex exp eller log. Det tre vanligaste objekten för hantering av data är: vektorer, matriser, data frames. 3.2 Vektorer En vektor är ett dataobjekt som är endimensionellt och består av \\(n\\) element. En vektor skapas med kommandot c() (‘’Combine Values into a Vector’’). Anta att vi observerar värdena \\(3,-1,1,5,0\\). Med hjälp av nedanstående kod skapas ett vektor-objekt med med 5 element: # Skapa din första numeriska vektor my__first_vec &lt;- c(3, -1, 1, 5, 0) Notera att inget visas i Console, men att objektet finns sparat i minnet upptäcker man i RStudio genom att observera den övre högra panelen under fliken Environment. Där listas alla objekt som finns sparade i minnet i R. För att titta på objektet exekveras objektet genom att köra nedanstående kod. &gt; # Visa din första numeriska vektor &gt; my__first_vec &gt; [1] 3 -1 1 5 0 Du ska nu skapa ett antal vektorobjekt som sedan på olika sätt ska manipuleras. Skapa ett script som heter kap3_objekt_och_funktioner.R genom att välja File &gt; New File &gt; R Script och sedan direkt spara scriptet med File &gt; Save As i mappen A5Rkod. Skriv in koden nedan i scriptet och spara med File &gt; Save. Det är bra att få rutin på att ofta spara sitt script så att inte kod råkar försvinna. # Skapar två numeriska vektorer x &lt;- c(3, 1, 1, 5, 0) y &lt;- c(2, 3, 5, 6, 9) # Kombinera vektorer till en ny vektor z &lt;- c(x, y) Generellt gäller i R att om \\(x\\) är en vektor bestående av \\(k\\) element \\[x = (x_1,x_2,\\ldots,x_k)\\] och \\(y\\) är en vektor bestående av \\(l\\) element \\[y = (y_1,y_2,\\ldots,y_l)\\] så skapar kommandot z &lt;- c(x,y) en vektor med \\(k + l\\) element, \\[z= (x_1,x_2,\\ldots,x_k,y_1,y_2,\\ldots,y_l)=(z_1,z_2,\\ldots,z_{k+l}).\\] För att se om detta stämmer tittar vi på objekten genom att exekvera dem. Fortsätt scriptet genom att skriva in nedanstående kod. Spara och kör koden. x y z I Console ser du då följande: &gt; x &gt; [1] 3 1 1 5 0 &gt; y &gt; [1] 2 3 5 6 9 &gt; z &gt; [1] 3 1 1 5 0 2 3 5 6 9 Både \\(x\\), \\(y\\) och \\(z\\) är numeriska vektorer. Det går även att skapa en vektor bestående av bokstäver. För att skapa en sådan vektor (character vector) sätts de enskilda elementen inom citationstecken. Fortsätt scriptet och skriv in nedanstående kod i scriptet, spara och kör koden. # Skapar en vektor med ord nordic_countries &lt;- c(&quot;Denmark&quot;, &quot;Finland&quot;, &quot;Iceland&quot;, &quot;Norway&quot;, &quot;Sweden&quot;) nordic_countries I Console ser du då följande resultat. &gt; # Skapar en vektor med ord &gt; nordic_countries &lt;- c(&quot;Denmark&quot;, &quot;Finland&quot;, &quot;Iceland&quot;, &quot;Norway&quot;, &quot;Sweden&quot;) &gt; nordic_countries &gt; [1] &quot;Denmark&quot; &quot;Finland&quot; &quot;Iceland&quot; &quot;Norway&quot; &quot;Sweden&quot; Kombineras en numerisk och en character-vektor blir hela vektorn en character-vector. Skriv följande kod i scriptet, spara och kör koden. # Kombinera en numerisk vektor med en vektor med ord x_nordic_countries &lt;- c(x, nordic_countries ) x_nordic_countries I Console erhålls följande output och vi ser att de tidigare numeriska värdena nu omges av citationstecken. &gt; # Kombinera en numerisk vektor med en vektor med ord &gt; x_nordic_countries &lt;- c(x, nordic_countries ) &gt; x_nordic_countries &gt; [1] &quot;3&quot; &quot;1&quot; &quot;1&quot; &quot;5&quot; &quot;0&quot; &quot;Denmark&quot; &quot;Finland&quot; &gt; [8] &quot;Iceland&quot; &quot;Norway&quot; &quot;Sweden&quot; Om en numerisk vektor kombineras med en vektor med bokstäver så blir hela vektorn en character-vektor. R tolkas alltså siffrorna som bokstäver/tecken utan relation till numeriska värden. Det ser vi genom att det finns finns citationstecken kring siffrorna. Vi ska nu se introducera hur man på andra sätt kan skapa vektorer typer av vektorer. Skriv in nedanstående kod i scriptet och spara. Kör koden. # Skapar en vektor med värdena 1,2,3,4,5 v &lt;- 1:5 # Skapar en vektor med endast ett element u &lt;- 150 # Skapar en vektor med ett bortfall. ymis &lt;- c(3, NA, 6, 3, 6) I Console visas &gt; # Skapar en vektor med värdena 1,2,3,4,5 &gt; v &lt;- 1:5 &gt; # Skapar en vektor med endast ett element &gt; u &lt;- 150 &gt; # Skapar en vektor med ett bortfall. &gt; ymis &lt;- c(3, NA, 6, 3, 6) För att sammanfatta så har vi har hittills skapat numeriska vektorer, vektorer som enbart innehåller bokstäver och vektorer som skapats genom sekvenser. Vidare finns vektorer med bortfall anges med NA (Not Available). div.green{ background-color:#abd4b3; border-radius: 5px; padding: 20px;} En vektor som innehåller enbart en datatyp kallas för atomic. Detta kan vara värt att känna till eftersom eftersom det är vanligt att felmeddelande referar till just att en vektor inte är atomic. Inled en rad med # för att kommentera kod. Kommentera alltid kod!. Vid all programmering är det viktigt att förklara kod så att du själv och andra snabbt förstår vad koden gör. Det är viktigt att få rutin på att kommentera, kommentera därför även enkel kod. Nya vektorer kan skapas med räkneoperationer. Beräkningarna sker då elementvis, till exempel adderas elementvärden i en vektor till elementvärden i en annan vektor som har motsvarade position. Vektorerna måste antingen ha lika många element eller att den enda vektorna består av en konstant. Skriv in nedanstående i ditt script, spara och kör. # Addition av x och y x + y # Multiplikation av x och y x * y # Potenser skrivs med a^b y^2 # En konstant u adderas till alla element i vektorn x + u # Räkneoperationer med NA ger NA x + ymis # Division med 0 är ej definierat. R anger det som Inf (infinity) # eller NaN (Not a Number) om det är 0/0. x/0 # Exempel på längre räkneoperationer. # Notera att alla beräkningar är elementvisa. w &lt;- x + (y^2 - u)/v w I Console visas &gt; # Addition av x och y &gt; x + y &gt; [1] 5 4 6 11 9 &gt; # Multiplikation av x och y &gt; x * y &gt; [1] 6 3 5 30 0 &gt; # Potenser skrivs med a^b &gt; y^2 &gt; [1] 4 9 25 36 81 &gt; # En konstant u adderas till alla element i vektorn &gt; x + u &gt; [1] 153 151 151 155 150 &gt; # Räkneoperationer med NA ger NA &gt; x + ymis &gt; [1] 6 NA 7 8 6 &gt; # Division med 0 är ej definierat. R anger det som Inf (infinity) &gt; # eller NaN (Not a Number) om det är 0/0. &gt; x/0 &gt; [1] Inf Inf Inf Inf NaN &gt; # Exempel på längre räkneoperationer. &gt; # Notera att alla beräkningar är elementvisa. &gt; w &lt;- x + (y^2 - u)/v &gt; w &gt; [1] -143.00000 -69.50000 -40.66667 -23.50000 -13.80000 Ovanstående illustrerar att genom att användning av objekt kan beräkningar förenklas. Nu ska vi se vad som händer om elemementen består av olika antal element. Skriv i Console in nedanstående kod och tryck enter. x + c(2,5,6) I Console visas &gt; x + c(2,5,6) &gt; Warning in x + c(2, 5, 6): longer object length is not a multiple of shorter &gt; object length &gt; [1] 5 6 7 7 5 Detta innebär att om vektorn \\(x\\) (innehållande 5 element) adderas till en vektor bestående av endast 3 element, dvs antalet element skiljer sig åt, erhålls ett felmeddelande. Det gäller oavsett räknesätt. Om däremot den ena vektorn är en konstant, som i exemplet med vektorn \\(u\\) ovan, fungerar beräkningarna genom att konstanten beräknas för alla element i den större vektorn. 3.2.1 Vektorer och indexering Vi ska nu presentera hur enskilda element kan väljas ut i vektorer. Eftersom data i praktiken alltid måste anpassas för planerade analyser är detta nödvändigt. Det mest grundläggande i hantering av vektorer är att konstatera att varje element i en vektor har en position. Med hakparenteser [] erhålls åtkomst till ett eller flera element. Skriv in nedanstående i ditt script, spara och kör. # Visa element nummer 2 i vektorn x x[2] # Visa element 2, 3 och 4 i vektorn y y[c(2,3,4)] I Console redovisas &gt; # Visa element nummer 2 i vektorn x &gt; x[2] &gt; [1] 1 &gt; # Visa element 2, 3 och 4 i vektorn y &gt; y[c(2,3,4)] &gt; [1] 3 5 6 Det går även att spara utvalda element till en ny vektor. Skriv in nedanstående i ditt script. # Spara element nummer 2 i vektorn x2 x2 &lt;- x[2] x2 # Visa element 2, 3 och 4 i vektorn y234 y234 &lt;- y[c(2,3,4)] y234 I Console redovisas &gt; # Spara element nummer 2 till vektorn x2 &gt; x2 &lt;- x[2] &gt; x2 &gt; [1] 1 &gt; # Spara element 2, 3 och 4 till vektorn y234 &gt; y234 &lt;- y[c(2,3,4)] &gt; y234 &gt; [1] 3 5 6 Det går att tillämpa negativ indexering för att exkludera angivna element. Resterande element i en vektor behålls då. Skriv in nedanstående i scriptet, spara, och kör. # Spara element nummer 1,3,4,5 till vektorn x1345 x1345 &lt;- x[-2] x1345 # Spara element 1 och 5 till vektorn y15 y15 &lt;- y[-c(2,3,4)] y15 I Console redovisas nedanstående. &gt; # Spara element nummer 1,3,4,5 till vektorn x1345 &gt; x1345 &lt;- x[-2] &gt; x1345 &gt; [1] 3 1 5 0 &gt; # Spara element 1 och 5 till vektorn y15 &gt; y15 &lt;- y[-c(2,3,4)] &gt; y15 &gt; [1] 2 9 En viktigt skäl till att identifiera element är att användaren då på ett enkelt sätt kan hantera värden som identifierade element har. Skriv i nedanstående i scriptet, spara och kör. # Ändra element 3 från 1 till 4 x_new &lt;- x x_new[3] &lt;- 4 x_new # Ändra element 3 från &quot;Iceland&quot; till 4 nordic_countries_new &lt;- nordic_countries nordic_countries_new[3] &lt;- 4 nordic_countries_new I Console redovisas nedanstående. &gt; # Ändra element 3 från 1 till 4 &gt; x_new &lt;- x &gt; x_new[3] &lt;- 4 &gt; x_new &gt; [1] 3 1 4 5 0 &gt; # Ändra element 3 från &quot;Iceland&quot; till 4 &gt; nordic_countries_new &lt;- nordic_countries &gt; nordic_countries_new[3] &lt;- 4 &gt; nordic_countries_new &gt; [1] &quot;Denmark&quot; &quot;Finland&quot; &quot;4&quot; &quot;Norway&quot; &quot;Sweden&quot; Ovanstående kod illustrerar två vanliga företeelser: Vektorerna x_new och nordic_countries_new skapas på grund av att användaren ofta önskar behålla originalvektorerna x och nordic_countries. Detta är ofta önskvärt. Om ett numeriskt värde läggs till en vektor med bokstäver så tolkas det numeriska värdet som ett tecken, dvs “4”. Det illustrerar vikten av vara noga med om vektorerna är numeriska eller character 3.2.2 Vektorer och logiska operatorer Istället för att direkt identifiera positionen i vektorn kan man använda logiska operatorer. Några vanliga och viktiga logiska operatorer är: &lt; är mindre än. &gt; är mindre än. &gt;= större än eller lika med &lt;= mindre än eller lika med == lika med. != är ej lika med x|y \\(x\\) eller \\(y\\) x &amp; y \\(x\\) och \\(y\\) Genom att använda dessa kan användaren direkt hantera data i vektorn. Fortsätt scriptet genom att skriva in nedanstående kod. Spara och kör koden. # Visa element i vektor y som är större än 6 y[y &gt; 6] # Visa element i vektor y som är större än eller lika med 6 y[y &gt;= 6] # Visa element i vektor y från positioner där x har värden lika med 1. # (Kräver att x och y har lika många element) y[x == 1] # Visa element i vektor där x är ej lika med 1. y[x != 1] # Visa element i vektor y från positioner där nordic_countries == &quot;Finland&quot; y[nordic_countries == &quot;Finland&quot;] I Console visas &gt; # Visa element i vektor y som är större än 6 &gt; y[y &gt; 6] &gt; [1] 9 &gt; # Visa element i vektor y som är större än eller lika med 6 &gt; y[y &gt;= 6] &gt; [1] 6 9 &gt; # Visa element i vektor y från positioner där x har värden lika med 1. &gt; # (Kräver att x och y har lika många element) &gt; y[x == 1] &gt; [1] 3 5 &gt; # Visa element i vektor där x är ej lika med 1. &gt; y[x != 1] &gt; [1] 2 6 9 &gt; # Visa element i vektor y från positioner där nordic_countries == &quot;Finland&quot; &gt; y[nordic_countries == &quot;Finland&quot;] &gt; [1] 3 Precis som förut skapas i regel nya vektorer när logiska operatorer tillämpas. Skriv in nedanstående i scriptet, spara och kör koden. # Välj vektorn som är större än eller lika med 6 ysub &lt;- y[y &gt;= 6] # Skapa en binär vektor x_bin som är 1 om x är större än eller lika med 3 och 0 # om x är mindre än 3. Börja med att skapa en tom vektor med motsvarande antal element # och fyll sedan denna med saknade värden. x_bin &lt;- c(NA, NA, NA, NA, NA) x_bin[x &gt;=3] &lt;- 1 x_bin[x &lt; 3] &lt;- 0 # Skapa en tom vektor med 5 element och fyll därefter denna vektor med # data om landet är skandinaviskt eller ej scandinavia &lt;- c(NA, NA, NA, NA, NA) scandinavia[nordic_countries == &quot;Finland&quot;] &lt;- &quot;Not scandinavia&quot; scandinavia[nordic_countries == &quot;Denmark&quot;] &lt;- &quot;Scandinavia&quot; scandinavia[nordic_countries == &quot;Sweden&quot;] &lt;- &quot;Scandinavia&quot; scandinavia[nordic_countries == &quot;Norway&quot;] &lt;- &quot;Scandinavia&quot; scandinavia[nordic_countries == &quot;Iceland&quot;] &lt;- &quot;Not scandinavia&quot; scandinavia I Console visas &gt; # Välj vektorn som är större än eller lika med 6 &gt; ysub &lt;- y[y &gt;= 6] &gt; &gt; # Skapa en binär vektor x_bin som är 1 om x är större än eller lika med 3 och 0 &gt; # om x är mindre än 3. Börja med att skapa en tom vektor med motsvarande antal element &gt; # och fyll sedan denna med saknade värden. &gt; x_bin &lt;- c(NA, NA, NA, NA, NA) &gt; x_bin[x &gt;=3] &lt;- 1 &gt; x_bin[x &lt; 3] &lt;- 0 &gt; x &gt; [1] 3 1 1 5 0 &gt; x_bin &gt; [1] 1 0 0 1 0 &gt; # Skapa en tom vektor med 5 element och fyll därefter denna vektor med &gt; # data om landet är skandinaviskt eller ej &gt; scandinavia &lt;- c(NA, NA, NA, NA, NA) &gt; scandinavia[nordic_countries == &quot;Finland&quot;] &lt;- &quot;Not scandinavia&quot; &gt; scandinavia[nordic_countries == &quot;Denmark&quot;] &lt;- &quot;Scandinavia&quot; &gt; scandinavia[nordic_countries == &quot;Sweden&quot;] &lt;- &quot;Scandinavia&quot; &gt; scandinavia[nordic_countries == &quot;Norway&quot;] &lt;- &quot;Scandinavia&quot; &gt; scandinavia[nordic_countries == &quot;Iceland&quot;] &lt;- &quot;Not scandinavia&quot; &gt; scandinavia &gt; [1] &quot;Scandinavia&quot; &quot;Not scandinavia&quot; &quot;Not scandinavia&quot; &quot;Scandinavia&quot; &gt; [5] &quot;Scandinavia&quot; OVanstående moment är viktigt. Här illustreras nämligen en grundläggande princip för skapandet av nya variabel, dvs först skapa en tom vektor som sedans fylls med information. Även om det finns alternativa kompaktare sätt att koda om vektorer (och följaktligen variabler), är det ovanstående tillvägagångssätt som rekommenderas starkt på denna kurs. Nästa steg är att använda den logiska operatorn &amp;. Skriv in nedanstående i scriptet, spara och kör koden. # Skapa en vektor z_trinary som är # 1 om z är mindre än eller lika med 1 # 2 om z är större än 1 eller mindre än eller lika med 5 # 3 om z är större än 5 z_trinary &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) z_trinary[z &lt;= 1] &lt;- 1 z_trinary[(z &gt; 1) &amp; (z &lt;=5)] &lt;- 2 z_trinary[z &gt; 5] &lt;- 3 z z_trinary # Skapa en binära variabler z1, z2 och z3 z1 &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) z1[z_trinary == 1] &lt;- 1 z1[z_trinary == 2] &lt;- 0 z1[z_trinary == 3] &lt;- 0 z2 &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) z2[z_trinary == 1] &lt;- 0 z2[z_trinary == 2] &lt;- 1 z2[z_trinary == 3] &lt;- 0 z3 &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) z3[z_trinary == 1] &lt;- 0 z3[z_trinary == 2] &lt;- 0 z3[z_trinary == 3] &lt;- 1 z1 z2 z3 I Console redovisas följande. &gt; # Skapa en vektor z_trinary som är &gt; # 1 om z är mindre än eller lika med 1 &gt; # 2 om z är större än 1 eller mindre än eller lika med 5 &gt; # 3 om z är större än 5 &gt; z_trinary &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) &gt; z_trinary[z &lt;= 1] &lt;- 1 &gt; z_trinary[(z &gt; 1) &amp; (z &lt;= 5)] &lt;- 2 &gt; z_trinary[z &gt; 5] &lt;- 3 &gt; z &gt; [1] 3 1 1 5 0 2 3 5 6 9 &gt; z_trinary &gt; [1] 2 1 1 2 1 2 2 2 3 3 &gt; &gt; # Skapa en binära variabler z1, z2 och z3 &gt; z1 &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) &gt; z1[z_trinary == 1] &lt;- 1 &gt; z1[z_trinary == 2] &lt;- 0 &gt; z1[z_trinary == 3] &lt;- 0 &gt; &gt; z2 &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) &gt; z2[z_trinary == 1] &lt;- 0 &gt; z2[z_trinary == 2] &lt;- 1 &gt; z2[z_trinary == 3] &lt;- 0 &gt; &gt; z3 &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) &gt; z3[z_trinary == 1] &lt;- 0 &gt; z3[z_trinary == 2] &lt;- 0 &gt; z3[z_trinary == 3] &lt;- 1 &gt; z1 &gt; [1] 0 1 1 0 1 0 0 0 0 0 &gt; z2 &gt; [1] 1 0 0 1 0 1 1 1 0 0 &gt; z3 &gt; [1] 0 0 0 0 0 0 0 0 1 1 Ett par viktiga punkter att komma ihåg är Arbetsgången är att en ny vektor skapas, vilken sedan fylls på. För en binär variabel skulle vi teoretiskt kunna använda operatorn !=, men detta kan dels leda till att NA i en vektor kodas till 0, dels att datatvätten blir mindre noggrann. Ovanstående metodik för att skapa ny variabler är transparent. Använd parenteser för att undvika eventuella fel, som till exempel var fallet med (z &gt; 1) &amp; (z &lt;= 5). Avslutningsvis ska vi använda den logiska operatorn |. Skriv in nedanstående i scriptet, spara och kör koden. # Om z1 = 1 eller z3 = 1, så ska w_bin = 1. # Om z2 = 1 så ska d_bin = 0. # Skapa en tom vektor w_bin d_bin &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) d_bin[(z1 == 1) | (z3 == 1)] &lt;- 1 d_bin[z2 == 1] &lt;- 0 z1 z2 z3 w_bin # Om landet är Norge eller Island och x &gt; 4 eller w &gt; -50 så ska vi sätta NA y_new &lt;- y y_new[( (nordic_countries == &quot;Iceland&quot;) | (nordic_countries == &quot;Norway&quot;) ) &amp; ( (x &gt; 4) | (w &gt; -50) ) ] &lt;- NA nordic_countries x w y_new I Console ser vi utskrifterna. Om du inte har förstått koden, så kan du jämföra vektorerna och se varför w_bin och y_new har fått de värden som de har. # Om z1 = 1 eller z3 = 1, så ska w_bin = 1. # Om z2 = 1 så ska d_bin = 0. # Skapa en tom vektor w_bin d_bin &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) d_bin[(z1 == 1) | (z3 == 1)] &lt;- 1 d_bin[z2 == 1] &lt;- 0 z1 z2 z3 w_bin # Om landet är Norge eller Island och x &gt; 4 eller w &gt; -50 så ska vi sätta NA y_new &lt;- y y_new[( (nordic_countries == &quot;Iceland&quot;) | (nordic_countries == &quot;Norway&quot;) ) &amp; ( (x &gt; 4) | (w &gt; -50) ) ] &lt;- NA nordic_countries x w y_new Ovanstående sätt att förändra och skapa vektorer används mycket ofta i R och kan hantera mycket av den praktiska datahantering som du kommer att stöta på under denna kurs, men också ute i arbetslivet. Som tidigare nämnts finns andra sätt att åstadkomma samma resultat, som kanske till och med i specifika avseenden bättre, men utgå på denna kurs från kod som presenteras här. Det bör nämnas att det naturligtvis finns mycket mer att lära sig om hur logiska operatorer fungerar. Till exempel skapar nedanstående kod den sista datatypen som nämndes inledningsvis, dvs logical data. Skriv in nedanstående i scriptet, spara och kör koden. # Ger en logisk vektor (x &gt; 4) ## [1] FALSE FALSE FALSE TRUE FALSE # Multiplikation med en logisk vektor 1*(x &gt; 4) ## [1] 0 0 0 1 0 4*(x &gt; 4) ## [1] 0 0 0 4 0 Spara scriptet kap3_objekt_och_funktioner.R. 3.3 Matriser En matris är ett tvådimensionellt dataobjekt bestående av rader och kolumner. Notera ordningen, dvs en matris storlek anges först med rader, sedan med kolumner. Analogt med c(), som kombinerar element till en vektor, används rbind() och cbind() för att binda ihop vektorer radvis eller kolumnvis till matriser. En matris måste innehålla element av samma datatyp, vilket innebär att det inte går att binda samman numeriska vektorer som med vektorer som innehåller bokstäver. En matris kan även skapas direkt med kommandot matrix() som transformerar en vektor med \\(k\\) antal element till en matris bestående motsvarande antal element fördelat på antal rader och kolumner. Fortsätt scriptet kap3_objekt_och_funktioner.R och skriv in nedanstående kod. Spara scriptet och kör. # Skapa en matris genom att binda samman x och y radvis. Matrisen får 2 rader och 5 kolumner m1 &lt;- rbind(x, y) m1 # Skapa en matris genom att binda samman x, y, n och x radvis. Matrisen får 5 rader och 4 kolumner. m2 &lt;- cbind(x, y, n, x) m2 # Skapa en matris genom att binda samman x och ymis radvis. Matrisen får 5 rader och 2 kolumner. m3 &lt;- rbind(x, ymis) m3 # Skapa med matrix() en matris med två rader och 5 kolumner. # Matrisen fylls på kolumnvis och notera att detta inte blir samma som m1. m4 &lt;- matrix(z, 2, 5) m4 # Skapa med matrix() en matris med fem rader och 2 kolumner. # I detta fall är de två första kolumnerna i m2 samma som m5. m5 &lt;- matrix(z, 5, 2) m5 I Console visas &gt; # Skapa en matris genom att binda samman x och y radvis. Matrisen får 2 rader och 5 kolumner &gt; m1 &lt;- rbind(x, y) &gt; m1 &gt; [,1] [,2] [,3] [,4] [,5] &gt; x 3 1 1 5 0 &gt; y 2 3 5 6 9 &gt; # Skapa en matris genom att binda samman x, y, n och x radvis. Matrisen får 5 rader och 4 kolumner. &gt; m2 &lt;- cbind(x, y, u, x) &gt; m2 &gt; x y u x &gt; [1,] 3 2 150 3 &gt; [2,] 1 3 150 1 &gt; [3,] 1 5 150 1 &gt; [4,] 5 6 150 5 &gt; [5,] 0 9 150 0 &gt; # Skapa en matris genom att binda samman x och ymis radvis. Matrisen får 5 rader och 2 kolumner. &gt; m3 &lt;- rbind(x, ymis) &gt; m3 &gt; [,1] [,2] [,3] [,4] [,5] &gt; x 3 1 1 5 0 &gt; ymis 3 NA 6 3 6 &gt; # Skapa med matrix() en matris med två rader och 5 kolumner. &gt; # Matrisen fylls på kolumnvis och notera att detta inte blir samma som m1. &gt; m4 &lt;- matrix(z, 2, 5) &gt; m4 &gt; [,1] [,2] [,3] [,4] [,5] &gt; [1,] 3 1 0 3 6 &gt; [2,] 1 5 2 5 9 &gt; # Skapa med matrix() en matris med fem rader och 2 kolumner. &gt; # I detta fall är de två första kolumnerna i m2 samma som m5. &gt; m5 &lt;- matrix(z, 5, 2) &gt; m5 &gt; [,1] [,2] &gt; [1,] 3 2 &gt; [2,] 1 3 &gt; [3,] 1 5 &gt; [4,] 5 6 &gt; [5,] 0 9 div.green{ background-color:#abd4b3; border-radius: 5px; padding: 20px;} Använd på denna kurs rbind() och cbind() vid skapande av matriser. Det är då mindre risk för för missförstånd var elementen hamnar i matrisen. För åtkomst till element krävs nu, eftersom matriser består av rader och kolumner, att bägge dimensionerna anges. Först anges radnummer, sedan kolumnnummer. Skriv in nedanstående kod i scriptet, spara och kör. # Visa element på rad 2 och kolumn 3 m1[2,3] # Visa element på rad 2 och alla kolumner m1[2,] # Visa element på alla rader och kolumner 3 m1[,3] # Visa m2[c(1,2),] I Console visas &gt; # Visa element på rad 2 och kolumn 3 &gt; m1[2,3] &gt; y &gt; 5 &gt; # Visa element på rad 2 och alla kolumner &gt; m1[2,] &gt; [1] 2 3 5 6 9 &gt; # Visa element på alla rader och kolumner 3 &gt; m1[,3] &gt; x y &gt; 1 5 &gt; # Visa &gt; m2[c(1,2),] &gt; x y u x &gt; [1,] 3 2 150 3 &gt; [2,] 1 3 150 1 Precis som vad gäller vektorer går det att utföra elementvisa beräkningar. Det kräver att matriserna har samma antal rader och kolumner. Det går även att utföra räkneoperationer med en konstant. Observera att elementvis multiplikation inte är detsamma som matematikens matrismultiplikation. Det är naturligtvis inga problem att i R använda matrismultiplikation, men detta går utanför kursens avgränsning. För att exemplfiera räkneoperationer med matriser, skriv in nedanstående kod i scriptet, spara och kör. # Addera element i matris 1 med element i matris 3 m1 + m3 # Multiplicera element i matris 1 med element i matris 3. OBS! Detta är inte matrismultiplikation! m1 * m3 # Dividera element i matris 1 med en konstant u m1 / u # Nedanstående är INTE det som inom matematiken benämns inversen av en matris, utan är 1/elementvärde 1/m1 I Console visas &gt; # Addera element i matris 1 med element i matris 3 &gt; m1 + m3 &gt; [,1] [,2] [,3] [,4] [,5] &gt; x 6 2 2 10 0 &gt; y 5 NA 11 9 15 &gt; # Multiplicera element i matris 1 med element i matris 3. OBS! Detta är inte matrismultiplikation! &gt; m1 * m3 &gt; [,1] [,2] [,3] [,4] [,5] &gt; x 9 1 1 25 0 &gt; y 6 NA 30 18 54 &gt; # Dividera element i matris 1 med en konstant n &gt; m1 / u &gt; [,1] [,2] [,3] [,4] [,5] &gt; x 0.02000000 0.006666667 0.006666667 0.03333333 0.00 &gt; y 0.01333333 0.020000000 0.033333333 0.04000000 0.06 &gt; # Nedanstående är INTE det som inom matematiken benämns inversen av en matris, utan är 1/elementvärde &gt; 1/m1 &gt; [,1] [,2] [,3] [,4] [,5] &gt; x 0.3333333 1.0000000 1.0 0.2000000 Inf &gt; y 0.5000000 0.3333333 0.2 0.1666667 0.1111111 Spara scriptet kap3_objekt_och_funktioner.R. Det går att tillämpa logiska operatorer även på matriser, men den extra dimensionen gör detta omständligt. Dessutom konstaterade vi att matrisen endast kan hantera en datatyp. Därför introduceras en tredje typ av dataobjekt som bättre sätt hanterar datamaterial. Det är dock bra att känna till att vid mer avancerad användning av R är matriser dock ett mycket viktigt verktyg. 3.4 Data frames En data frame är i praktiken det vanligaste objektet för dataanalys. En data frame har två dimensioner (rader och kolumner), men kan till skillnad från matrisen måste inte kolumnerna ha samma datatyp. Vad som dock krävs är att en kolumn består av en och samma datatyp. Vidare innehåller en data frame detaljerad information om exempelvis variabelnamn och variabeltyp. För att skapa en data frame används data.frame() och vi ska nu se på några exempel. Observera att en data frame även anger information om radnummer. Dessa nummer är dock inte definierade som en sepearat kolumn. Skriv nedanstående kod i kap3_objekt_och_funktioner.R, spara och kör. # Skapa en data frame genom att ange vektorer df &lt;- data.frame(x, y, nordic_countries) df # Skapa en data frame genom att transformera en matris. data.frame(m3) I Console erhålls följande resultat. &gt; # Skapa en data frame genom att ange vektorer &gt; df &lt;- data.frame(x, y, nordic_countries) &gt; df &gt; x y nordic_countries &gt; 1 3 2 Denmark &gt; 2 1 3 Finland &gt; 3 1 5 Iceland &gt; 4 5 6 Norway &gt; 5 0 9 Sweden &gt; # Skapa en data frame genom att transformera en matris. &gt; data.frame(m3) &gt; X1 X2 X3 X4 X5 &gt; x 3 1 1 5 0 &gt; ymis 3 NA 6 3 6 För åtkomst till element finns nu flera alternati och vi ska se på de två vanligaste: Precis som för matriser kan användaren använda hakparenteserna ´[]´ Genom att använda $ väljs en variabel i en dataframe. Det går sedan att använda hakparentes för att välja ett element i denna variabel. Nedanstående kod illustrerar de bägge metoderna. Skriv nedanstående kod i kap3_objekt_och_funktioner.R, spara och kör. # Visa kolumn 3 df[,3] # Visa variabeln nordic countries, dvs kolumn 3 df$nordic_countries # Visa värdet i rad 2 och kolumn 1 df[2,1] # Visa värdet för element 2 i variabeln x. df$x[2] I Console erhålls följande resultat. &gt; # Visa kolumn 3 &gt; df[,3] &gt; [1] Denmark Finland Iceland Norway Sweden &gt; Levels: Denmark Finland Iceland Norway Sweden &gt; df$nordic_countries &gt; [1] Denmark Finland Iceland Norway Sweden &gt; Levels: Denmark Finland Iceland Norway Sweden &gt; # Visa värdet i rad 2 och kolumn 1 &gt; df[2,1] &gt; [1] 1 &gt; df$x[2] &gt; [1] 1 Användning av enbart hakparentes är alltså ekvivalent med datahantering med hjälp av $ och sedan position. Även om koden med $ ofta blir längre, så blir koden mer lättförståelig jämfört med indexering för kolumn. Dessutom slipper man problemet med att indexeringen kan ändras om nya variabler adderas till det data frame man arbetar med eller om det på något annat sätt förändras. Med $ går det även enkelt att addera nya variabler till en data frame. Skriv nedanstående kod i kap3_objekt_och_funktioner.R, spara och kör. # Skapa variabeln sample_size baserat på n som bara har ett värde df$sample_size &lt;- u df # Skapa en variabel som heter ysq baserat på y i samma data frame. df$ysq &lt;- df$y^2 df # Skapa en tom variabel som heter x_cat df$x_cat &lt;- NA df I Console visas nedanstående. &gt; # Skapa variabeln sample_size baserat på n som bara har ett värde &gt; df$sample_size &lt;- u &gt; df &gt; x y nordic_countries sample_size &gt; 1 3 2 Denmark 150 &gt; 2 1 3 Finland 150 &gt; 3 1 5 Iceland 150 &gt; 4 5 6 Norway 150 &gt; 5 0 9 Sweden 150 &gt; # Skapa en variabel som heter ysq baserat på y i samma data frame. &gt; df$ysq &lt;- df$y^2 &gt; df &gt; x y nordic_countries sample_size ysq &gt; 1 3 2 Denmark 150 4 &gt; 2 1 3 Finland 150 9 &gt; 3 1 5 Iceland 150 25 &gt; 4 5 6 Norway 150 36 &gt; 5 0 9 Sweden 150 81 &gt; # Skapa en tom variabel som heter x_bin &gt; df$x_bin &lt;- NA &gt; df &gt; x y nordic_countries sample_size ysq x_bin &gt; 1 3 2 Denmark 150 4 NA &gt; 2 1 3 Finland 150 9 NA &gt; 3 1 5 Iceland 150 25 NA &gt; 4 5 6 Norway 150 36 NA &gt; 5 0 9 Sweden 150 81 NA Med $ förenklas även användningen av de logiska operatorerna och det blir enkelt att transformera variabler och även skapa mindre data frames. Skriv nedanstående kod i kap3_objekt_och_funktioner.R, spara och kör. # Ändra värdet på sample_size för Danmark från 150 till 300 df$sample_size[df$nordic_countries == &quot;Denmark&quot;] &lt;- 300 df # Ändra värden från NA till 1 i x_cat om x är större än 2 df$x_cat[x &gt; 2] &lt;- 1 df # Ändra värden från NA till 0 i x_cat om x är mindre än eller lika 2 df$x_cat[x &lt;= 2] &lt;- 0 df # Skapa ett nytt data frame som vi kallas df_sweden bestående av bara rader för Sverige df_sweden &lt;- df[df$nordic_countries== &quot;Sweden&quot;, ] df_sweden I Console visas nedanstående. &gt; # Ändra värdet på sample_size för Danmark från 150 till 300 &gt; df$sample_size[df$nordic_countries == &quot;Denmark&quot;] &lt;- 300 &gt; df &gt; x y nordic_countries sample_size ysq x_bin &gt; 1 3 2 Denmark 300 4 NA &gt; 2 1 3 Finland 150 9 NA &gt; 3 1 5 Iceland 150 25 NA &gt; 4 5 6 Norway 150 36 NA &gt; 5 0 9 Sweden 150 81 NA &gt; # Ändra värden från NA till 1 i x_cat om x är större än 2 &gt; df$x_cat[x &gt; 2] &lt;- 1 &gt; df &gt; x y nordic_countries sample_size ysq x_bin x_cat &gt; 1 3 2 Denmark 300 4 NA 1 &gt; 2 1 3 Finland 150 9 NA NA &gt; 3 1 5 Iceland 150 25 NA NA &gt; 4 5 6 Norway 150 36 NA 1 &gt; 5 0 9 Sweden 150 81 NA NA &gt; # Ändra värden från NA till 0 i x_cat om x är mindre än eller lika 2 &gt; df$x_cat[x &lt;= 2] &lt;- 0 &gt; df &gt; x y nordic_countries sample_size ysq x_bin x_cat &gt; 1 3 2 Denmark 300 4 NA 1 &gt; 2 1 3 Finland 150 9 NA 0 &gt; 3 1 5 Iceland 150 25 NA 0 &gt; 4 5 6 Norway 150 36 NA 1 &gt; 5 0 9 Sweden 150 81 NA 0 &gt; # Skapa ett nytt data frame som vi kallas df_sweden bestående av bara rader för Sverige &gt; df_sweden &lt;- df[df$nordic_countries== &quot;Sweden&quot;, ] &gt; df_sweden &gt; x y nordic_countries sample_size ysq x_bin x_cat &gt; 5 0 9 Sweden 150 81 NA 0 Vi kommer senare under kursen gång upprepade gånger att återkomma till data frames och titta närmare olika typer av sätt att hantera detta objekt. Vi avslutar med några grundläggande för att hatnera data frame. Skriv in nedanstående i scriptet kap3_objekt_och_funktioner.R. Spara och kör. # Med names() anges namnen i ett dataframe. names(df) # Med colnames() namnges variablerna i en data frame colnames(df) &lt;- c(&quot;age&quot;, &quot;income&quot;, &quot;nordic_countries&quot;) names(df) Vi ser nu i Console att variabelnamnen har ändrats. &gt; # Med names() anges namnen i ett dataframe. &gt; names(df) &gt; [1] &quot;x&quot; &quot;y&quot; &quot;nordic_countries&quot; &quot;sample_size&quot; &gt; [5] &quot;ysq&quot; &quot;x_bin&quot; &quot;x_cat&quot; &gt; # Med colnames() namnges variablerna i en data frame &gt; colnames(df) &lt;- c(&quot;age&quot;, &quot;income&quot;, &quot;nordic_countries&quot;) &gt; names(df) &gt; [1] &quot;age&quot; &quot;income&quot; &quot;nordic_countries&quot; NA &gt; [5] NA NA NA div.green{ background-color:#abd4b3; border-radius: 5px; padding: 20px;} Hantering av data är av lättförklarliga skäl väldigt viktigt i R. Det tar inledningsvis tid att lära, men är samtidigt något som varje användare måste vara trygg med. Värt att nämna är att nästan alltid finns alternativa sätt arbeta med data i R och vad som presentas här är är endast ett alternativ. På denna kurs rekommenderas starkt att ni följer den metodik som presenteras här. Visserligen är den inte effektivast, varken i termer av beräkningstid eller längd på kod, men det är ett transparent arbetssätt som minimerar risken för att fel uppkommer. Datahanteringen är ofta en tidskrävande del i statistisk undersökning och stor noggrannhet är viktigt. Det går inte att tillräckligt betona hur betydelsefull datahanteringen är i en undersökning. En korrekt analys kräver ju korrekt data. 3.5 Funktioner En funktion utför operationer på objekt. Exakt vad funktionen gör beror på funktionen. Det vara allt från att utföra enkla räkneoperationer på data i en vektor, till komplicerade beräkningar och förändringar av data. Oftast sparas resultatet från en funktion som ett nytt objekt. En funktion har i regel också olika argument som gör det möjligt för användaren att anpassa vad funktionen gör. Den något mer avancerade R-användaren kan även enkelt skapa egna funktioner, vilket är styrka eftersom R då blir väldigt flexibelt. Att skapa egna funktioner ingår emellertid inte på denna kurs utan analyserna som utförs på kurser kommer hanteras av redan implementerade funktioner i R. Denna introduktionen till funktioner är därför relativt kortfattad och det enklaste sättet att introducera funktion blir med hjälp av exempel. Skriv in nedanstående kod i scriptet kap3_objekt_och_funktioner.R, spara och kör. # sum() är en funktion för att summera värdera i en vektor. Summan sparas i objektet summax summax &lt;- sum(x) summax # length() beräknar antalet element i en vektor och spara i objektet n n &lt;- length(x) n I Console får erhålls följande. &gt; # sum() är en funktion för att summera värdera i en vektor. Summan sparas i objektet sumx &gt; sumx &lt;- sum(x) &gt; sumx &gt; [1] 10 &gt; # length() beräknar antalet element i en vektor och spara i objektet n &gt; n &lt;- length(x) &gt; n &gt; [1] 5 Du har nu tillämpat funktionen sum() som summerar alla elementvärden i en vektor, dvs \\(\\sum_{i=1}^n x_i=x_1 + x_2 + \\cdots + x_k\\). Funktionen length() räknar antalet element. Med hjälp av dessa funktioner går det nu att på enkelt sätt att beräkna medelvärdet, \\(\\bar{x}=\\dfrac{1}{n}\\sum_{i=1}^n x_i\\), och stickprovsvarians, \\(s^2=\\dfrac{1}{n-1}\\sum_{i=1}^n(x_i - \\bar{x})^2\\). Notera att standardavvikelsen är \\(s=\\sqrt{s^2}\\). Skriv in nedanstående kod i scriptet kap3_objekt_och_funktioner.R, spara och kör. # Beräkna medelvärdet av en vektor sample.mean &lt;- (1/n)*sumx sample.mean # Beräkna stickprovsvarians s^2 med det sum() samt de sparade objekten xbar och n sample.variance &lt;- (1/(n-1))*sum( (x - xbar)^2 ) sample.variance I Console visas nedanstående. &gt; # Beräkna medelvärdet av en vektor &gt; sample.mean &lt;- (1/n)*sumx &gt; sample.mean &gt; [1] 2 &gt; &gt; # Beräkna stickprovsvarians s^2 med hjälp av sum() samt de sparade objekten xbar och n &gt; sample.variance &lt;- (1/(n-1))*sum( (x - sample.mean)^2 ) &gt; sample.variance &gt; [1] 4 Naturligtvis finns i R färdiga funktioner för både medelvärde och stickprovsvarians. Skriv in nedanstående kod i scriptet kap3_objekt_och_funktioner.R, spara och kör. # Beräkna medelvärdet av en vektor xbar &lt;- mean(x) xbar # Beräkna stickprovsvariansen av en vektor s2 &lt;- var(x) s2 I Console visas nedanstående. &gt; # Beräkna medelvärdet av en vektor &gt; xbar &lt;- mean(x) &gt; xbar &gt; [1] 2 &gt; # Beräkna stickprovsvariansen av en vektor &gt; s2 &lt;- var(x) &gt; s2 &gt; [1] 4 Resultatet är samma som det tidigare, enda skillnaden är att funktionerna mean(x) och var() förenklar ytterligare. Men vi genom detta också en förståelse för vilka formler som mean() och var() använder sig av. Skriv in nedanstående kod i scriptet kap3_objekt_och_funktioner.R, spara och kör. # Beräkna medelvärdet av ymis, en vektor med att bortfall ymis.mean &lt;- mean(ymis) ymis.mean # Beräkna medelvärdet av ymis, en vektor med att bortfall # ymisbar &lt;- mean(ymis, na.rm = TRUE) ymisbar I Console presenteras följande. &gt; # Beräkna medelvärdet av ymis, en vektor med att bortfall &gt; ymis.mean &lt;- mean(ymis) &gt; ymis.mean &gt; [1] NA &gt; # Beräkna medelvärdet av ymis, en vektor med att bortfall &gt; # &gt; ymisbar &lt;- mean(ymis, na.rm = TRUE) &gt; ymisbar &gt; [1] 4.5 Eftersom R ger att \\(y_1 + y_2 + NA + \\cdots + y_k = NA\\) blir även medelvärdet NA. Vi kan dock använda ett argument i funktionen som heter na.rm som vi sätter till TRUE. Om detta argument sätts till TRUE så tar funktionen före beräkning bort saknade värden. Default-inställningen är dock att detta argument är satt till FALSE. Det innebär att medelvärdet ymisbar är beräknat på de fyra värden som har observationer. För att veta vilka argument en funktion har skriver använd funktionen help(). I exemplet med medelvärdet så skriver du help(mean). I nedre högra panelen i Rstudio under fliken Help visas nu information om den funktion som vi ville veta mer om. I hjälpfilen står under Usage hur funktionen kan användas mean(x, trim = 0, na.rm = FALSE) och under Arguments hittar beskrivs vad argumenten betyder. Till exempel står det na.rm a logical value indicating whether NA values should be stripped before the computation proceeds.. Grundinställningen (default) satt till FALSE efter detta är angivet i Usage. Hjälpfilerna är ofta svåra att förstå, men exemplen längst ner i hjälpfilerna är i regel klargörande. På denna kurs kommer funktioner att introduceras efterhand. Funktioner är nämligen något som man lär sig genom tillämpning och inte genom att lära sig utantill i förväg. Dock kan det vara bra att ha en lista över alla de vanliga funktionerna så man vet vilka möjligheter som finns. https://cran.r-project.org/doc/contrib/Short-refcard.pdf Vi börjar här med några grundläggande funktioner som är användbara. Skriv in nedanstående kod i scriptet kap3_objekt_och_funktioner.R, spara och kör. # Skapa en vektor som repeterar värde 3 fem gånger x1 &lt;- rep(3, 5) x1 # Skapa en vektor som repeterar NA 10 fem gånger xNA &lt;- rep(NA, 5) xNA # Funktion som skapar en sekvens från 2 till 3 med steglängd 0.25 x2 &lt;- seq(from = 2, to = 3, by = 0.25) x2 # Skapa en en vektor av element som repeterats x3 &lt;- c(rep(1, 3), rep(4, 2), rep(9, 10)) x3 # Funktion för att summera information i ett objekt summary(ymis) # Funktion skapar ett histogram hist(x) # Funktion som skapar ett spridningsdiagram plot(x, y) I Console visas &gt; # Skapa en vektor som repeterar värde 3 fem gånger &gt; x1 &lt;- rep(3, 5) &gt; x1 &gt; [1] 3 3 3 3 3 &gt; # Skapa en vektor som repeterar NA 10 fem gånger &gt; xNA &lt;- rep(NA, 5) &gt; xNA &gt; [1] NA NA NA NA NA &gt; # Funktion som skapar en sekvens från 2 till 3 med steglängd 0.25 &gt; x2 &lt;- seq(from = 2, to = 3, by = 0.25) &gt; x2 &gt; [1] 2.00 2.25 2.50 2.75 3.00 &gt; # Skapa en en vektor av element som repeterats &gt; x3 &lt;- c(rep(1, 3), rep(4, 2), rep(9, 10)) &gt; x3 &gt; [1] 1 1 1 4 4 9 9 9 9 9 9 9 9 9 9 &gt; # Funktion för att summera information i ett objekt &gt; summary(ymis) &gt; Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s &gt; 3.0 3.0 4.5 4.5 6.0 6.0 1 &gt; # Funktion skapar ett histogram &gt; hist(x) &gt; # Funktion som skapar ett spridningsdiagram &gt; plot(x, y) Avslutningsvis finns det ett antal frekvent använda samt viktiga funktioner för dataobjekt. Bekanta dig med dessa. &gt; # Funktion för att beskriva datatyp &gt; class(y) &gt; [1] &quot;numeric&quot; &gt; class(nordic_countries) &gt; [1] &quot;character&quot; &gt; # Funktion för att beskriva objekt &gt; str(y) &gt; num [1:5] 2 3 5 6 9 &gt; str(nordic_countries) &gt; chr [1:5] &quot;Denmark&quot; &quot;Finland&quot; &quot;Iceland&quot; &quot;Norway&quot; &quot;Sweden&quot; &gt; # Funktion för att ta reda på storleken på matris eller data frame &gt; dim(m1) &gt; [1] 2 5 &gt; dim(df) &gt; [1] 5 7 &gt; dim(df)[1] &gt; [1] 5 &gt; dim(df)[2] &gt; [1] 7 &gt; # Funktion för att beräkna längden av en vektor &gt; length(x) &gt; [1] 5 &gt; # Funktionen ls() listar alla objekt i minnet &gt; ls() &gt; [1] &quot;df&quot; &quot;df_sweden&quot; &quot;m1&quot; &gt; [4] &quot;m2&quot; &quot;m3&quot; &quot;m4&quot; &gt; [7] &quot;m5&quot; &quot;my__first_vec&quot; &quot;n&quot; &gt; [10] &quot;nordic_countries&quot; &quot;nordic_countries_new&quot; &quot;s2&quot; &gt; [13] &quot;sample.mean&quot; &quot;sample.variance&quot; &quot;scandinavia&quot; &gt; [16] &quot;sumx&quot; &quot;u&quot; &quot;v&quot; &gt; [19] &quot;w&quot; &quot;x&quot; &quot;x_bin&quot; &gt; [22] &quot;x_new&quot; &quot;x_nordic_countries&quot; &quot;x1&quot; &gt; [25] &quot;x1345&quot; &quot;x2&quot; &quot;x3&quot; &gt; [28] &quot;xbar&quot; &quot;xNA&quot; &quot;y&quot; &gt; [31] &quot;y15&quot; &quot;y234&quot; &quot;ymis&quot; &gt; [34] &quot;ymis.mean&quot; &quot;ymisbar&quot; &quot;ysub&quot; &gt; [37] &quot;z&quot; &quot;z_trinary&quot; &quot;z1&quot; &gt; [40] &quot;z2&quot; &quot;z3&quot; &gt; # Funktionen rm() raderar ett objekt &gt; rm(y) &gt; # Se om objektet y finns kvar &gt; ls() &gt; [1] &quot;df&quot; &quot;df_sweden&quot; &quot;m1&quot; &gt; [4] &quot;m2&quot; &quot;m3&quot; &quot;m4&quot; &gt; [7] &quot;m5&quot; &quot;my__first_vec&quot; &quot;n&quot; &gt; [10] &quot;nordic_countries&quot; &quot;nordic_countries_new&quot; &quot;s2&quot; &gt; [13] &quot;sample.mean&quot; &quot;sample.variance&quot; &quot;scandinavia&quot; &gt; [16] &quot;sumx&quot; &quot;u&quot; &quot;v&quot; &gt; [19] &quot;w&quot; &quot;x&quot; &quot;x_bin&quot; &gt; [22] &quot;x_new&quot; &quot;x_nordic_countries&quot; &quot;x1&quot; &gt; [25] &quot;x1345&quot; &quot;x2&quot; &quot;x3&quot; &gt; [28] &quot;xbar&quot; &quot;xNA&quot; &quot;y15&quot; &gt; [31] &quot;y234&quot; &quot;ymis&quot; &quot;ymis.mean&quot; &gt; [34] &quot;ymisbar&quot; &quot;ysub&quot; &quot;z&quot; &gt; [37] &quot;z_trinary&quot; &quot;z1&quot; &quot;z2&quot; &gt; [40] &quot;z3&quot; Avslutningsvis finns en viktig funktion som används för att radera alla objekt. Det är rm(list = ls()). Var försiktig med denna funktion eftersom alla objekt i minnet försvinner! Emellertid är god idé inleda ett script för en dataanlys med denna kod för att säkerställa att minnet är tomt innan ny data läses in. På så vis undviker vi konflkter mellan objekt. Förslagsvis används denna funktion inför varje ny övningsuppgift, såvida inte uppgiftern bygger på information från tidigare uppgifter. 3.6 Sammanfattning div.red{ background-color:#F5B7B1; border-radius: 5px; padding: 20px;} Du ska kunna känna till de viktigaste datatyperna som R arbetar med. känna till de tre olika typerna av dataobjekt. genomföra enklare datahantering, till exempel förändra ett specifikt elements värde i ett dataobjekt eller att med logiska operationer välja ut data från ett objekt. genomföra logiska operationer på vektorer och data frames. använda $ i data frames. tillämpa några vanliga funktioner i R samt även informera dig om vad en funktion gör genom att använda hjälp-filen. div.green{ background-color:#abd4b3; border-radius: 5px; padding: 20px;} Bortfall komplicerar analyser och kodas på olika sätt. Det hanteras separat i kapitlet om bortfall. På denna kurs används baspaketen i R för datahantering. I R-universumet finns även en uppsättning paket som tillhör det så kallade tidyverse(). Här finns paket med en mängd funktioner som förenklar avancerad datahantering betydligt och som också följer en logik som många uppskattar. På denna kurs och för de flesta användare är dock baspaketen i R fullt tillräckligt. Kategorivariabler kallas faktorer och kommer att hanteras utförligt i kapitlet om faktorer. Att ha en förståelse för hur man hanterar faktorer är nödvändigt inom all dataanlys. I R används även typiska programmeringssatser innehållande for, if, else, while. Detta är emellertid inte något som vi kommer att arbeta med på denna kurs. 3.7 Övningar Övning 3.1 Du har ett stickprov betående av observationerna \\(4,-2,5,6,8\\). Beräkna medelvärdet. Beräkna standardavvikelsen. Beräkna variationsbredden. Beräkna det geometriska medelvärdet för de positiva värden \\(4, 5, 6, 8\\). Beräkna det geometriska medelvärdet för alla värden \\(4, -2, 5, 6, 8\\). Svar 3.1 # Töm minnet inför denna Övning 3.1 rm(list = ls()) x &lt;- c(4,-2,5,6,8) mean(x) [1] 4.2 Svar: Medelvärdet är 4.2 Standardavvikelsen \\(s=\\sqrt{\\dfrac{\\sum_{i=1}^n (x_i -\\bar{x})^2}{n-1}}\\) beräknas med sd(x) [1] 3.768289 Svar: Standardavvikelsen är 3.768 Variationsbredden, dvs skillnaden mellan det största och det minsta värdet är max(x) - min(x) ## [1] 10 Svar: Variationsbredden är är 10. Det geometriska medelvärdet \\(\\bar{x}_g=(x_1\\cdot x_2 \\cdot \\cdots \\cdot x_n)^{1/n}\\) kan i R beräknas med # Välj enbart positiva värden xpos &lt;- x[x &gt; 0] # Du kan beräkna det geometriska medelvärdet med exp( mean(log(xpos)) ) ## [1] 5.566315 # Alternativt kan du funktionen geometric.mean() # i paketet psych. Aktivera paketet och beräkna. library(&quot;psych&quot;) geometric.mean(xpos) ## [1] 5.566315 Svar: Det geometriska medelvärdet är 3.95. Det geometriska medelvärdet \\[\\bar{x}_g=(x_1\\cdot x_2 \\cdot \\cdots \\cdot x_n)^{1/n}\\] kan i R beräknas med (4 * (-2) * 5 * 6 * 8)^(1/5) ## [1] NaN geometric.mean(x) ## Warning in log(x): NaNs produced ## [1] 5.566315 Svar: Eftersom en observation är negativ blir NaN, vilket betyder ‘’Not a Number’’. Det går alltså inte att beräkna. Övning 3.2 Ett slumpmässigt urval ger följande observationer \\(0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1\\),där \\(1=Arbetslös\\) och \\(0=Förvärvsarbetande\\). Beräkna andelen arbetslösa i stickprovet. Svar 3.2 Andelen arbetslösa beräkna i R med # Töm minnet inför denna Övning 3.2 rm(list = ls()) x &lt;- c(0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1) mean(x) ## [1] 0.3846154 Svar: Andelen arbetslösa i stickprovet är 0.38. Övning 3.3 Kosumentpriset 2006-2011 är Table 3.1: Konsumentprisindex (KPI) 2006-2011 2006 284.2 2007 290.5 2008 300.6 2009 299.7 2010 303.5 2011 311.4 Med hur många procent har prisnivån förändrats från 2007 till 2010? Svar 3.3 Beräkning i R ger # Töm minnet inför denna Övning 3.2 rm(list = ls()) year &lt;- c(2006, 2007, 2008, 2009, 2010, 2011) kpi &lt;- c(284.22, 290.51, 300.61, 299.66, 303.46, 311.423) percent_change &lt;- 100*(kpi[year == 2010]/kpi[year == 2007])-100 Svar: Prisnivån har ökat med 4.458%. Övning 3.4 Låt observationerna \\(4,-2,5,6,8\\) vara obundet slumpmässigt urval från en normalfördelad population. Genomför en hypotesprövning på 5% signifikansnivå för att testa medelvärdet i population är skild från 1. Svar 3.4 Vi observerar \\(x=\\{4,-2,5,6,8\\}.\\) Hypoteser: \\(H_0:\\mu=1\\) vs \\(H_1:\\mu \\neq 1\\) Antaganden: Variabeln \\(x\\) är normalfördelad i populationen. Populationsvariansen \\(\\sigma^2\\) är okänd i populationen. Vi har ett litet stickprov, \\(n=5\\). Testfunktionen ges av \\(t=\\dfrac{\\bar{x}-\\mu}{\\sqrt{s^2/n}}\\). Denna teststatistika är \\(t\\)-fördelad med \\(n-1\\) frihetsgrader om nollhypotesen är sann. Beslutregel: \\(\\alpha=0.05\\). Tvåsidigt test, förkasta därför \\(H_0\\) om \\(|t_{obs}| &gt; t_{krit} = t_{4,\\alpha/2=0.025} = 2.776\\) # Töm minnet inför uppgift 3.4 rm(list = ls()) # Vi ska lösa uppgiften först illusterat med objekt i R # Sedan löser vi den med den inbyggda funktionen för t-test # Bestäm värden som ska in i testfunktionen x &lt;- c(4,-2,5,6,8) n &lt;- length(x) xbar &lt;- mean (x) s2 &lt;- var(x) mu &lt;- 1 # Beräkna testfunktionen tobs &lt;- (xbar - mu)/sqrt(s2/n) # Se var testfunktionensvärde hamnar i en t-fördelning med n-1 frihetsgrader # Funktionen pt() ger för ett givet t-värde vänstersvanssannolikheter i en t-fördelning med n-1 frihetsgrader # Eftersom vi vill ha sannolikheten i högra svansen måste vi därför ta 1-pt(). # Slutligen, eftersom mothypotesen är två-sidig multipliceras p-värdet med 2. p_value &lt;- 2*(1 - pt(tobs, (n-1))) p_value [1] 0.1304116 t.test(x, mu = 1) One Sample t-test data: x t = 1.8989, df = 4, p-value = 0.1304 alternative hypothesis: true mean is not equal to 1 95 percent confidence interval: -0.4789485 8.8789485 sample estimates: mean of x 4.2 t.test(x, mu = 1)$p.value [1] 0.1304116 Svar: Efterom \\(p=0.13\\) kan vi på 5% signifikansnivå inte påvisa att medelvärdet i populationen är skilt från 1. Notera att detta inte innebär att vi visar att medelvärdet är 1. Övning 3.5 Du observerar följande vektorer \\(x = \\{4,7,2,4,6,NA,89\\}\\) och \\(y=\\{7,3, 2, 5,6, 5 , 7\\}\\) och \\(z=\\{Alfa, bravo, Charlie, delta, Echo, Foxtrot, Golf\\}\\) Använd indexering för att summera element 2 och 3 i \\(x\\) med element 6 och 7 i \\(y\\). Använd indexering för att ändra NA i \\(x\\) till 999. Använd indexering för att korrigera så att bravo och delta inleds med versaler. Exkludera Echo och Foxtrot från \\(z\\). Svar 3.5 # Töm minnet inför uppgift 3.5 rm(list = ls()) # a) x &lt;- c(4,7,2,4,6,NA,89) y &lt;- c(7,3,2,5,6,5,7) sumxy &lt;- x[c(2,3)] + y[c(6,7)] sumxy [1] 12 9 # b) x[6] &lt;- 999 x [1] 4 7 2 4 6 999 89 # c) z &lt;- c(&quot;Alfa&quot;, &quot;Bravo&quot;, &quot;Charlie&quot;, &quot;Delta&quot;, &quot;Echo&quot;, &quot;Foxtrot&quot;, &quot;Golf&quot;) z[2] &lt;- &quot;Bravo&quot; z[4] &lt;- &quot;Delta&quot; z [1] &quot;Alfa&quot; &quot;Bravo&quot; &quot;Charlie&quot; &quot;Delta&quot; &quot;Echo&quot; &quot;Foxtrot&quot; &quot;Golf&quot; # d) zsub &lt;- z[-c(5,6)] zsub [1] &quot;Alfa&quot; &quot;Bravo&quot; &quot;Charlie&quot; &quot;Delta&quot; &quot;Golf&quot; Övning 3.6 Du observerar följande datapunkter \\(x = \\{4,7,2,4,6\\}\\) och \\(y=\\{7,3, 2, 5,6\\}\\). Använd minsta-kvadratmetoden och beräkna koefficienterna \\(a\\) och \\(b\\) i regressionslinjen \\(y=a + bx\\). Använd koefficienterna och ge en prediktion för \\(y\\) givet att \\(x=7\\). Beräkna residualen för \\(x=7\\) Beräkna residualspridningen. Svar 3.6 Riktningskoefficienten ges av \\[b=\\dfrac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i - \\bar{x})^2}\\] och interceptet ges av \\[ a = \\bar{y} - b \\bar{x}\\]. Vi tillämpar formlerna i R. # Töm minnet inför uppgift 3.5 rm(list = ls()) x &lt;- c(4,7,2,4,6) y &lt;- c(7,3, 2, 5,6) xbar &lt;- mean(x) ybar &lt;- mean(y) b &lt;- sum( (x - xbar)*(y - ybar))/sum( (x - xbar)^2) b [1] 0.2105263 a &lt;- ybar - b*xbar a [1] 3.631579 # Det finns en inbyggd funktion i R för regressionsanalys, vilken används senare på kursen. Svar: Riktningskoefficienten beräknas till \\(b=0.2105\\), vilket tolkas som att om \\(x\\) ökar en enhet så ökar \\(y\\) i genomsnitt med \\(0.2105\\) enheter. Interceptet beräknas till \\(a=3.632\\), vilket tolkas som medelvärdet för \\(y\\) när \\(x=0\\). Notera att det i beräkningarna Använd koefficienterna från regressionslinjen och sätt in värdet \\(x=7\\). xp &lt;- 7 yhat &lt;- a + b*xp yhat [1] 5.105263 Svar: Prediktionen \\(\\hat{y}=\\) 5.105. Detta är punkten på regressionslinjen när \\(x=7\\) och vår bästa gissning för det \\(y\\)-värde en individ med värdet \\(x=7\\) kommer att ha. En residual är skillnaden mellan ett predicerat värde och det faktiska observerade värdet, \\(\\hat{\\varepsilon}=y_i - \\hat{y}\\). Eftersom \\(y=3\\) när \\(x=7\\) så residualen residual &lt;- y[x == xp] - yhat Svar: Residualen för \\(x=7\\) är -2.105. Residualspridningen ges av \\[s_\\varepsilon=\\sqrt{\\dfrac{\\sum_{i=1}^n(y_i - \\hat{y}_i)^2}{n-2}}= \\sqrt{\\dfrac{\\sum_{i=1}^n\\hat{\\varepsilon}_i^2}{n-2}}\\]. Vi beräknar på samma sätt som i c) övriga residualer, kvadrerar och summerar. residuals &lt;- y - (3.6316 + 0.2105*x) n &lt;- length(residuals) residual_spridning &lt;- sqrt( sum(residuals^2)/(n-2) ) residual_spridning [1] 2.347077 Svar: Residualspridningen är 2.347 (Notera att \\(\\sum_{i=1}^n \\varepsilon_i^2\\) kallas för residualkvadratsumman.) Övning 3.7 Du observerar följande data frame income &lt;- c(4,7,2,3,6,7,8,6) education &lt;- c(&quot;Low&quot;, &quot;Medium&quot;, &quot;Low&quot;, &quot;High&quot;, &quot;High&quot;, &quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;) df &lt;- data.frame(income, education) Skapa en ny variabel som heter high_edu som tar värdet 1 om education är “High” och 0 annars. Svar 3.7 # Töm minnet inför uppgift 3.6 rm(list = ls()) income &lt;- c(4,7,2,3,6,7,8,6) education &lt;- c(&quot;Low&quot;, &quot;Medium&quot;, &quot;Low&quot;, &quot;High&quot;, &quot;High&quot;, &quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;) df &lt;- data.frame(income, education) df$high_edu &lt;- NA df$high_edu[df$education == &quot;High&quot;] &lt;- 1 df$high_edu[df$education == &quot;Low&quot;] &lt;- 0 df$high_edu[df$education == &quot;Medium&quot;] &lt;- 0 df income education high_edu 1 4 Low 0 2 7 Medium 0 3 2 Low 0 4 3 High 1 5 6 High 1 6 7 Low 0 7 8 Medium 0 8 6 High 1 Övning 3.8 Ett oljebolag är intresserat av att för ett äldre bostadsområde med \\(2\\,000\\) hus skatta andelen hus utan oljeeldning. Sakkunskapen säger att det sanna antalet hus utan oljeeldning är mellan 300 och 800 stycken. Precisionskravet är formulerat så att ett 95% konfidensintervall för andelen hus utan oljeeldning inte får bli längre än 0.05 procentenheter. Beräkna urvalsstorleken vid OSU om dragningen sker med återläggning. Svar 3.8 Mål: Beräkna den nödvändiga stickprovsstorleken \\(n\\) om längden för ett 95% konfidensintervall för andelen i populationen får vara maximalt 0.05. Parameter: \\(p\\) = andelen hus utan oljeeldning i populationen. Estimator: \\(\\hat{p}\\) = andelen hus utan oljeeldning i stickprovet. Förutsättningar: OSU-MÅ ger att \\(E(\\hat{p})=p\\). Detta säger oss att andelen i stickprovprovet kan skatta andelen i populationen väntevärdesriktigt. \\(V(\\hat{p})=\\frac{p(1-p)}{n}\\). Detta är variansen i andelsestimatorns samplingfördelning. Vi antar att \\(p=\\dfrac{800}{2000}=0.4\\) eftersom detta ger störst varians givet den information vi har. Vi utgår från att \\(np(1-p)&gt;5\\) kommer att vara uppfyllt. Vi måste sedan kontrollera att antagandet faktiskt är uppfyllt! Annars gäller inte CGS och approximativ normalfördelning. Precisionskravet i termer av konfidensintervallets längd kan nu formuleras \\[ 0.05\\geq 2\\cdot 1.96\\sqrt{\\frac{0.4(1-0.4)}{n}}. \\] Det går att ändra värdena på \\(n\\) i R för att se vilket \\(n\\) som ger vår önskade minsta stickprovsstorlek. Vi vill att uttrycket nedan ska vara lika med eller mindre än 0.05. # Töm minnet inför uppgift 3.7 rm(list = ls()) n &lt;- seq(10, 10000, 1) p &lt;- 0.4 # Z-värdet från fördelning N(0,1) med sannolikheten 0.025 i högre svansen. z &lt;- qnorm(0.975) # Längden för ett konfidensintervall ges av följande formel: KIlength &lt;- 2 * z * sqrt( ( p*(1-p) ) / n ) # Illustration över olika KIlength för olika värden stickprovsstorlekar n plot(n, KIlength, type = &quot;l&quot;) # Välj den minsta stickprovsstorleken som uppfyller precisionskravet KIlength &lt; 0.05 min( n[KIlength &lt; 0.05] ) [1] 1476 Svar: För att uppnå precisionskravet behövs ett stickprov med minst 1476 hus. Glöm inte att kontrollera CGS: \\(np(1-p)=1476\\cdot 0.4(1-0.4)=354.24 &gt; 5\\) så antagandet är uppfyllt. Det går även att lösa denna uppgift algebraiskt, genom att lösa ut $n i formeln ovan. Övning 3.9 En rikstäckande butikskedja säljer bland annat kompletta datorpaket. För ett visst paket tillåter man butikscheferna att själva sätta priset. För att centralt i företaget få en uppfattning om hur efterfrågan påverkas av priset gör man ett slumpmässigt urval om åtta butiker och inhämtar uppgifter om pris och försäljning under den närmast föregående månaden: pris &lt;- c(5500, 6000, 6500, 6000, 5000, 6500, 4500, 5000) antal &lt;- c(41, 38, 35, 40, 44, 38, 45, 42) Beräkna korrelationskoefficienten. Svar 3.9 Korrelationskoefficentens ges av \\[r=\\dfrac{\\sum_{i=1}^n(x_i - \\bar{x})(y_i-\\bar{y})}{\\sqrt{\\sum_{i=1}^n(x_i - \\bar{x})^2 \\sum_{i=1}^n(y_i - \\bar{y})^2}}.\\] Vi kan enkelt tillämpa formeln. # Töm minnet inför uppgift 3.8 rm(list = ls()) x &lt;- c(5500, 6000, 6500, 6000, 5000, 6500, 4500, 5000) y &lt;- c(41, 38, 35, 40, 44, 38, 45, 42) xbar &lt;- mean(x) ybar &lt;- mean(y) sdx &lt;- sd(x) sdy &lt;- sd(y) r &lt;- sum( (x - xbar)*(y - ybar) ) /sqrt( sum( (x - xbar)^2)*sum( (y - ybar)^2) ) r [1] -0.9426412 Svar: Pearsons produktmomentkorrelationskoefficient är \\(-0.94\\), vilket tyder på ett mkt starkt negativt samband mellan pris och antal. Övning 3.10 Betrakta nedanstående vektor: some_letters &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;B&quot;, &quot;D&quot;, &quot;A&quot;, &quot;D&quot;, &quot;A&quot;) Använd R för att räkna hur många B det finns i vektorn. Svar 3.10 # Töm minnet inför uppgift 3.8 rm(list = ls()) some_letters &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;B&quot;, &quot;D&quot;, &quot;A&quot;, &quot;D&quot;, &quot;A&quot;) length( some_letters[some_letters == &quot;B&quot;] ) [1] 2 Övning 3.11 Betrakta nedanstående vektorer: some_numbers &lt;- c(&quot;1&quot;, &quot;3&quot;, &quot;1&quot;, &quot;3&quot;, &quot;3&quot;) some_numbers_and_letters &lt;- c(&quot;2&quot;, &quot;4&quot;, &quot;-1&quot;, &quot;3&quot;, &quot;3&quot;, &quot;A&quot;, &quot;D&quot;) Använd R för att summera alla värdena i respektive vektor. Tips: Använd funktionen as.numeric(). Svar 3.11 # Töm minnet inför uppgift 3.10 rm(list = ls()) some_numbers &lt;- c(&quot;1&quot;, &quot;3&quot;, &quot;1&quot;, &quot;3&quot;, &quot;3&quot;) some_numerics &lt;- as.numeric( some_numbers ) class(some_numbers) [1] &quot;character&quot; class(some_numerics) [1] &quot;numeric&quot; sum(some_numerics) [1] 11 some_numbers_and_letters &lt;- c(&quot;2&quot;, &quot;5&quot;, &quot;-1&quot;, &quot;3&quot;, &quot;3&quot;, &quot;A&quot;, &quot;D&quot;) some_numerics_2 &lt;- as.numeric(some_numbers_and_letters) Warning: NAs introduced by coercion sum(some_numerics_2, na.rm = TRUE) [1] 12 Övning 3.12 Betrakta nedanstående vektorer. x1 &lt;- c(0.39, 0.76, -1.25, 0.28, 0.60, 0.66, 0.94, -0.18, -0.26, -1.83, -1.13, 0.45, 0.11, -1.03, 1.06, -0.08, 1.68, -1.02, 1.36, 1.58) x2 &lt;- c(-1.0, 1.5, 0.2, -0.5, -1.1, -0.2, -1.0, -1.3, -1.6, -1.2, -0.4, -1.3, -0.3, -0.7, 0.7, -2.5, -1.0, 2.1, 1.3, -1.3) x3 &lt;- c(5.94, -2.38, -0.16, 0.44, 0.70, 2.54, 2.12, 8.33, 0.57, 1.24, 0.05, -1.78, 2.53, -1.60, 2.77, 0.26, 1.48, 1.10, -8.00, 4.57) Skapa variabeln \\(x = x_1 + x_2 + x_3\\). Skapa variabeln \\(z\\), där \\(z=1\\) om \\(x &lt; 0\\), \\(z=2\\) om \\(0 \\leq x &lt; 5\\) och \\(z=3\\) om \\(x \\geq 5\\). Skapa de binära variblerna \\(v_1\\) som är 1 om \\(x1 &gt; 0\\) och 0 annars, \\(v_2\\) som är 1 om \\(x2 &gt; 0\\) och 0 annars, och \\(v_3\\) som är 1 om \\(x3 &gt; 0\\) och 0 annars Skapa variabeln \\(v = v_1 + v_2 + v_3\\) som är en summa av de binära variablerna. Skapa en frekvenstabell för \\(v\\). Svar 3.12 # Töm minnet inför uppgift 3.10 rm(list = ls()) x1 &lt;- c(0.39, 0.76, -1.25, 0.28, 0.60, 0.66, 0.94, -0.18, -0.26, -1.83, -1.13, 0.45, 0.11, -1.03, 1.06, -0.08, 1.68, -1.02, 1.36, 1.58) x2 &lt;- c(-1.0, 1.5, 0.2, -0.5, -1.1, -0.2, -1.0, -1.3, -1.6, -1.2, -0.4, -1.3, -0.3, -0.7, 0.7, -2.5, -1.0, 2.1, 1.3, -1.3) x3 &lt;- c(5.94, -2.38, -0.16, 0.44, 0.70, 2.54, 2.12, 8.33, 0.57, 1.24, 0.05, -1.78, 2.53, -1.60, 2.77, 0.26, 1.48, 1.10, -8.00, 4.57) # a) x &lt;- x1 + x2 + x3 # b) # Skapa en variabeln som består av NA som är lika lång som x z &lt;- rep(NA, length(x)) z[x &lt; 0] &lt;- 1 z[(x &gt;= 0) &amp; (x &lt; 10) ] &lt;- 2 z[x &gt; 10] &lt;- 3 z [1] 2 1 1 2 2 2 2 2 1 1 1 1 2 1 2 1 2 2 1 2 # c) v1 &lt;- rep(NA, length(x1)) v1[x1 &gt; 0] &lt;- 1 v1[x1 &lt;= 0] &lt;- 0 v2 &lt;- rep(NA, length(x1)) v2[x2 &gt; 0] &lt;- 1 v2[x2 &lt;= 0] &lt;- 0 v3 &lt;- rep(NA, length(x1)) v3[x3 &gt; 0] &lt;- 1 v3[x3 &lt;= 0] &lt;- 0 # d) v &lt;- v1 + v2 + v3 v [1] 2 2 1 2 2 2 2 1 1 1 1 1 2 0 3 1 2 2 2 2 # e) sumv0 &lt;- sum(v == 0) sumv1 &lt;- sum(v == 1) sumv2 &lt;- sum(v == 2) sumv3 &lt;- sum(v == 3) frequencies &lt;- c(sumv0, sumv1, sumv2, sumv3) values &lt;- c(0, 1, 2, 3) frequency.table &lt;- cbind(values, frequencies) frequency.table values frequencies [1,] 0 1 [2,] 1 7 [3,] 2 11 [4,] 3 1 # Det finns i R också en inbyggd funktion table(), som vi ska använda oss av senare på kursen. "],
["läsa-in-och-spara-data.html", "Kapitel 4 Läsa in och spara data 4.1 Principer ska 4.2 Text- och CSV-filer 4.3 Excel-filer 4.4 Övriga format", " Kapitel 4 Läsa in och spara data Avsikten är att beskriva principerna för hur datamaterial är organiserade, hur datamaterial bör organiseras samt presentera de vanligaste formaten för att att importera och exportera data. För nybörjaren i R kan det vara uppmuntrande att känna till att datainläsning i en del fall kan vara omständligt och frustrerande, framförallt om datamaterialet inte är organiserat på ett konsekvent sätt. Misströsta därför inte ifall det dyker upp svårigheter. Det krävs mycket erfarenhet för att blir trygg med att arbeta med data. På denna kurs rekommenderas två format för att importera och spara datamaterial: textfiler (.txt eller .csv), vilket innebär att data sparas i textformat. R Data format (.RDS), vilket är det dataformat som R använder. I praktiken, på grund av att många icke-statistiker använder det, är det dock nödvändigt att kunna importera och spara filer i Excel-format (.xlsx eller motsvarande). Vad gäller import och export av andra dataformat som är kopplade till andra statistikprogram (SAS, SPSS, Minitab) finns R-paket (t ex foreign och haven) avsedda för detta. Likaså, vad gäller hantering av stora dataset (\\(&gt;10\\) Gigabyte i storlek) kan paket som data.table vara till hjälp. 4.1 Principer ska HAdley Wickham (https://twitter.com/hadleywickham?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor) En bra princip för att dataset är att skapa en tidy There are three interrelated rules which make a dataset tidy: Varje variabel måste ha en egen kolumn. Each variable must have its own column. Varje observation måste ha sin egen rad Varje värde måste ha sin egen cell. Data är organiserat i kolumner, där kolumner anger variabler. På rader har vi Observera att internminnet i datorn sätter en begränsning för hur stora dataset användaren kan hantera i Många program (t ex Excel) gör det möjligt att spara data som ren text istället för i progammets eget format. Spara alltid en kopia i textformat. Organisera data med kolumner som korresponderar till olika variabler. Använd semi-kolon för att avgränsa kolumner. Eftersom komma används som decimaltecken på svenska och avstånd eller TAB är svåra att se i en textfil eftersom de påminner om blanksteg undviks enkla problem. Försök att inte ändra något i ursprungsfilen. Det är bättre att, om möjligt, importera till R och göra ändringarna där. Undvik namn med blanksteg. Avoid names with blank spaces. Good column names: Long_jump or Long.jump. Bad column name: Long jump. Avoid names with special symbols: ?, $, *, +, #, (, ), -, /, }, {, |, &gt;, &lt; etc. Only underscore can be used. Avoid beginning variable names with a number. Use letter instead. Good column names: sport_100m or x100m. Bad column name: 100m Column names must be unique. Duplicated names are not allowed. R is case sensitive. This means that Name is different from Name or NAME. Avoid blank rows in your data Delete any comments in your file Replace missing values by NA (for not available) If you have a column containing date, use the four digit format. Good format: 01/01/2016. Bad format: 01/01/16 Although this book focuses almost exclusively on data analysis, data management is also an important part of data science. As explained in the introduction, we do not cover this topic. However, quite often data analysts needs to collect data, or work with others collecting data, in a way that is most conveniently stored in a spreadsheet. Although filling out a spreadsheet by hand is a practice we highly discourage, we instead recommend the process be automatized as much as possible, sometimes you just have to do it. Therefore, in this section, we provide recommendations on how to organize data in a spreadsheet. Although there are R packages designed to read Microsoft Excel spreadsheets, we generally want to avoid this format. Instead, we recommend Google Sheets as a free software tool. Below we summarize the recommendations made in paper by Karl Broman and Kara Woo18. Please read the paper for important details. Be Consistent - Before you commence entering data, have a plan. Once you have a plan, be consistent and stick to it. Choose Good Names for Things - You want the names you pick for objects, files, and directories to be memorable, easy to spell, and descriptive. This is actually a hard balance to achieve and it does require time and thought. One important rule to follow is do not use spaces, use underscores _ or dashes instead -. Also, avoid symbols; stick to letters and numbers. Write Dates as YYYY-MM-DD - To avoid confusion, we strongly recommend using this global ISO 8601 standard. No Empty Cells - Fill in all cells and use some common code for missing data. Put Just One Thing in a Cell - It is better to add columns to store the extra information rather than having more than one piece of information in one cell. Make It a Rectangle - The spreadsheet should be a rectangle. Create a Data Dictionary - If you need to explain things, such as what the columns are or what the labels used for categorical variables are, do this in a separate file. No Calculations in the Raw Data Files - Excel permits you to perform calculations. Do not make this part of your spreadsheet. Code for calculations should be in a script. Do Not Use Font Color or Highlighting as Data - Most import functions are not able to import this information. Encode this information as a variable instead. Make Backups - Make regular backups of your data. Use Data Validation to Avoid Errors - Leverage the tools in your spreadsheet software so that the process is as error-free and repetitive-stress-injury-free as possible. Save the Data as Text Files - Save files for sharing in comma or tab delimited format. 4.2 Text- och CSV-filer CSV står för “comma separated values”, vilket även referar till semi-kolon eftersom många länder använder komma som decimaltecken. De två funktionerna som används för att läsa in CSV-filer är read.csv() och read.csv2(). CSV.filer är textfiler och mer generellt kan text-filer läsas in med read.table(). De bägge read.csv() och read.csv2() baseras nämligen på read.table(), men med förspecificerade argument. Funktionernas vanligaste argument presenteras nedan, men det går att specificera funktionerna i stor detalj beroende på hur datafilen ser ut. read.csv(file, header = TRUE, sep = &quot;,&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;.&quot;) read.csv2(file, header = TRUE, sep = &quot;;&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;,&quot;) read.table(file, header = TRUE, sep=&quot; &quot;, quote = &quot;\\&quot;&quot;, dec = &quot;.&quot;) file anger filnamnet header om variablerna har variabelnamn på första raden sep anger typ av separarering mellan kolumner. quote anger citationstecken för text-variabler dec anger typ av decimal-tecken För att läsa in nedanstående text-fil animals1.csv som kan vi använda read.csv(). Skriv in df1 &lt;- read.csv(file=\"D:/animals1.csv\") Eftersom det är en textfil kan filen öppnas i Notepad eller Textredigerare (eller mosvarande). Då är det tydligt att kolumnerna är separerade med komma och att decimaltecken används punkt. Raden längst till vänster är radnamn, vilket är default. Citationstecken hanterar textvariabler. &quot;&quot;,&quot;animal&quot;,&quot;body&quot;,&quot;brain&quot; &quot;1&quot;,&quot;Lesser short-tailed shrew&quot;,0.005,0.14 &quot;2&quot;,&quot;Little brown bat&quot;,0.01,0.25 &quot;3&quot;,&quot;Big brown bat&quot;,0.023,0.3 &quot;4&quot;,&quot;Mouse&quot;,0.023,0.4 &quot;5&quot;,&quot;Musk shrew&quot;,0.048,0.33 &quot;6&quot;,&quot;Star-nosed mole&quot;,0.06,1 &quot;7&quot;,&quot;E. American mole&quot;,0.075,1.2 &quot;8&quot;,&quot;Ground squirrel&quot;,0.101,4 &quot;9&quot;,&quot;Tree shrew&quot;,0.104,2.5 &quot;10&quot;,&quot;Golden hamster&quot;,0.12,1 &quot;11&quot;,&quot;Mole&quot;,0.122,3 &quot;12&quot;,&quot;Galago&quot;,0.2,5 &quot;13&quot;,&quot;Rat&quot;,0.28,1.9 &quot;14&quot;,&quot;Chinchilla&quot;,0.425,6.4 &quot;15&quot;,&quot;Owl monkey&quot;,0.48,15.5 &quot;16&quot;,&quot;Desert hedgehog&quot;,0.55,2.4 &quot;17&quot;,&quot;Rockhyraxa&quot;,0.75,12.3 &quot;18&quot;,&quot;European hedgehog&quot;,0.785,3.5 &quot;19&quot;,&quot;Tenrec&quot;,0.9,2.6 &quot;20&quot;,&quot;Arctic ground squirrel&quot;,0.92,5.7 &quot;21&quot;,&quot;African giant pouched rat&quot;,1,6.6 &quot;22&quot;,&quot;Guinea pig&quot;,1.04,5.5 &quot;23&quot;,&quot;Mountain beaver&quot;,1.35,8.1 &quot;24&quot;,&quot;Slow loris&quot;,1.4,12.5 &quot;25&quot;,&quot;Genet&quot;,1.41,17.5 &quot;26&quot;,&quot;Phalanger&quot;,1.62,11.4 &quot;27&quot;,&quot;N.A. opossum&quot;,1.7,6.3 &quot;28&quot;,&quot;Tree hyrax&quot;,2,12.3 &quot;29&quot;,&quot;Rabbit&quot;,2.5,12.1 &quot;30&quot;,&quot;Echidna&quot;,3,25 &quot;31&quot;,&quot;Cat&quot;,3.3,25.6 &quot;32&quot;,&quot;Arctic fox&quot;,3.385,44.5 &quot;33&quot;,&quot;Water opossum&quot;,3.5,3.9 &quot;34&quot;,&quot;Nine-banded armadillo&quot;,3.5,10.8 &quot;35&quot;,&quot;Rock yrax-b&quot;,3.6,21 &quot;36&quot;,&quot;Yellow-bellied marmot&quot;,4.05,17 &quot;37&quot;,&quot;Verbet&quot;,4.19,58 &quot;38&quot;,&quot;Red fox&quot;,4.235,50.4 &quot;39&quot;,&quot;Raccoon&quot;,4.288,39.2 &quot;40&quot;,&quot;Rhesus monkey&quot;,6.8,179 &quot;41&quot;,&quot;Potarmonkey&quot;,10,115 &quot;42&quot;,&quot;Baboon&quot;,10.55,179.5 &quot;43&quot;,&quot;Roe deer&quot;,14.83,98.2 &quot;44&quot;,&quot;Goat&quot;,27.66,115 &quot;45&quot;,&quot;Kangaroo&quot;,35,56 &quot;46&quot;,&quot;Grey wolf&quot;,36.33,119.5 &quot;47&quot;,&quot;Chimpanzee&quot;,52.16,440 &quot;48&quot;,&quot;Sheep&quot;,55.5,175 &quot;49&quot;,&quot;Giantarmadillo&quot;,60,81 &quot;50&quot;,&quot;Human&quot;,62,1320 &quot;51&quot;,&quot;Grey seal&quot;,85,325 &quot;52&quot;,&quot;Jaguar&quot;,100,157 &quot;53&quot;,&quot;Brazilian tapir&quot;,160,169 &quot;54&quot;,&quot;Donkey&quot;,187.1,419 &quot;55&quot;,&quot;Pig&quot;,192,180 &quot;56&quot;,&quot;Gorilla&quot;,207,406 &quot;57&quot;,&quot;Okapi&quot;,250,490 &quot;58&quot;,&quot;Cow&quot;,465,423 &quot;59&quot;,&quot;Horse&quot;,521,655 &quot;60&quot;,&quot;Giraffe&quot;,529,680 &quot;61&quot;,&quot;Asian elephant&quot;,2547,4603 &quot;62&quot;,&quot;African elephant&quot;,6654,5712 &quot;63&quot;,&quot;Triceratops&quot;,9400,70 &quot;64&quot;,&quot;Dipliodocus&quot;,11700,50 &quot;65&quot;,&quot;Brachiosaurus&quot;,87000,154.5 Läs nu in animals2.csv med read.csv2(), det skriv in df2 &lt;- read.csv2(file=\"D:/animals2.csv\"). I denna textfilen är kolumnerna separerade med semi-kolon och komma är decimaltecken. &quot;&quot;;&quot;animal&quot;;&quot;body&quot;;&quot;brain&quot; &quot;1&quot;;&quot;Lesser short-tailed shrew&quot;;0,005;0,14 &quot;2&quot;;&quot;Little brown bat&quot;;0,01;0,25 &quot;3&quot;;&quot;Big brown bat&quot;;0,023;0,3 &quot;4&quot;;&quot;Mouse&quot;;0,023;0,4 &quot;5&quot;;&quot;Musk shrew&quot;;0,048;0,33 &quot;6&quot;;&quot;Star-nosed mole&quot;;0,06;1 &quot;7&quot;;&quot;E. American mole&quot;;0,075;1,2 &quot;8&quot;;&quot;Ground squirrel&quot;;0,101;4 &quot;9&quot;;&quot;Tree shrew&quot;;0,104;2,5 &quot;10&quot;;&quot;Golden hamster&quot;;0,12;1 &quot;11&quot;;&quot;Mole&quot;;0,122;3 &quot;12&quot;;&quot;Galago&quot;;0,2;5 &quot;13&quot;;&quot;Rat&quot;;0,28;1,9 &quot;14&quot;;&quot;Chinchilla&quot;;0,425;6,4 &quot;15&quot;;&quot;Owl monkey&quot;;0,48;15,5 &quot;16&quot;;&quot;Desert hedgehog&quot;;0,55;2,4 &quot;17&quot;;&quot;Rockhyraxa&quot;;0,75;12,3 &quot;18&quot;;&quot;European hedgehog&quot;;0,785;3,5 &quot;19&quot;;&quot;Tenrec&quot;;0,9;2,6 &quot;20&quot;;&quot;Arctic ground squirrel&quot;;0,92;5,7 &quot;21&quot;;&quot;African giant pouched rat&quot;;1;6,6 &quot;22&quot;;&quot;Guinea pig&quot;;1,04;5,5 &quot;23&quot;;&quot;Mountain beaver&quot;;1,35;8,1 &quot;24&quot;;&quot;Slow loris&quot;;1,4;12,5 &quot;25&quot;;&quot;Genet&quot;;1,41;17,5 &quot;26&quot;;&quot;Phalanger&quot;;1,62;11,4 &quot;27&quot;;&quot;N.A. opossum&quot;;1,7;6,3 &quot;28&quot;;&quot;Tree hyrax&quot;;2;12,3 &quot;29&quot;;&quot;Rabbit&quot;;2,5;12,1 &quot;30&quot;;&quot;Echidna&quot;;3;25 &quot;31&quot;;&quot;Cat&quot;;3,3;25,6 &quot;32&quot;;&quot;Arctic fox&quot;;3,385;44,5 &quot;33&quot;;&quot;Water opossum&quot;;3,5;3,9 &quot;34&quot;;&quot;Nine-banded armadillo&quot;;3,5;10,8 &quot;35&quot;;&quot;Rock yrax-b&quot;;3,6;21 &quot;36&quot;;&quot;Yellow-bellied marmot&quot;;4,05;17 &quot;37&quot;;&quot;Verbet&quot;;4,19;58 &quot;38&quot;;&quot;Red fox&quot;;4,235;50,4 &quot;39&quot;;&quot;Raccoon&quot;;4,288;39,2 &quot;40&quot;;&quot;Rhesus monkey&quot;;6,8;179 &quot;41&quot;;&quot;Potarmonkey&quot;;10;115 &quot;42&quot;;&quot;Baboon&quot;;10,55;179,5 &quot;43&quot;;&quot;Roe deer&quot;;14,83;98,2 &quot;44&quot;;&quot;Goat&quot;;27,66;115 &quot;45&quot;;&quot;Kangaroo&quot;;35;56 &quot;46&quot;;&quot;Grey wolf&quot;;36,33;119,5 &quot;47&quot;;&quot;Chimpanzee&quot;;52,16;440 &quot;48&quot;;&quot;Sheep&quot;;55,5;175 &quot;49&quot;;&quot;Giantarmadillo&quot;;60;81 &quot;50&quot;;&quot;Human&quot;;62;1320 &quot;51&quot;;&quot;Grey seal&quot;;85;325 &quot;52&quot;;&quot;Jaguar&quot;;100;157 &quot;53&quot;;&quot;Brazilian tapir&quot;;160;169 &quot;54&quot;;&quot;Donkey&quot;;187,1;419 &quot;55&quot;;&quot;Pig&quot;;192;180 &quot;56&quot;;&quot;Gorilla&quot;;207;406 &quot;57&quot;;&quot;Okapi&quot;;250;490 &quot;58&quot;;&quot;Cow&quot;;465;423 &quot;59&quot;;&quot;Horse&quot;;521;655 &quot;60&quot;;&quot;Giraffe&quot;;529;680 &quot;61&quot;;&quot;Asian elephant&quot;;2547;4603 &quot;62&quot;;&quot;African elephant&quot;;6654;5712 &quot;63&quot;;&quot;Triceratops&quot;;9400;70 &quot;64&quot;;&quot;Dipliodocus&quot;;11700;50 &quot;65&quot;;&quot;Brachiosaurus&quot;;87000;154,5 Läs nu in animals.txt med read.table(), dvs använd df3 &lt;- read.table(file=\"D:/animals.txt\", header=TRUE) Kolumnerna är i denna textfil är separerade med mellanslag och punkt används som decimaltecken. Här finns inga radnamn. &quot;animal&quot; &quot;body&quot; &quot;brain&quot; &quot;Lesser short-tailed shrew&quot; 0.005 0.14 &quot;Little brown bat&quot; 0.01 0.25 &quot;Big brown bat&quot; 0.023 0.3 &quot;Mouse&quot; 0.023 0.4 &quot;Musk shrew&quot; 0.048 0.33 &quot;Star-nosed mole&quot; 0.06 1 &quot;E. American mole&quot; 0.075 1.2 &quot;Ground squirrel&quot; 0.101 4 &quot;Tree shrew&quot; 0.104 2.5 &quot;Golden hamster&quot; 0.12 1 &quot;Mole&quot; 0.122 3 &quot;Galago&quot; 0.2 5 &quot;Rat&quot; 0.28 1.9 &quot;Chinchilla&quot; 0.425 6.4 &quot;Owl monkey&quot; 0.48 15.5 &quot;Desert hedgehog&quot; 0.55 2.4 &quot;Rockhyraxa&quot; 0.75 12.3 &quot;European hedgehog&quot; 0.785 3.5 &quot;Tenrec&quot; 0.9 2.6 &quot;Arctic ground squirrel&quot; 0.92 5.7 &quot;African giant pouched rat&quot; 1 6.6 &quot;Guinea pig&quot; 1.04 5.5 &quot;Mountain beaver&quot; 1.35 8.1 &quot;Slow loris&quot; 1.4 12.5 &quot;Genet&quot; 1.41 17.5 &quot;Phalanger&quot; 1.62 11.4 &quot;N.A. opossum&quot; 1.7 6.3 &quot;Tree hyrax&quot; 2 12.3 &quot;Rabbit&quot; 2.5 12.1 &quot;Echidna&quot; 3 25 &quot;Cat&quot; 3.3 25.6 &quot;Arctic fox&quot; 3.385 44.5 &quot;Water opossum&quot; 3.5 3.9 &quot;Nine-banded armadillo&quot; 3.5 10.8 &quot;Rock yrax-b&quot; 3.6 21 &quot;Yellow-bellied marmot&quot; 4.05 17 &quot;Verbet&quot; 4.19 58 &quot;Red fox&quot; 4.235 50.4 &quot;Raccoon&quot; 4.288 39.2 &quot;Rhesus monkey&quot; 6.8 179 &quot;Potarmonkey&quot; 10 115 &quot;Baboon&quot; 10.55 179.5 &quot;Roe deer&quot; 14.83 98.2 &quot;Goat&quot; 27.66 115 &quot;Kangaroo&quot; 35 56 &quot;Grey wolf&quot; 36.33 119.5 &quot;Chimpanzee&quot; 52.16 440 &quot;Sheep&quot; 55.5 175 &quot;Giantarmadillo&quot; 60 81 &quot;Human&quot; 62 1320 &quot;Grey seal&quot; 85 325 &quot;Jaguar&quot; 100 157 &quot;Brazilian tapir&quot; 160 169 &quot;Donkey&quot; 187.1 419 &quot;Pig&quot; 192 180 &quot;Gorilla&quot; 207 406 &quot;Okapi&quot; 250 490 &quot;Cow&quot; 465 423 &quot;Horse&quot; 521 655 &quot;Giraffe&quot; 529 680 &quot;Asian elephant&quot; 2547 4603 &quot;African elephant&quot; 6654 5712 &quot;Triceratops&quot; 9400 70 &quot;Dipliodocus&quot; 11700 50 &quot;Brachiosaurus&quot; 87000 154.5 Prova nedanstående kod. Vad händer? df4 &lt;- read.table(file=\"D:/animals1.csv\", header=TRUE, sep=\",\", dec=\".\") 4.3 Excel-filer I praktiken är det nödvändigt att importera av Excel-dokument. Nedan följer ett antal tips för när data matas in i Excel. Första raden ska bestå av variabelnamn Första kolumnen bör bestå av observationsid Undvik namn och värden med mellanslag. Risken är att det tolkas som två olika kolumner. Korta variabelnamn är bättre än långa. Undvik tecken som ?, $,%, ^, &amp;, *, (, ),-,#, ?,,,&lt;,&gt;, /, |, , [ ,] ,{, and }; Radera kommentarer som du har i Excelfilen så att dessa inte tolkas som extra data. Målet är nu att läsa in Excel-filerna animal3.xlsx och animal4.xlsx. För att läsa in data från Excel-filer krävs ett paket som heter readxl. Installera paketet med att i Console skriv install.packages(\"readxl\") och trycka enter. Skriv nu ett script # Läser in nödvändigt paket library(&quot;readxl) df5 &lt;- read_excel(&quot;animal3.xlsx&quot;) df6 &lt;- read_excel(&quot;animal4.xlsx&quot;) Titta på data frames. Data frame df5 ser ok ut, men för df6 är det något som inte stämmer. Öppnar filen med Excel. Då ser du att Excel-dokumentet består av flera kalkylblad och data finns i blad 2. Dessutom börjar inte data från toppen, utan det finns även annan text i blad två. Genom att vara mer specifik i inläsningen av data väljs exakt varifrån Excel-filen data hämtas. df7 &lt;- read_excel(&quot;animal4.xlsx&quot;, sheet = &quot;Blad2&quot;, range = &quot;A3:D68&quot;) Titta på data frame df7 (som nu förhoppningsvis ska se ok ut). 4.4 Övriga format Det är viktigt att organisera data på ett bra sätt och nedan följer några allmänna tips: På så vis är datamaterialet program- och plattformsoberoende. Nackdelen är att man vid inläsning av denna typ av data ofta måste ange I princip är detta en fil som innehåller objektet som fanns i Rs minne spara objekt. Fördelarna med att arbeta i detta format är att det är mindre minneskrävande än R och filen innehåller samma information om objektet som när det fanns som inläst data frame i R. Nackdelen är att det kräver att andra användare också använder R. "],
["urvalsmetoder.html", "Kapitel 5 Urvalsmetoder 5.1 Obundet slumpmässigt urval utan återläggning 5.2 Stratifierat urval 5.3 Övningar", " Kapitel 5 Urvalsmetoder 5.1 Obundet slumpmässigt urval utan återläggning 5.1.1 Inferens för \\(\\mu\\) Målet är att undersöka en variabel \\(x\\) i en population bestående av \\(N\\) element. Variabelns populationsmedelvärde betecknas \\(\\mu\\) och populationsvariansen \\(\\sigma^2\\). Ett urval dras med storleken \\(n\\). Givet att urvalsmetoden är ett obundet slumpmässigt urval utan återläggning (OSU-UÅ) gäller följande: Stickprovsmedelvärdet, \\[\\bar{x} = \\dfrac{1}{n}\\sum_{i=1}^n x_i\\] är en väntevärdesriktig skattning av \\(\\mu\\). Stickprovsmedelvärdets varians är \\[V(\\bar{x}) = \\left(\\dfrac{N-n}{N-1}\\right)\\dfrac{\\sigma^2}{n}\\] och skattas med \\[\\hat{V}(\\bar{x}) = \\left(1 - \\dfrac{n}{N}\\right)\\dfrac{s^2_x}{n},\\] där \\(s^2\\) är stickprovsvariansen. Om stickprovsstorleken är tillräckligt stor är stickprovsmedelvärdets samplingfördelning \\(\\bar{x} \\underset{approx}{\\sim} N(\\mu,\\sigma^2)\\)). Ett konfidensintervall ges då av \\[ \\bar{x}\\pm z_{\\alpha/2}\\sqrt{\\hat{V}(\\bar{x})} \\] där \\(1-\\alpha\\) är konfidensgraden och \\(z_{\\alpha/2}\\) är det \\(z\\)-värde som erhålls om svanssannolikheten \\(\\alpha/2\\) läggs i högra svansen. För statistiska test krävs en nollhypotes, en testfunktion (och huruvida testet är ensidigt eller två-sidigt) samt data. Om nollhypotesen \\(H_0:\\mu=\\mu_0\\) är sann är testfunktionen \\[z = \\dfrac{\\bar{x} - \\mu_0}{\\sqrt{\\hat{V}(\\bar{x})}}\\] approximativt \\(N(0,1)\\). div.red{ background-color:#F5B7B1; border-radius: 5px; padding: 20px;} Kommer du ihåg? \\(p\\)-värdet är sannolikheten att observera ett minst lika extremt värde som det observerade givet att nollhypotesen är sann. Beroende på hur hypoteserna är formulerade är \\(p\\)-värdet något av följande sannolikheter: För en händelse i höger svans, dvs \\(H_1: \\mu &gt; \\mu_0\\) är \\[p-value=\\Pr(Z \\geq z|H_0\\,\\,\\text{sann})\\] För en händelse i vänster svans, \\(H_1: \\mu &lt; \\mu_0\\) \\[p-value=\\Pr(Z \\leq z|H_0\\,\\,\\text{sann})\\] För en två-sidig \\(H_1:\\mu\\neq \\mu_0\\) \\[p-value=2 \\cdot \\min \\left\\{ \\Pr(Z \\leq z|H_0\\,\\,\\text{sann}), \\Pr(Z \\geq z|H_0\\,\\,\\text{sann}) \\right\\} \\] Om möjligt, beräkna alltid \\(p\\)-värdet istället för att enbart jämföra testfunktionens observerade värde med en kritisk punkt. Det går nämligen att tolka \\(p\\)-värdet som ett kontinuerligt mått på bevis mot nollhypotesen eller formulerat som i vilken utsträckning data stämmer överens med nollhypotesen. Ett lågt \\(p\\)-värde indikerar att data har låg överensstämmelse med nollhypoytesen. Om målet med studien trots allt innebär att ett beslut måste fattas kan \\(p\\)-värdet då enkelt relateras till vald signifikansnivå. Understiger \\(p\\)-värdet signifikansnivå så förkastas nollhypotesen, i annat fall kan nollhypotesen inte förkastas. Tänk på att signifikansnivån i dessa fall måste väljas i förväg. div.green{ background-color:#abd4b3; border-radius: 5px; padding: 20px;} Normalfördelning eller \\(t\\)-fördelning? Det går att argumentera för att \\(t\\)-fördelningen bör användas i beräkning av konfidensintervall och test även vid användning av approximativ normalfördelning på grund av CGS. Anledningen är att variansen i den approximativa normalfördelningen är okänd och därmed skattas denna varians. Om vi förlitar oss på CGS har dock valet mellan normal- och \\(t\\)-fördelning liten betydelse eftersom dessa fördelningar är snarlika i stora stickprov. Använd följande Shiny-app och jämför standardnormalfördelningen med t-fördelningar med olika frihetsgrader, där antalet frihetgrader beror på stickprovsstorleken. https://jetty.im.uu.se/shiny/Dist/ 5.1.2 Skattning av \\(p\\) Anta att variabeln \\(x\\) i tidigare nämnda population är binär med populationsandelen \\(p\\). Givet OSU-UÅ gäller följande: Stickprovsandelen \\(\\hat{p}\\) är en väntevärdesriktig skattning av \\(p\\). Andelsestimatorns varians \\[V(\\hat{p}) = \\left(\\dfrac{N-n}{N-1}\\right)\\dfrac{p(1-p)}{n}\\] skattas med \\[\\hat{V}(\\hat{p}) = \\left(1 - \\dfrac{n}{N}\\right)\\dfrac{\\hat{p}(1-\\hat{p})}{n-1}\\]. För konfidensintervall krävs att samplingfördelningen är känd. Om \\(np(1-p)&gt;5\\) är andelsestimatorn approximativt normalfördelad. Ett konfidensintervall ges då av \\[ \\hat{p}\\pm z_{\\alpha/2}\\sqrt{\\hat{V}(\\hat{p})} \\] Vid hypotesprövning av \\(H_0: p = p_0\\) är under nollhypotesen \\[z = \\dfrac{\\hat{p} - p_0}{\\sqrt{\\dfrac{N-n}{N-1}\\dfrac{p_0(1-p_0)}{n}}}\\] approximativt \\(N(0,1)\\) om \\(np(1-p)&gt;5\\). div.green{ background-color:#abd4b3; border-radius: 5px; padding: 20px;} Centrala gränsvärdessatsen och inferens om \\(p\\) Tumregeln \\(np(1-p)&gt;5\\) är dålig om andelen i populationen är nära 0 eller 1. Om andelen i populationen är nära 0 eller 1 krävs stort stickprov för att konfidensgraden ska vara rätt. Det finns dock så kallade exakta alternativ för att skapa konfidensintervall och genomföra test. 5.1.3 Skattning av \\(\\tau\\) Målet är att studera summan av alla variabelvärden i poulationen, dvs populationstotalen \\(\\tau\\). Givet OSU-UÅ gäller följande: Totalestimatorn \\(\\hat{\\tau} = N\\bar{x}\\) är en väntevärdesriktig skattning av \\(\\tau\\). Om \\(x\\) är binär gäller att \\(\\hat{\\tau} = N\\hat{p}\\). Totalestimatorns varians är \\(V(\\hat{\\tau}) = N^2V(\\bar{x})\\), vilken skattas med \\(\\hat{V}(\\hat{\\tau}) = N^2\\hat{V}(\\bar{x})\\). Om \\(x\\) är binär gäller att andelsestimatorns varians är \\(V(\\hat{\\tau}) = N^2V(\\hat{p})\\), vilken skattas med och \\(\\hat{V}(\\hat{\\tau}) = N^2\\hat{V}(\\hat{p})\\). Samplingfördelningen följer samma regler som för \\(\\bar{x}\\) respektive \\(\\hat{p}\\). Ett konfidensintervall om vi förlitar oss på CGS ges av: \\[ \\hat{\\tau}\\pm z_{\\alpha/2}\\sqrt{\\hat{V}(\\hat{\\tau})} \\] Om nollhypotetesen \\(H_0:\\tau=\\tau_0\\) är sann så är testfunktionen \\[z = \\dfrac{\\hat{\\tau} - \\tau_0}{\\sqrt{\\hat{V}(\\hat{\\tau})}}\\] approximativt \\(N(0,1)\\). 5.1.4 Beräkningar av stickprovstorlek Precisionskraven kan i regel skrivas i termer av estimatorns varians och ett tabellvärde. Tre vanliga precisionskrav är \\(\\text{medelfel}=\\sqrt{V(\\hat{\\theta})},\\) \\(\\text{felmarginal}=tabellvärde\\cdot \\sqrt{V(\\hat{\\theta})}\\) eller \\(\\text{KIbredd}=2\\cdot tabellvärde \\cdot \\sqrt{V(\\hat{\\theta})}\\) får vara av en viss storlek. Att formulera ett precisionskrav är inte enkelt eftersom det beror på vilken nogrannhet som krävs i en undersökning. Kan vi i en partisympatiundersökning nöja oss med en felmarginal på 10 procentenheter när vi skattar andelen i väljarkåren som sympatiserar med Socialdemokraterna? Kan vi vid en skattning av andelen individer med antikroppar från Covid-19 nöja oss med ett konfidensintervall med längden 3 procentenheter? Storleken på precisionskravet beror således på den praktiska betydelsen av att undersökningen ger en viss precision. Formel för variansen beror på val av estimator. Vidare finns ett tabellvärdet som beror på samplingfördelningen. Kända parametervärden stoppas sedan in i precisionskravet, till exempel populationsvariansen, \\(\\sigma^2\\) och populationsstorleken \\(n\\). Slutligen löser vi ut urvalstorleken \\(n\\). Om en algebraisk lösning är svår kan en iterativ lösning enkelt genomföras i R. Nedan följer exempel på kod för beräkning av stickprovsstorlek vid skattning av \\(\\mu\\). Läs koden och relatera den till formlerna för precisionskraven. # Bestäm spridningen i populationen, sätter 1 som default sigma2 &lt;- 1 # Känd populationsstorlek, sätter 10000 som default N &lt;- 100000 # Bestäm konfidensgrad eller signifikansnivå, sätter 95%/5% som default alpha &lt;- 0.05 z_alpha &lt;- qnorm((1-alpha/2)) # Lista olika stickprovsstorlekar, sätter 1 till 1000 som default n &lt;- 1:1000 # Beräkna medelfelet för olika stickprovsstorlekar xbar_medelfel &lt;- sqrt( ( (N-n)/(N-1))*sigma2/n ) # Beräkna felmarginal för olika stickprovsstorlekar xbar_felmarginal &lt;- z_alpha * xbar_medelfel # Beräkna konfidensintervallets bredd för olika stickprovsstorlekar xbar_KIbredd &lt;- z_alpha * xbar_medelfel # Välj stickprovsstorlek utifrån valt precisionskra, sätter 0.2 som default precisionskrav &lt;- 0.2 # Välj den minsta stickprovsstorlek som uppnår precisionskravet. min(n[xbar_medelfel &lt;= precisionskrav]) # Studera precisionskrav som en funktion av stickprovstorleken plot(n, xbar_medelfel, type = &quot;l&quot;, col = &quot;red&quot;) abline(h = precisionskrav) 5.2 Stratifierat urval 5.2.1 Inferens för \\(\\mu\\) Målet är att undersöka en variabel \\(x\\) i en population bestående av \\(N\\) element. Variabelns populationsmedelvärde betecknas \\(\\mu\\) och populationsvariansen \\(\\sigma^2\\). Populationen indelas i \\(K\\) stycken disjunkta strata. Populationsstorlekan i stratum \\(j\\) betecknas \\(N_j\\) och den total populationsstorleken är \\(N=N_1 + \\dots + N_K\\). Vidare betecknar \\(\\mu_j\\) och \\(\\sigma^2_j\\) populationsmedelvärdet respektive populationsvariansen i stratum \\(j\\). Från respektive stratum dras ett urval. Den stratumspecifika urvalsstorlek betecknas \\(n_j\\) och den totala urvalsstorleken i undersökningen är \\(n=n_1+\\cdots+n_K\\). Givet att urvalsmetoden i respektive stratum är ett OSU-UÅ gäller följande: Stickprovsmedelvärdet vid stratifierat urval, \\[\\bar{x}_{st} = \\sum_{j=1}^K\\dfrac{N_j}{N}\\bar{x}_j\\] är en väntevärdesriktig skattning av \\(\\mu\\), där \\(\\bar{x}_{j}\\) betecknar stickprovsmedelvärdet i stratum \\(j\\). Stickprovsmedelvärdets varians är \\[V(\\bar{x}_{st}) = \\sum_{j=1}^K \\left(\\dfrac{N_j}{N}\\right)^2 V(\\bar{x}_j)\\] där stickprovsmedelvärdets varians betecknas \\[V(\\bar{x}_j) = \\left(\\dfrac{N_j-n_j}{N_j-1}\\right)\\dfrac{\\sigma^2_j}{n_j}\\]. Ovan skattas med \\[\\hat{V}(\\bar{x}_{st}) = \\sum_{j=1}^K \\left(\\dfrac{N_j}{N}\\right)^2\\hat{V}(\\bar{x}_j)\\] där \\[\\hat{V}(\\bar{x}_j) = \\left(1 - \\dfrac{n_j}{N_j}\\right)\\dfrac{s^2_j}{n_j}\\] där \\(s^2_j\\) är den stratumspecifika stickprovsvariansen. + För konfidensintervall krävs att samplingfördelningen är känd. Om stickprovsstorleken är tillräckligt stor i respektive stratum, dvs \\(n_j &gt; 20\\), är \\(\\bar{x}_{st}\\) approximativt normalfördelad. + Ett konfidensintervall ges av \\[ \\bar{x}_{st}\\pm z_{\\alpha/2}\\sqrt{\\hat{V}(\\bar{x}_{st})} \\] där \\(1-\\alpha\\) är konfidensgraden och \\(z_{\\alpha/2}\\) är det \\(z\\)-värde som erhålls om svanssannolikheten \\(\\alpha/2\\) läggs i högra svansen. + För statistiska test krävs en nollhypotes, en testfunktion (och huruvida testet är ensidigt eller två-sidigt) samt data. Om nollhypotesen \\(H_0:\\mu=\\mu_0\\) är sann är testfunktionen \\[z = \\dfrac{\\bar{x}_{st} - \\mu_0}{\\sqrt{\\hat{V}(\\bar{x}_{st})}}\\] approximativt \\(N(0,1)\\). 5.2.2 Inferens för \\(p\\) Anta att variabeln \\(x\\) i tidigare nämnda stratifierade population är binär med populationsandelen \\(p\\). En stratumspecifik andel betecknas \\(p_j\\). Givet OSU-UÅ gäller följande: Stickprovsandelen \\(\\hat{p}_st=\\dfrac{N}{N_j}\\hat{p}_j\\) är en väntevärdesriktig skattning av \\(p\\). Andelsestimatorns varians \\[V(\\hat{p}) = \\left(\\dfrac{N-n}{N-1}\\right)\\dfrac{p(1-p)}{n}\\] skattas med \\[\\hat{V}(\\hat{p}) = \\left(1 - \\dfrac{n}{N}\\right)\\dfrac{\\hat{p}(1-\\hat{p})}{n-1}\\]. För konfidensintervall krävs att samplingfördelningen är känd. Om \\(np(1-p)&gt;5\\) är andelsestimatorn approximativt normalfördelad. För hypotesprövning krävs information om variansen under nollhypotesen. Vid stratifierat urval krävs då information om alla stratumspecifika varianser. Hypotesprövning för andelar vid stratifierat urval ingår inte på kursen. 5.2.3 Inferens för \\(\\tau\\) Om målet är att skatta totalen i populationen \\(\\tau\\) med ett stratifierat urval, och utgångspunkten är som ovan beskrivits med OSU-UÅ från respektive stratum så gäller följande: Totalestimatorn \\(\\hat{\\tau}_{st} = N\\bar{x}_{st}\\) är en väntevärdesriktig skattning av \\(\\tau\\). Om \\(x\\) är binär gäller att \\(\\hat{\\tau}_{st} = N\\hat{p}_{st}\\) Totalestimatorns varians är \\(V(\\hat{\\tau}_{st}) = N^2V(\\bar{x}_{st})\\), vilken skattas med \\(\\hat{V}(\\hat{\\tau}_{st}) = N^2\\hat{V}(\\bar{x}_{st})\\). Om \\(x\\) är binär är \\(V(\\hat{\\tau}_{st}) = N^2V(\\hat{p}_{st})\\), vilken skattas med \\(\\hat{V}(\\hat{\\tau}_{st}) = N^2\\hat{V}(\\hat{p}_{st})\\). Samplingfördelningen följer samma regler som för \\(\\bar{x}_{st}\\) respektive \\(\\hat{p}_{st}\\). Samma principer gäller som för när stratifierat urval används för inferens om \\(\\mu\\) respektive \\(p\\). 5.2.4 Allokering av \\(n\\). För att allokera ett stickprov av storleken \\(n\\) till \\(K\\) strata används formeln \\[n_j=\\dfrac{\\sigma_jN_j}{\\sum_{j=1}^K \\sigma_j N_j}\\] Neyman-allokering innebär hänsyn tas till variation och populationsstorlek. Proportionell allokering innebär allokering utifrån de stratumspecifika populationsstorlekar men hänsyn tas ej tas variansen. Därmed förkortas \\(\\sigma_j\\) bort från allokeringsformeln. Proportionell allokering är mindre effektiv än Neyman-allokering, men denna allokeringsmetod väljs ändå på grund av ett eller flera av följande skäl: (i) Varianserna antas vara lika varandra i olika stratum och Neymana-allokering skulle innebära en mycket låg precisionsvinst. (ii) Det saknas information om de stratumspecifika varianserna. (iii) Inferensen blir enklare med proportionell allokering eftersom det leder till ett så kallat självvägt urval (alla element i populationen har samma inklusionssannolikhet). Lika allokering innebär att \\(n_j=n/K\\). 5.2.5 Efterstratifiering Efterstratifiering (poststratifiering) innebär att en stratifiering görs i efterhand. Anledningen är att hjälpvariabeln inte finns i urvalsramen och det är först efter datainsamlingen som elementens stratumtillhörigheter blir kända. En förutsättning för efterstratifiering är dock att information om hjälpvariabeln är känd på aggregerad nivå i populationen, dvs \\(N_j\\) för respektive stratum måste vara känd. Efterstratifiering leder till att de stratumspecifika stickprovsstorlekarna \\(n_j\\) är slumpvariabler eftersom de stratumspecifika stickprovsstorlekarna beror de element som valts ut i urvalet. På detta vis skiljer sig efterstratifering från sedvanligt stratifierat urval där \\(n_j\\) är konstanter som väljs i förväg. På grund av denna extra slumpmässighet är estimatorernas varianser vid efterstratifiering alltid större än vid stratifierat urval, dvs \\(V(\\bar{x}_{post} &gt; V(\\bar{x}_{st}\\), \\(V(\\hat{\\tau}_{post} &gt; V(\\hat{\\tau}_{st}\\) och \\(V(\\hat{\\tau}_{post} &gt; V(\\hat{\\tau}_{st}\\). Dock minskar skillnaden mellan varianserna när \\(n\\) är stort och all \\(n_j\\) är relativt stora. Därför gäller att om \\(n\\) är stort och alla \\(n_j\\) är relativt stora används samma variansskattningar som vid stratifierat urval. En praktisk konsekvens är att man inte kan välja allt för många strata vid en efterstratifiering. Istället för att stratifiera utifrån nio eller tio ålderskategorier så måste vi nöja oss med två eller tre strata. Undersökaren måste i förväg ha bestämt hur stratifiering ska göras, så att man inte letar efter en lämplig stratumindelning i efterhand. Efterstratifiering används ofta för korrigera för bortfall i en undersökning. 5.3 Övningar När lösningar presenteras till uppgifter som liknar tidigare genomgådda uppgifter kommer förklaringarna inte vara lika utförliga. Detta för att minska textmängden. Om du upplever ett kommando oklart, försök först att hitta en förklaring i tidigare kod och glöm inte bort hjälp-funktionen i R. Övning 1 I ett nybyggt höghusområde önskade kommunen undersöka förskolebehovet. Kommunen gjorde därför ett obundet slumpmässigt urval utan återläggning (OSU-UÅ) av 100 hushåll. Frågan som ställdes var hur många platser som hushållen är i behov av. Totalt finns det 800 hushåll i området. Av de tillfrågade hushållen angav 56 inget behov, 34 hade behov av en plats, 7 hade behov av två platser och 3 hade behov av tre platser. Beräkna ett 95 % konfidensintervall (KI) för det totala antalet önskade förskoleplatser i området. Var noga med förutsättningar! Tolka intervallet! Beräkna ett 95 % KI för andelen hushåll i området som inte önskar någon förskoleplats. Var noga med förutsättningar! Tolka intervallet! Svar 1 Mål: Skatta populationstotalen \\(\\tau\\) med konfidensgraden 95%. Estimator: \\(\\hat{\\tau} = N \\bar{x}\\) där \\(\\bar{x}\\) är stickprovsmedelvärdet. Förutsättningar: 1. OSU-UÅ ger att \\(\\hat{\\tau}\\) är vvr. 2. \\(N=800\\), dvs populationen är ändlig och \\(V(\\hat{\\tau} )\\) skattas med \\(\\hat{V}(\\tau)=N^2(1-\\frac{n}{N})\\frac{s^2}{n}\\). 3. \\(n=100\\). Eftersom stickprovsstorleken är \\(n&gt;30\\) så är \\(\\hat{\\tau}\\) approximativt normalfördelad enligt CGS. Beräkningar: Ett 95% konfidensintervall för \\(\\tau\\) ges av \\[ \\hat{\\tau}\\pm z_{\\alpha/2}\\sqrt{\\hat{V}(\\hat{\\tau})} \\] där \\(z_{ \\alpha/2 } = z_{0.025} = 1.96\\) och \\(\\hat{V}(\\hat{\\tau}) = N^2\\left(1-\\dfrac{n}{N}\\right)\\dfrac{s^2}{n}\\). # Börja med att tömma minnet inför uppgiften rm(list = ls()) # Skapa variabeln platsbehov utifrån informationen i uppgiften platsbehov &lt;- c(rep(0, times = 56), rep(1, times = 34), rep(2, times = 7), rep(3, times = 3)) # Populationsstorlek N &lt;- 800 # Urvalsstorlek n &lt;- length(platsbehov) # Skatta totalen tauhat &lt;- N * mean(platsbehov) # Beräkna stickprovsvariansen s2 &lt;- var(platsbehov) # Variansskattning (Notera att vi av utrymmesskäl använder det kortare vtauhat och inte det mer korrekta vhattauhat) vtauhat &lt;- N^2 * (1 - n/N) * (s2/n) # Välj konfidensgraden 100*(1-alpha)% alpha &lt;- 0.05 z_alpha &lt;- qnorm( (1 - alpha/2) ) # Beräkna konfidensintervallet tau_LB &lt;- tauhat - z_alpha * sqrt(vtauhat) tau_UB &lt;- tauhat + z_alpha * sqrt(vtauhat) Svar: Det totala antalet önskade förskoleplatser i området skattas till 456 stycken. Med 95% säkerhet täcker intervallet 345 \\(&lt; \\tau &lt;\\) 567 det totala antalet önskade förskoleplatser i området. Beräkna ett 95 % KI för andelen hushåll i området som inte önskar någon förskoleplats. Var noga med förutsättningar! Tolka intervallet! Mål: Skatta populationsandelen \\(p\\) med konfidensgraden 95%. Estimator: \\(\\hat{p}\\) = stickprovsandelen. –&gt; Förutsättningar: 1. OSU-UÅ ger att \\(\\hat{p}\\) är vvr. 2. \\(N=800\\), dvs populationen är ändlig och \\(V(\\hat{p})\\) skattas med \\(\\hat{V}(\\hat{p})=(1-\\frac{n}{N})\\frac{\\hat{p}(1-\\hat{p})}{n-1}\\). 3. \\(n=100\\). Om \\(np(1-p)&gt;5\\) är \\(\\hat{p}\\) approximativt normalfördelad enligt CGS. Kontrollera med stickprovskvantiterna att detta verkar vara uppfyllt! Beräkningar: Ett 95% KI för \\(p\\) ges av \\[\\hat{p} \\pm z_{\\alpha/2} \\sqrt{\\left(1-\\frac{n}{N}\\right)\\frac{\\hat{p}(1-\\hat{p})}{n-1}}\\] där \\(z_{\\alpha/2}=z_{0,025}=1.96\\). # Skapa binär variabel platsbehov_bin som är 1 om ej platsbehov 0 annars platsbehov_bin &lt;- rep(NA, n) platsbehov_bin[platsbehov == 0] &lt;- 1 platsbehov_bin[platsbehov == 1] &lt;- 0 platsbehov_bin[platsbehov == 2] &lt;- 0 platsbehov_bin[platsbehov == 3] &lt;- 0 # Skatta andelen phat &lt;- mean(platsbehov_bin) # Skatta variansen för andelen (återigen skriver vi av utrymmeskäl in vhatphat) vphat &lt;- (1 - n/N) * ( phat*(1 - phat)/(n-1) ) # Kolla förutsättning för normalitet normalitet &lt;- n*phat*(1-phat) # Beräkna konfidensintervall p_LB &lt;- phat - z_alpha*sqrt(vphat) p_UB &lt;- phat + z_alpha*sqrt(vphat) Kontroll av förutsättningen för normalitet ger \\(n \\hat{p}(1-\\hat{p}) =\\) 24.64. Svar: Andelen i området som ej önskar förskoleplats skattas till 0.56. Med 95% säkerhet täcker intervallet 0.47 \\(&lt; p &lt;\\) 0.65 andelen önskade förskoleplatser i området. Övning 2 Vid en marknadsundersökning i en kommun med \\(8000\\) hushåll utvaldes 200 hushåll med OSU-UÅ. De utvalda hushållen tillfrågades genom brevenkät bland annat om åsikterna beträffande ett antal produkter. Efter påminnelser hade kommunen fått svar från samtliga 200 hushåll. De i urvalet ingående hushållens procentuella fördelning efter åsikt beträffande en viss produkt A blev följande: Utmärkt (U) 30%, Tillfredsställande (T) 50%, Dålig (D) 20%. Beräkna ett 95% konfidensintervall för antalet hushåll i kommunen som anser att produkten är dålig. Var noga med förutsättningar! Tolka intervallet! Hur stort är medelfelet för andelen hushåll i kommunen som anser att produkten är utmärkt? Var noga med förutsättningar! Tolka medelfelet! Svar 2 Mål: Intervallskatta antalet hushåll i kommunen som anser att produkten är dålig med konfidensgraden 95%. Parameter: \\(\\tau=Np\\) = totala antalet hushåll i kommunen som anser att produkten är dålig. Estimator: \\(\\hat{\\tau}=N\\hat{p}\\) = antalet hushåll i stickprovet som anser att produkten är dålig. Förutsättningar: 1. ger att \\(E(\\hat{\\tau})=\\tau\\), dvs att \\(\\hat{\\tau}\\) är en väntevärdesriktig skattning av \\(\\tau\\). 2. Populationsstorlek: \\(N = 8000\\). Urvalsstorlek: \\(n = 200\\). \\(V(\\hat{\\tau})\\) skattas med \\(V(\\hat{\\tau})=N^2\\hat{V}(\\hat{p})=N^2\\left(1-\\frac{n}{N}\\right)\\frac{\\hat{p}(1-\\hat{p})}{n-1}\\). 3.Om \\(np(1-p)&gt;5\\) är \\(\\hat{\\tau}=N\\hat{p}\\) i detta fall approximativt normalfördelad enligt CGS. Kontrollera med stickprovskvantiterna att detta verkar vara uppfyllt! Beräkning: Ett 95% konfidensintervall för \\(\\tau\\) ges av –&gt; "],
["kategorivariabler.html", "Kapitel 6 Kategorivariabler 6.1 Analys av binära variabeler 6.2 Analys av variabler med mer än två kategorier 6.3 Exportera tabeller till html –&gt; 6.4 Några frekvent förekommande tabeller", " Kapitel 6 Kategorivariabler I princip alla datamaterial innehåller kategorivariabler och finns inga sådana från början är det vanligt att på olika sätt omkoda kvantitativa variabler till kategorier. Dessutom hanteras diskreta kvantitativa variabler med få värden ofta som en kategorivariabel. Kategorivariabler är generellt sett besvärligare att arbeta med jämfört med kvantitativa variabler. Något som kan vara förvirrande inledningsvis är att det finns två alternativ beträffande hur man väljer att arbeta med kategorivariabler, som bägge är viktiga för en dataanlytiker att hantera. Det går att definiera variabeln som datatypen faktor (nominal eller ordinal, dvs med eller utan ordning). Detta görs med funktionen factor(). En faktors kategorier benämns i R för levels (nivåer) och med funktionen factor() kan användaren även kan ange om nivåerna går att rangordna eller inte. Det går även att ange referensnivå samt tilldela nivåerna namn. Genom att använda datatypen faktor använder R information om kategorivariabeln i analyser. Till exempel kan namnen på olika kategorierna skrivas ut i resultat eller så man på ett enkelt sätt ändra rangordningen på kategorierna. Det går dock inte att utföra några räkneoperationer på en faktor. Det går att tilldela variabeln numeriska värden till de olika kategorierna, till exempel 0-1 till en variabel med två kategorier. Hur dessa värden sedan används beror på analysmetod. Eftersom bägge varianterna har för- och nackdelar finns oftast bägge typerna av kodning för en och samma kategorivariabel i ett dataset, där kategorivariabler kodade som faktorer kallas variabelnamn_cat och numeriska kategorivariabler kallas för variabelnamn_bin om den är kodad 0-1. Slutligen så involderar dataanalys med kategorivariabler i regel arbete med tabeller: Frekvenstabeller. (dvs en univariat beskrivning av en kategori-variabel) Korstabeller i R Export av tabeller till HTML (som sedan kan importeras till ordbehandlingsprogram) 6.1 Analys av binära variabeler 6.1.1 Analys av en binär variabel Binära variabler har enbart två kategorier och det är den absolut vanligaste typen av kategorivariabel. Oavsett om en binär variabel har kategorier som inte går att rangordna (till exempel \\(kön\\) med kategorierna \\(kvinna\\) och \\(man\\)) eller har kategorier som går att rangordna (till exempel \\(utbildning\\) med kategorierna \\(låg\\) och \\(hög\\)) hanteras och analyseras en binär variabel på samma sätt. Som tidigare nämnt arbetar vi i praktiskt i R på två sätt: De två kategorierna i den binära variabeln tilldelas numeriska värden och variabeln analyseras sedan som en numerisk variabel. Vanligast är att ge kategorierna värdena 0 och 1. Anledningen är tolkningen blir i termer av andelar av den kategori som är kodad 1. Dessutom förenklas tolkning i sambandsanalyser, vilket vi ska komma att se senare. Exemplet nedan illustrerar. &gt; # Ursprungsvariabel &gt; education &lt;- c(&quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;low&quot;, + &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, + &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, + &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, + &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;low&quot;, &quot;high&quot;, &quot;low&quot;, + &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;low&quot;, + &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, + &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, + &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, + &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;low&quot;, &quot;high&quot;, &quot;low&quot;, + &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, + &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, + &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, + &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, + &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, + &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, + &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;low&quot;, + &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, + &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, + &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, + &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;low&quot;, &quot;high&quot;, &quot;low&quot;, + &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;low&quot;, + &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, + &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, + &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, + &quot;low&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;low&quot;, &quot;high&quot;, &quot;low&quot;, + &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, + &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, + &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, + &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, + &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;, + &quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;,&quot;low&quot;) &gt; str(education) &gt; chr [1:280] &quot;high&quot; &quot;high&quot; &quot;low&quot; &quot;high&quot; &quot;high&quot; &quot;low&quot; &quot;high&quot; &quot;low&quot; &quot;low&quot; ... &gt; # Numerisk kodning: 0 = low, 1 = high &gt; edu_bin &lt;- rep(NA, length(education)) &gt; edu_bin[education == &quot;high&quot;] &lt;- 1 &gt; edu_bin[education == &quot;low&quot;] &lt;- 0 &gt; str(edu_bin) &gt; num [1:280] 1 1 0 1 1 0 1 0 0 1 ... &gt; # Numerisk kodning: 1 = low, 2 = high &gt; edu_12 &lt;- rep(NA, length(education)) &gt; edu_12[education == &quot;high&quot;] &lt;- 2 &gt; edu_12[education == &quot;low&quot;] &lt;- 1 &gt; str(edu_12) &gt; num [1:280] 2 2 1 2 2 1 2 1 1 2 ... &gt; # Beräkna medelvärdet (andelen) &gt; mean(edu_bin) &gt; [1] 0.4142857 &gt; mean(edu_12) &gt; [1] 1.414286 Medelvärdet när variabelns kategorier är kodade 1-2 inte är tolkningsbart på samma uppenbara sätt som vid kodningen 0-1. Med kommandot str() undersöker vi datatypen och vi ser att education är av typen character medan edu_01 och edu_12 är av datatypen numeric. Det är viktigt att undersöka datatyp, emellertid är detta ingen kod man vanligtvis sparar i scriptet. Efter datatypen är undersökt kan dessa rader tas bort. Den binära variabeln definieras som datatypen faktor med funktionen factor() Med argumentet levels kan vi ändra nivåerna. Vidare kan vi använda funktionen levels kan vi ändra kategorinamn. Vi nedan illusterar med R. &gt; # Skapa en faktorvariabel &gt; edu_cat &lt;- factor(education) &gt; str(edu_cat) &gt; Factor w/ 2 levels &quot;high&quot;,&quot;low&quot;: 1 1 2 1 1 2 1 2 2 1 ... &gt; summary(edu_cat) &gt; high low &gt; 116 164 &gt; # Test att utföra en räkneoperation på en faktorvariabel &gt; mean(edu_cat) &gt; Warning in mean.default(edu_cat): argument is not numeric or logical: returning &gt; NA &gt; [1] NA Vi har nu definierat en faktor-variabel med två kategorier “high” and “low”. Vi kan även se att R även tilldelat kategorierna nivåer, där “high” är level 1 och “low” är level 2. Nivåernas ordning bestäms utifrån ordning de först dyker upp i objektet såvida inte vi gör om en numerisk variabel till en faktor. Även om vi nu arbetar med en binär variabel där nominal- eller ordinalskala teoretiskt saknar betydelse, är det viktigt att se till att ordningen stämmer eftersom med sin tänkta analys eftersom ordningen påverkar analyser i R. I detta exempel är det dessutom förmodligen förvirrande för användaren att “high” har tilldelats nivå 1 medan “low” är nivå 2. Av dessa skäl ändras därför ordningen med hjälp av argumentet levels. &gt; # Ändra ordningen på nivåerna &gt; edu_cat &lt;- factor(education, levels = c(&quot;low&quot;, &quot;high&quot;)) &gt; str(edu_cat) &gt; Factor w/ 2 levels &quot;low&quot;,&quot;high&quot;: 2 2 1 2 2 1 2 1 1 2 ... &gt; summary(edu_cat) &gt; low high &gt; 164 116 &gt; # Gör en numerisk variabel med två värden till en faktor. Notera att nivåerna i detta fall inte bestäms &gt; # av ordningen i vektorn utan av de numeriska värdens storlek. &gt; x &lt;- c(3, 1, 1, 3, 3) &gt; x_cat &lt;- factor(x) &gt; str(x_cat) &gt; Factor w/ 2 levels &quot;1&quot;,&quot;3&quot;: 2 1 1 2 2 Avslutningsvis illustrerar vi nu att vi ändrar namn från low till L samt high till H. OBS! Nedanstående kod är inget som är uppenbart för nybörjaren och det går att mer kompakt ändra namn på kategorier i en faktor-variabel med hjälp av argumentet labels. Dock gäller det då att vara nogrann med ordningen och därför rekommenderas den kod som presenteras här. Enklast är att kopiera koden och klistra in och ändra. &gt; # Funktionen levels() skapar en character-vektor med namn på kategorierna &gt; levels(edu_cat) &gt; [1] &quot;low&quot; &quot;high&quot; &gt; # Ändra för valt element namn i vektor levels(education_cat) &gt; levels(edu_cat)[levels(edu_cat) == &quot;low&quot;] &lt;- &quot;L&quot; &gt; levels(edu_cat)[levels(edu_cat) == &quot;high&quot;] &lt;- &quot;H&quot; &gt; edu_cat &gt; [1] H H L H H L H L L H H H H H H L H H H H H H H H H L H H H L H H L H H H L &gt; [38] L H L H H L H H L H L L H H H H H H L H H H H H H H H H L H H H L H H L H &gt; [75] H H L L H L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L &gt; [112] L L L L L L L L L L L L L L L L L L L L L L L L L L L L L H H L H H L H L &gt; [149] L H H H H H H L H H H H H H H H H L H H H L H H L H H H L L H L H H L H H &gt; [186] L H L L H H H H H H L H H H H H H H H H L H H H L H H L H H H L L H L L L &gt; [223] L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L &gt; [260] L L L L L L L L L L L L L L L L L L L L L &gt; Levels: L H 6.1.2 Binära variabler med missing Om en variabel har bortfall krävs viss försiktighet. Nedanstående kodning för att koda om high till 1 och low till 0. &gt; # Skapa en variabel med missing data (NA) i element 3, 10, 100 &gt; education_mis &lt;- education &gt; education_mis[3] &lt;- NA &gt; education_mis[10] &lt;- NA &gt; education_mis[100] &lt;- NA &gt; # Numerisk kodning: 0 = low, 1 = high &gt; edu_bin_mis &lt;- rep(NA, length(education_mis)) &gt; edu_bin_mis[education_mis == &quot;high&quot;] &lt;- 1 &gt; edu_bin_mis[education_mis == &quot;low&quot;] &lt;- 0 &gt; # Genom att ta summary ser vi om det finns 3 missing i edu_bin &gt; summary(edu_bin_mis) &gt; Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s &gt; 0.0000 0.0000 0.0000 0.4152 1.0000 1.0000 3 &gt; # Medelvärdet (andelen) beräknas med argumentet na.rm = TRUE &gt; mean(edu_bin_mis) &gt; [1] NA &gt; mean(edu_bin_mis, na.rm = TRUE) &gt; [1] 0.4151625 6.1.3 Analays av en binär variabel med en tabell Den grundläggande funktionen för skapa tabeller är table(), vilken har flexibilitet att hantera både en och flera variabler. Det finns flera olika sätt att skapa tabeller i R och den avancerade användaren kan kombinera olika funktioner för att skapa exakt den avancerade tabell man har satt sig för att skapa. Många grundläggande tabeller kan dock skapas genom att skapa ett antal tabellobjekt som sedan sätts samman likt byggstenar. Vi börjar med att titta på en mest grundläggande tabellfunktionen table(). Denna presenterar frekvenser och dessutom bortfall om vi använder argumentet useNA. &gt; table(edu_cat) &gt; edu_cat &gt; L H &gt; 164 116 &gt; table(edu_bin) &gt; edu_bin &gt; 0 1 &gt; 164 116 &gt; table(edu_bin_mis) &gt; edu_bin_mis &gt; 0 1 &gt; 162 115 &gt; table(edu_bin_mis, useNA = &quot;ifany&quot;) &gt; edu_bin_mis &gt; 0 1 &lt;NA&gt; &gt; 162 115 3 I regel sparas tabeller i objekt. Tabell-objekt kan dock vara något omständliga att arbeta och det kan i ibland vara fördelaktigt att konvertera tabellen till en data frame för att kunna hämta element från tabellen. Se koden nedan för att undersöka skillnaden mellan tabell-objekt och data frame. När tabellen är konverterad till data frame går det använda sedvanlig metod för att ändra namn på variabler. &gt; freq_table_edu_cat &lt;- table(edu_cat) &gt; freq_table_edu_cat &gt; edu_cat &gt; L H &gt; 164 116 &gt; str(freq_table_edu_cat) &gt; &#39;table&#39; int [1:2(1d)] 164 116 &gt; - attr(*, &quot;dimnames&quot;)=List of 1 &gt; ..$ edu_cat: chr [1:2] &quot;L&quot; &quot;H&quot; &gt; freq_table_edu &lt;- data.frame(freq_table_edu_cat) &gt; freq_table_edu &gt; edu_cat Freq &gt; 1 L 164 &gt; 2 H 116 Ofta vill man se resultat presenterade som andelar och funktionen prop.table ger oss sådana. &gt; # Skapa tabell med andelar från tabell-objektetet &gt; prop_table_edu_cat &lt;- prop.table(freq_table_edu_cat) &gt; prop_table_edu_cat &gt; edu_cat &gt; L H &gt; 0.5857143 0.4142857 &gt; # Kombinera frekvenser och andelar. Passa samtidigt på att avrunda och göra om variabeln till procent. &gt; table_edu &lt;- cbind(freq_table_edu_cat, round(100*prop_table_edu_cat,1)) &gt; colnames(table_edu) &lt;- c(&quot;Frekvens&quot;, &quot;Andel (%)&quot;) &gt; table_edu &gt; Frekvens Andel (%) &gt; L 164 58.6 &gt; H 116 41.4 Vi ska senare se på hur denna tabell kan exporteras. 6.1.4 Analys av två binära variabler Vi ska nu se på hur funktionen table() kan användas för analysera samband mellan två variabler. Att titta på korstabeller är alltid ett första steg innan man genomför hypotesprövning. Skapande av korstabeller kräver också att vi funderar på hur sambandet presenteras. I table() anges variabeln som ska finnas på raden först, sedan variabeln redovisas. Tabellen som erhålls kallas i fallet med två inkluderade variabler för tvåvägs-korstabell. Om det går att översätta variablerna i termer av oberoende variabel och beroende variabel, sätts den oberoende variabeln i regel kolumnsvis (x-axel) och den beroende variabeln radvis (y-axel). Det kan dock av utrymmesskäl finnas anledning att rucka på denna princip. Vi exemplifierar nedan med R-kod och vi ska nu beskriva sambandet mellan utbildningsnivå och rökning. Först skapas en korstabell med frekvenser och baserat på denna skapas en korstabell med relativa frekvenser baserat på kolumnprocent. Notera att det kräver en del pusslande, men vi har stor flexibilitet vad gäller den slutliga utformningen av tabellen. &gt; # Skapa en variabel smoker som är 1 om rökare och 0 om icke-rökare &gt; smoker &lt;- c(0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, + 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, + 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, + 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, + 1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1, + 1,1,1,1,0,0,0,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, + 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, + 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, + 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, + 1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1, + 1,1,1,1,0,0,0,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,1) &gt; # Korstabulering av edu_bin och smoker (vi sätter rökning kolumnvis) &gt; freq_table_edu_smoke &lt;- table(smoker, edu_bin) &gt; # Frekvenser &gt; freq_table_edu_smoke &gt; edu_bin &gt; smoker 0 1 &gt; 0 76 80 &gt; 1 88 36 &gt; colnames(freq_table_edu_smoke) &lt;- c(&quot;Low&quot;, &quot;High&quot;) &gt; rownames(freq_table_edu_smoke) &lt;- c(&quot;Non-smoker&quot;, &quot;Smoker&quot;) För att använda tabellen behöver vi ordna till den. Det är svårt att analysera samband från tabeller med absoluta frekvenser, därför vi vill även se redovisat relativa frekvenser. Med funktionen prop.table() kan vi på ett enkelt sätt erhålla relativa frekvenser. Funktionen prop.table() kan tillämpas på ett objekt från table() och beräknar proportioner baserat på totala antalet (default), radvisa frekvenser eller kolumnfrekvenser. Argumentet margin används för bestämma hur andelarna i tabellen ska beräknas. Notera att det är mycket viktigt att redovisa andelar korrekt eftersom tolkningen helt beror på hur procenten är beräknade. &gt; # Andelar baserat alla &gt; table_all &lt;- prop.table(freq_table_edu_smoke) &gt; table_all &gt; edu_bin &gt; smoker Low High &gt; Non-smoker 0.2714286 0.2857143 &gt; Smoker 0.3142857 0.1285714 &gt; # Procent baserat rader &gt; table_row_percent &lt;- prop.table(freq_table_edu_smoke, margin = 1) &gt; table_row_percent &gt; edu_bin &gt; smoker Low High &gt; Non-smoker 0.4871795 0.5128205 &gt; Smoker 0.7096774 0.2903226 &gt; # Andelar baserat kolumner &gt; table_column_percent &lt;- prop.table(freq_table_edu_smoke, margin = 2) &gt; table_column_percent &gt; edu_bin &gt; smoker Low High &gt; Non-smoker 0.4634146 0.6896552 &gt; Smoker 0.5365854 0.3103448 Eftersom sambandet bäst analyseras utifrån andelen rökare inom respektive utbildningskategori konstruerar vi nu en tabell med frekvenser och andelar baserat på detta samband. &gt; # Andelar baserat alla &gt; table_edu_smoke &lt;- cbind(freq_table_edu_smoke[,1], round(100*table_column_percent[,1], 1), + freq_table_edu_smoke[,2], round(100*table_column_percent[,2], 1)) &gt; table_edu_smoke &gt; [,1] [,2] [,3] [,4] &gt; Non-smoker 76 46.3 80 69 &gt; Smoker 88 53.7 36 31 &gt; colnames(table_edu_smoke) &lt;- c(&quot;Low education&quot;, &quot;%&quot;, &quot;High education&quot;, &quot;%&quot;) &gt; table_edu_smoke &gt; Low education % High education % &gt; Non-smoker 76 46.3 80 69 &gt; Smoker 88 53.7 36 31 Slutligen tittar vi på funktionen addmargins() som beräknar ger marginalerna i ett tabellobjeket. Med argumentet margins anges om alla marginaler, radmarginalen eller kolumnmargialen ska beräknas. &gt; # Andelar baserat alla &gt; table_edu_smoke &lt;- addmargins(table_edu_smoke, 1) 6.1.5 Kvantifiering och test av samband mellan två binära variabler Det vanligaste testet för analys av korstabeller är \\(\\chi^2\\)-test som testar om två variabler är oberoende. För att genomföra detta test i R används funktionen chisq.test(). Detta test går att genomföra oavsett skalnivå, men det finns alternativ med bättre styrka om avsikten är att testa om det finns en trend och det faktiskt finns en sådan. # Chitvå test baserat på tabellobjektet chisq.test(freq_table_edu_smoke) Pearson&#39;s Chi-squared test with Yates&#39; continuity correction data: freq_table_edu_smoke X-squared = 13.193, df = 1, p-value = 0.0002811 # Chitvå-test baserat på variablerna chisq.test(edu_bin, smoker) Pearson&#39;s Chi-squared test with Yates&#39; continuity correction data: edu_bin and smoker X-squared = 13.193, df = 1, p-value = 0.0002811 För att kvantifiera samband kan man använda skillnad i andelar (riskdifferens), relativa samt oddskvot. # Chitvå test baserat på tabellobjektet p1 &lt;- mean( smoker[edu_bin == 1] ) # Alternativt hämta andelarna från tabellen med table_row_percent[4] p0 &lt;- mean( smoker[edu_bin == 0] ) # Alternativt hämta andelarna från tabellen med table_row_percent[2] # Skillnad i andelar (riskdifferens) rd &lt;- p1 - p0 # kvot av andelar (relativ risk) rr &lt;- p1/p0 # oddskvot or &lt;- (p1/(1-p1)) / ((p0/(1-p0))) rd [1] -0.2262405 rr [1] 0.5783699 or [1] 0.3886364 # Kan du skapa konfidensintervall? Hur tolkar du resultatet? Vad gäller tolkning av resultat borde det kanske vara rimligt ur presentationsperspektiv att vända på analysen, dvs i vilken utsträckning ökar låg utbildning benägenheten att röka? 6.1.6 Export av tabeller Det kan vara omständligt att exportera data från R till Word. En smidig lösning är att spara tabellerna i html-format, vilket gör tabellerna program och plattformsoberoende. Du kan sedan när manuset närmar sig att bli klart, öppna html-filen, markera allt, och klistra in. Kom ihåg att det inte är nödvändigt att lägga in tabellerna i Word förrän manuset närmar sig att bli klart. För att exportera tabeller använder vi paketet xtable och funktionen xtable() tillsammans med funktionen print() (som finns i basversionen av R). Installera därför nödvändigt paket install.packages(\"xtable\"). library(&quot;xtable&quot;) print(xtable(table_edu_smoke), type=&quot;html&quot;, file=&quot;D://table_edu_smoke.html&quot;) För att sedan föra in tabellerna i ordbehandlingsprogram öppnas tabellen i en webläsare, du högerklickar någonstans i webläsaren och väljer markera allt, kopiera, och klistra in. 6.2 Analys av variabler med mer än två kategorier För att exemplifiera tittar vi på ett datamaterial. # Skapa en population och urval # Läs in data. Vi ska välja ut födda 1961 och födda 1975. insark &lt;- read.csv2(&quot;D:/conscriptiondata.csv&quot;) # Välja ut insark för födda 1961 insark1 &lt;- insark[insark$year == 1961,] # Välj ut INSARK för födda 1975 --&gt; insark2 &lt;- insark[insark$year == 1975,] # Skapa ett dataset av INSARK 1961 och 1975. insark3 &lt;- rbind(insark1, insark2) # Skapa nytt rad id baserat på delpopulationen 1961 och 1975 insark3$newid &lt;- 1:length(insark3$id) # Dra urval n &lt;- 1000 set.seed(12345) df &lt;- insark3[sample(insark3$newid, n), ] Variablen psych i INSARK mäter psykisk funktionsförmåga under stressade förhållande på en skala från från 1-9. I det inlästa datasetet är denna variabeln numerisk och värdet är satt av en psykolog. Dock kan denna variabel betraktas som en variabel på ordinalskala. Därför skapar vi en ny variabel psych_cat som R använder som ordinalskala. För att skapa en ordinal kategorivariabel används funktionen factor() och i detta fall lägger vi till argumentet ordered = TRUE eftersom det är en kategorivariabel som går att rangordna. Kör nedanstående kod och fundera varför R ger felmeddelanden. df$psych &gt; [1] 5 7 3 5 2 6 4 5 5 4 3 6 6 6 5 8 1 4 6 3 8 8 5 5 6 8 6 6 3 2 8 4 7 5 2 5 6 &gt; [38] 9 5 2 5 6 3 4 5 7 2 6 5 5 6 7 2 4 3 5 5 2 4 7 7 5 6 3 5 3 7 6 6 2 5 5 3 3 &gt; [75] 7 3 7 8 6 2 3 5 2 2 6 7 1 6 5 7 7 3 3 6 4 4 6 9 5 7 4 8 6 8 4 6 8 2 7 3 7 &gt; [112] 2 6 6 4 3 6 5 7 3 3 8 5 3 5 5 6 4 5 5 5 7 5 4 6 5 2 2 7 5 4 1 5 6 9 2 3 9 &gt; [149] 3 6 6 7 7 3 3 5 8 4 3 6 6 6 8 3 6 5 7 5 6 4 7 6 4 3 5 5 6 8 1 5 5 7 3 6 3 &gt; [186] 3 4 3 9 5 6 6 4 5 7 3 7 7 6 6 5 7 6 6 5 7 1 5 4 3 8 6 2 7 7 5 3 5 2 7 6 4 &gt; [223] 4 7 5 5 7 3 6 5 6 3 4 4 4 4 3 6 4 5 4 9 5 7 8 7 2 2 3 5 5 6 5 7 4 7 3 4 7 &gt; [260] 4 6 5 4 6 5 5 5 6 2 5 2 8 5 2 6 4 8 6 6 7 5 4 5 7 6 4 2 4 6 6 6 3 4 2 3 4 &gt; [297] 4 3 3 4 7 2 7 6 4 2 7 4 7 6 7 4 4 6 5 5 8 6 5 6 6 3 2 6 5 5 6 6 7 7 6 6 3 &gt; [334] 5 4 3 3 1 5 6 3 4 6 5 2 5 4 5 7 6 8 3 8 3 8 7 6 5 6 6 5 8 6 7 5 8 6 5 4 4 &gt; [371] 3 4 6 7 5 5 7 7 4 8 7 7 6 9 7 6 6 4 8 1 2 6 2 4 4 6 6 5 6 3 1 6 6 6 3 7 7 &gt; [408] 6 6 7 5 6 3 5 5 7 5 7 3 1 5 3 6 6 6 2 8 5 4 7 7 5 5 2 5 5 6 4 3 7 8 4 3 4 &gt; [445] 3 6 8 5 6 5 2 3 7 7 9 6 7 5 3 7 1 8 5 2 5 3 6 3 3 6 5 7 3 3 6 6 5 6 5 3 5 &gt; [482] 5 3 4 4 6 4 3 4 3 6 4 4 5 5 3 5 4 5 7 2 7 8 3 5 6 5 6 5 6 7 6 1 7 5 6 6 4 &gt; [519] 6 7 5 6 4 6 6 2 1 6 8 8 2 4 4 1 5 5 6 5 6 7 5 5 4 3 7 5 4 3 6 4 2 6 6 3 3 &gt; [556] 6 9 6 5 5 5 3 8 4 7 6 5 6 7 6 5 7 6 2 5 3 3 5 5 6 6 6 8 7 5 6 5 1 5 7 7 4 &gt; [593] 5 4 6 7 4 8 6 5 7 3 4 5 4 2 4 5 9 2 7 5 5 4 5 4 4 4 5 7 2 3 5 2 5 5 4 5 4 &gt; [630] 8 3 3 4 7 3 5 9 5 3 4 4 7 9 2 6 4 3 2 7 3 6 5 2 8 5 1 4 5 8 7 5 5 5 5 4 5 &gt; [667] 4 4 5 5 3 7 6 5 6 6 8 4 6 4 4 4 7 6 4 4 6 7 5 4 7 6 3 5 7 4 2 7 8 4 3 4 7 &gt; [704] 6 6 4 3 7 4 5 6 6 8 4 8 4 7 7 8 6 3 7 3 4 5 8 8 7 6 5 2 5 3 5 6 6 7 4 5 5 &gt; [741] 6 4 6 8 2 6 5 7 5 2 5 3 4 8 3 5 5 2 7 5 4 4 7 6 7 8 5 4 1 5 2 3 7 4 2 3 5 &gt; [778] 6 6 8 6 2 5 7 7 8 4 7 6 5 5 2 4 3 7 7 8 6 2 3 5 4 4 4 4 6 8 5 3 2 6 6 5 7 &gt; [815] 8 5 6 5 4 1 5 7 4 6 6 4 8 7 6 7 5 4 7 6 4 4 6 7 2 4 8 5 5 2 2 7 3 5 3 1 5 &gt; [852] 5 4 5 7 5 4 4 4 5 3 5 7 8 7 7 7 7 6 4 6 8 4 5 5 5 5 5 7 3 5 6 7 5 5 8 3 3 &gt; [889] 7 7 6 5 6 6 8 8 2 6 4 5 7 6 4 2 8 7 5 7 6 4 3 3 4 6 4 5 4 3 5 5 5 7 5 5 6 &gt; [926] 5 3 8 6 3 4 3 7 7 8 7 3 6 6 4 4 5 6 2 7 5 3 6 5 6 7 6 5 6 5 7 6 4 7 7 1 3 &gt; [963] 5 7 5 5 3 3 6 4 3 2 6 3 6 6 5 3 4 7 6 5 5 6 5 4 6 6 8 6 2 2 8 7 5 6 4 3 3 &gt; [1000] 4 df$psych_cat &lt;- factor(df$psych, ordered=TRUE) mean(df$psych) &gt; [1] 5.062 mean(df$psych_cat) &gt; Warning in mean.default(df$psych_cat): argument is not numeric or logical: &gt; returning NA &gt; [1] NA hist(df$psych) hist(df$psych_cat) &gt; Error in hist.default(df$psych_cat): &#39;x&#39; must be numeric Naturligtvis är det på grund av att vi försöker skapa histogram och medelvärden på psych_cat som inte är en kvantitativ variabel. Titta återigen på ditt dataset. psych_cat är således kategorivariabel (factor) på ordinalskalnivå. str(df) &gt; &#39;data.frame&#39;: 1000 obs. of 19 variables: &gt; $ id : int 703699 692123 702781 692870 689627 25548 393 701579 21052 2848 ... &gt; $ year : int 1975 1975 1975 1975 1975 1961 1961 1975 1961 1961 ... &gt; $ height : int 170 189 174 179 183 179 175 168 177 183 ... &gt; $ weight : int 69 69 60 73 74 71 60 62 69 62 ... &gt; $ psych : int 5 7 3 5 2 6 4 5 5 4 ... &gt; $ muscle : int 5 6 6 9 7 6 6 6 4 3 ... &gt; $ armstrength : num 392 335 404 545 451 ... &gt; $ physical : int 8 8 6 8 6 7 5 6 7 5 ... &gt; $ gripstrength: num 554 701 562 693 619 ... &gt; $ legstrength : num 624 601 633 791 646 ... &gt; $ sbp : int 118 141 106 121 130 125 124 151 140 126 ... &gt; $ dbp : int 77 80 63 68 61 55 55 90 78 62 ... &gt; $ officer : int NA 9 0 9 9 8 0 0 0 0 ... &gt; $ testa : int 24 35 25 18 25 27 26 30 27 30 ... &gt; $ testb : int 16 26 24 28 24 20 19 34 26 29 ... &gt; $ testc : int 5 39 18 23 28 16 12 36 20 16 ... &gt; $ testd : int 19 0 24 30 25 37 28 34 26 26 ... &gt; $ newid : int 76440 64864 75522 65611 62368 25548 393 74320 21052 2848 ... &gt; $ psych_cat : Ord.factor w/ 9 levels &quot;1&quot;&lt;&quot;2&quot;&lt;&quot;3&quot;&lt;&quot;4&quot;&lt;..: 5 7 3 5 2 6 4 5 5 4 ... df$psych_cat &gt; [1] 5 7 3 5 2 6 4 5 5 4 3 6 6 6 5 8 1 4 6 3 8 8 5 5 6 8 6 6 3 2 8 4 7 5 2 5 6 &gt; [38] 9 5 2 5 6 3 4 5 7 2 6 5 5 6 7 2 4 3 5 5 2 4 7 7 5 6 3 5 3 7 6 6 2 5 5 3 3 &gt; [75] 7 3 7 8 6 2 3 5 2 2 6 7 1 6 5 7 7 3 3 6 4 4 6 9 5 7 4 8 6 8 4 6 8 2 7 3 7 &gt; [112] 2 6 6 4 3 6 5 7 3 3 8 5 3 5 5 6 4 5 5 5 7 5 4 6 5 2 2 7 5 4 1 5 6 9 2 3 9 &gt; [149] 3 6 6 7 7 3 3 5 8 4 3 6 6 6 8 3 6 5 7 5 6 4 7 6 4 3 5 5 6 8 1 5 5 7 3 6 3 &gt; [186] 3 4 3 9 5 6 6 4 5 7 3 7 7 6 6 5 7 6 6 5 7 1 5 4 3 8 6 2 7 7 5 3 5 2 7 6 4 &gt; [223] 4 7 5 5 7 3 6 5 6 3 4 4 4 4 3 6 4 5 4 9 5 7 8 7 2 2 3 5 5 6 5 7 4 7 3 4 7 &gt; [260] 4 6 5 4 6 5 5 5 6 2 5 2 8 5 2 6 4 8 6 6 7 5 4 5 7 6 4 2 4 6 6 6 3 4 2 3 4 &gt; [297] 4 3 3 4 7 2 7 6 4 2 7 4 7 6 7 4 4 6 5 5 8 6 5 6 6 3 2 6 5 5 6 6 7 7 6 6 3 &gt; [334] 5 4 3 3 1 5 6 3 4 6 5 2 5 4 5 7 6 8 3 8 3 8 7 6 5 6 6 5 8 6 7 5 8 6 5 4 4 &gt; [371] 3 4 6 7 5 5 7 7 4 8 7 7 6 9 7 6 6 4 8 1 2 6 2 4 4 6 6 5 6 3 1 6 6 6 3 7 7 &gt; [408] 6 6 7 5 6 3 5 5 7 5 7 3 1 5 3 6 6 6 2 8 5 4 7 7 5 5 2 5 5 6 4 3 7 8 4 3 4 &gt; [445] 3 6 8 5 6 5 2 3 7 7 9 6 7 5 3 7 1 8 5 2 5 3 6 3 3 6 5 7 3 3 6 6 5 6 5 3 5 &gt; [482] 5 3 4 4 6 4 3 4 3 6 4 4 5 5 3 5 4 5 7 2 7 8 3 5 6 5 6 5 6 7 6 1 7 5 6 6 4 &gt; [519] 6 7 5 6 4 6 6 2 1 6 8 8 2 4 4 1 5 5 6 5 6 7 5 5 4 3 7 5 4 3 6 4 2 6 6 3 3 &gt; [556] 6 9 6 5 5 5 3 8 4 7 6 5 6 7 6 5 7 6 2 5 3 3 5 5 6 6 6 8 7 5 6 5 1 5 7 7 4 &gt; [593] 5 4 6 7 4 8 6 5 7 3 4 5 4 2 4 5 9 2 7 5 5 4 5 4 4 4 5 7 2 3 5 2 5 5 4 5 4 &gt; [630] 8 3 3 4 7 3 5 9 5 3 4 4 7 9 2 6 4 3 2 7 3 6 5 2 8 5 1 4 5 8 7 5 5 5 5 4 5 &gt; [667] 4 4 5 5 3 7 6 5 6 6 8 4 6 4 4 4 7 6 4 4 6 7 5 4 7 6 3 5 7 4 2 7 8 4 3 4 7 &gt; [704] 6 6 4 3 7 4 5 6 6 8 4 8 4 7 7 8 6 3 7 3 4 5 8 8 7 6 5 2 5 3 5 6 6 7 4 5 5 &gt; [741] 6 4 6 8 2 6 5 7 5 2 5 3 4 8 3 5 5 2 7 5 4 4 7 6 7 8 5 4 1 5 2 3 7 4 2 3 5 &gt; [778] 6 6 8 6 2 5 7 7 8 4 7 6 5 5 2 4 3 7 7 8 6 2 3 5 4 4 4 4 6 8 5 3 2 6 6 5 7 &gt; [815] 8 5 6 5 4 1 5 7 4 6 6 4 8 7 6 7 5 4 7 6 4 4 6 7 2 4 8 5 5 2 2 7 3 5 3 1 5 &gt; [852] 5 4 5 7 5 4 4 4 5 3 5 7 8 7 7 7 7 6 4 6 8 4 5 5 5 5 5 7 3 5 6 7 5 5 8 3 3 &gt; [889] 7 7 6 5 6 6 8 8 2 6 4 5 7 6 4 2 8 7 5 7 6 4 3 3 4 6 4 5 4 3 5 5 5 7 5 5 6 &gt; [926] 5 3 8 6 3 4 3 7 7 8 7 3 6 6 4 4 5 6 2 7 5 3 6 5 6 7 6 5 6 5 7 6 4 7 7 1 3 &gt; [963] 5 7 5 5 3 3 6 4 3 2 6 3 6 6 5 3 4 7 6 5 5 6 5 4 6 6 8 6 2 2 8 7 5 6 4 3 3 &gt; [1000] 4 &gt; Levels: 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 Om variabeln är på ordinalskalenivå. För variabeln psych_cat står Levels: 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 som indikerar hur nivåerna är rangordnade. OBS! Trots att det är siffror i variabeln hanteras inte dessa som numeriska värden. Genom att använda funktionen levels() kan vi se vilka nivåer en faktor-variabel har. # Namn på nivåerna i faktorn psych_cat levels(df$psych_cat) &gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; # Ändra namn på nivåerna i psych_cat levels(df$psych_cat)[levels(df$psych_cat)==&quot;1&quot;] &lt;- &quot;A&quot; levels(df$psych_cat)[levels(df$psych_cat)==&quot;2&quot;] &lt;- &quot;B&quot; levels(df$psych_cat)[levels(df$psych_cat)==&quot;3&quot;] &lt;- &quot;C&quot; levels(df$psych_cat)[levels(df$psych_cat)==&quot;4&quot;] &lt;- &quot;D&quot; levels(df$psych_cat)[levels(df$psych_cat)==&quot;5&quot;] &lt;- &quot;E&quot; levels(df$psych_cat)[levels(df$psych_cat)==&quot;6&quot;] &lt;- &quot;F&quot; levels(df$psych_cat)[levels(df$psych_cat)==&quot;7&quot;] &lt;- &quot;G&quot; levels(df$psych_cat)[levels(df$psych_cat)==&quot;8&quot;] &lt;- &quot;H&quot; levels(df$psych_cat)[levels(df$psych_cat)==&quot;9&quot;] &lt;- &quot;I&quot; levels(df$psych_cat) &gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; str(df$psych_cat) &gt; Ord.factor w/ 9 levels &quot;A&quot;&lt;&quot;B&quot;&lt;&quot;C&quot;&lt;&quot;D&quot;&lt;..: 5 7 3 5 2 6 4 5 5 4 ... För att ändra rangordningen används funktionen ordered() och argumentet levels, där namnen på nivåerna placeras i en vektor som anger den rangordning nivåerna ska ha. df$psych_cat &lt;- ordered(df$psych_cat, levels=c(&quot;I&quot;, &quot;H&quot;, &quot;G&quot;, &quot;F&quot;, &quot;E&quot;, &quot;D&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;)) str(df$psych_cat) &gt; Ord.factor w/ 9 levels &quot;I&quot;&lt;&quot;H&quot;&lt;&quot;G&quot;&lt;&quot;F&quot;&lt;..: 5 3 7 5 8 4 6 5 5 6 ... I exemplet vänds rangordningen, men det går att ordna nivåerna i vilken ordning som helst. Baserat på urvalet är nu målet att skapa frekvenstabell som innehåller både absoluta och relativa frekvenser. För att skapa tabeller används funktionerna Baserat på urvalet är nu målet är att skapa en tabell som beskriver variabeln psych, som är bedömd psykisk funktionsförmåga som är en variabel med 9 steg, där 1 är sämst och 9 är bäst. Vi börjar med att titta på exemplet där variabeln psych används som numerisk variabel. Med funktionerna colnames() och rownames() går det att namnge kolumner och rader i tabellobjektet. # Univariat tabell med frekvenser och proportioner freqtable_psych &lt;- table(df$psych) proptable_psych &lt;- prop.table(freqtable_psych) table_psych &lt;- cbind(freqtable_psych, 100*proptable_psych) table_psych &lt;- addmargins(table_psych, margin = 1) colnames(table_psych) &lt;- c(&quot;Frekvens&quot;, &quot;%&quot;) rownames(table_psych) &lt;- c(&quot;Kat 1&quot;, &quot;Kat 2&quot;, &quot;Kat 3&quot;, &quot;Kat 4&quot;, &quot;Kat 5&quot;, &quot;Kat 6&quot;, &quot;Kat 7&quot;, &quot;Kat 8&quot;, &quot;Kat 9&quot;, &quot;Total&quot;) freqtable_psych &gt; &gt; 1 2 3 4 5 6 7 8 9 &gt; 19 67 122 150 220 200 145 65 12 proptable_psych &gt; &gt; 1 2 3 4 5 6 7 8 9 &gt; 0.019 0.067 0.122 0.150 0.220 0.200 0.145 0.065 0.012 table_psych &gt; Frekvens % &gt; Kat 1 19 1.9 &gt; Kat 2 67 6.7 &gt; Kat 3 122 12.2 &gt; Kat 4 150 15.0 &gt; Kat 5 220 22.0 &gt; Kat 6 200 20.0 &gt; Kat 7 145 14.5 &gt; Kat 8 65 6.5 &gt; Kat 9 12 1.2 &gt; Total 1000 100.0 Notera att tabellen med proportioner multipliceras med 100 för att få resultaten i procent. Det kan även finns anledning att avrunda resultat med funktionen round(). Antalet decimaler i avrundningen beror på behovet av precision i resultatredovisningen. Ska tabellen användas i beräkningar i R, alltså inte som en del av en rapport, bör ingen dock avrundning ske. table_psych &lt;- cbind(round(freqtable_psych, 0), round(100*proptable_psych), 0) Alternativet är nu att skapa en variabel som heter psych_cat och sedan använda funktionen levels() för att ange nivåerna i faktorn. Som vanligt när vi skapar en ny variabel adderas vi den till datamaterialet. # För att namnge raderna kan göra om psych-variabeln till en faktor som namnges. df$psych_cat &lt;- factor(df$psych, ordered = TRUE) levels(df$psych_cat) = c(&quot;Kat 1&quot;, &quot;Kat 2&quot;, &quot;Kat 3&quot;, &quot;Kat 4&quot;, &quot;Kat 5&quot;, &quot;Kat 6&quot;, &quot;Kat 7&quot;, &quot;Kat 8&quot;, &quot;Kat 9&quot;) freqtable_psych_cat &lt;- table(df$psych_cat) proptable_psych_cat &lt;- prop.table(freqtable_psych_cat) table_psych_cat &lt;- cbind(round(freqtable_psych_cat), round(100*proptable_psych_cat, 1)) table_psych_cat &lt;- addmargins(table_psych_cat, 1) colnames(table_psych_cat) &lt;- c(&quot;Frekvens&quot;, &quot;%&quot;) table_psych_cat &gt; Frekvens % &gt; Kat 1 19 1.9 &gt; Kat 2 67 6.7 &gt; Kat 3 122 12.2 &gt; Kat 4 150 15.0 &gt; Kat 5 220 22.0 &gt; Kat 6 200 20.0 &gt; Kat 7 145 14.5 &gt; Kat 8 65 6.5 &gt; Kat 9 12 1.2 &gt; Sum 1000 100.0 Du har nu konstruerat en frekvenstabell utifrån bägge tillvägagångsätten. Det är viktigt vid alla dataanlyser är att veta hur funktionerna som används hanterar saknade data. Default-inställningen för table() är att ignorera sådana observationer. För att redovisa saknade data som en egen kategori används argumentet useNA = \"ifany\". 6.2.1 Analys av två variabler med fler än två kategorier Vi ska nu beskriva psyskologisk bedömning uppdelat på födda 1961 respektive 1975. Först en korstabell med frekvenser och baserat på denna skapa en korstabell med relativa frekvenser baserat på kolumnprocent. Notera att det kräver en del pusslande, men vi har stor flexibilitet vad gäller att konstruera tabellen. freqtable_psych_year &lt;- table(df$psych, df$year) freqtable_psych_year 1961 1975 1 10 9 2 29 38 3 64 58 4 78 72 5 112 108 6 91 109 7 55 90 8 27 38 9 6 6 proptable_psych_year &lt;- 100*prop.table(freqtable_psych_year, margin = 2 ) # 2 är kolumnprocent # Bind ihop frekvenser och relative frekvenser table_psych_year_bind &lt;- cbind(freqtable_psych_year[,1], round(proptable_psych_year[,1], 1), freqtable_psych_year[,2], round(proptable_psych_year[,2], 1)) table_psych_year &lt;- addmargins(table_psych_year_bind, 1) colnames(table_psych_year) &lt;- c(&quot;1961&quot;, &quot;%&quot;, &quot;1975&quot;, &quot;%&quot;) rownames(table_psych_year) &lt;- c(&quot;Kat 1&quot;, &quot;Kat 2&quot;, &quot;Kat 3&quot;, &quot;Kat 4&quot;, &quot;Kat 5&quot;, &quot;Kat 6&quot;, &quot;Kat 7&quot;, &quot;Kat 8&quot;, &quot;Kat 9&quot;, &quot;Total&quot;) table_psych_year 1961 % 1975 % Kat 1 10 2.1 9 1.7 Kat 2 29 6.1 38 7.2 Kat 3 64 13.6 58 11.0 Kat 4 78 16.5 72 13.6 Kat 5 112 23.7 108 20.5 Kat 6 91 19.3 109 20.6 Kat 7 55 11.7 90 17.0 Kat 8 27 5.7 38 7.2 Kat 9 6 1.3 6 1.1 Total 472 100.0 528 99.9 6.3 Exportera tabeller till html –&gt; 6.4 Några frekvent förekommande tabeller Vi ska nu presentera några tabeller som ofta förekommer, där du kan använda samma metod som ovan för att konstruera tabellerna. 6.4.1 Tabell för att beskriva urvalet Alla rapporter eller vetenskapliga artiklar bör inkludera en beskrivning av urvalet, dvs variablerna fördelning i stickprovet. Frågan som då besvaras är ‘’Vilka är det vi vi undersöker?’’. Ibland är denna beskrivning placeread i början, ibland i en bilaga. Inom en del vetenskapliga artiklar benämns en sådan tabell Tabell 1 eller Table 1. Observera att eftersom syftet inte är att göra inferens utan enbart att beskriva urval, dvs normallt sett redovisas inte medelfel, konfidensintervall eller \\(p\\)-värden. För att skapa en sådan tabell är det enklast att i R skapa en tabell separat för kvantitativa variabler som redovisas medelvärde, standardavvikelse och evenuellt andra mått och en för kategorivariabler. Därefter kan man kombinera tabellerna i ordbehandlingsprogrammet. # I studien krävs en variabel som indikerar högt blodtryck. --&gt; # För varje blodtrycksvariabel skapas 2 nya varibler till vårt dataset: # 1. en binär 0-1 variabel som är numerisk # 2. en binär variabel som R hanterar som en faktor med namngivna nivåer. # Att ändra namn på faktorers nivåer är lite omständligt, men det är enkelt att använda nedanstående kod. df$sbp_bin &lt;- NA df$sbp_bin[df$sbp &gt;= 130] &lt;- 1 df$sbp_bin[df$sbp &lt; 130] &lt;- 0 df$sbp_cat &lt;- factor(df$sbp_bin) levels(df$sbp_cat)[levels(df$sbp_cat) == &quot;0&quot;] &lt;- &quot;Normalt&quot; levels(df$sbp_cat)[levels(df$sbp_cat) == &quot;1&quot;] &lt;- &quot;Högt&quot; df$dbp_bin &lt;- NA df$dbp_bin[df$dbp &gt;= 80] &lt;- 1 df$dbp_bin[df$dbp &lt; 80] &lt;- 0 df$dbp_cat &lt;- factor(df$dbp_bin) &gt; levels(df$dbp_cat)[levels(df$dbp_cat) == &quot;0&quot;] &lt;- &quot;Normalt&quot; Error in factor(df$dbp_bin) &gt; levels(df$dbp_cat)[levels(df$dbp_cat) == : could not find function &quot;&gt;&lt;-&quot; levels(df$dbp_cat)[levels(df$dbp_cat) == &quot;1&quot;] &lt;- &quot;Högt&quot; Error in levels(df$dbp_cat)[levels(df$dbp_cat) == &quot;1&quot;] &lt;- &quot;Högt&quot;: attempt to set an attribute on NULL # Skapa Tabell 1a. Kvantitativa variabler xbar_height &lt;- mean(df$height) sd_height &lt;- sd(df$height) xbar_weight &lt;- mean(df$weight) sd_weight &lt;- sd(df$weight) xbar_sbp &lt;- mean(df$sbp) sd_sbp&lt;- sd(df$sbp) xbar_dbp &lt;- mean(df$dbp) sd_dbp&lt;- sd(df$dbp) means &lt;- round(c(xbar_height, xbar_weight, xbar_sbp, xbar_dbp ), 1) sds &lt;- round(c(sd_height, sd_weight, sd_sbp, sd_dbp), 2) table1_cont_vars &lt;- cbind(means, sds) colnames(table1_cont_vars) &lt;- c(&quot;Medelvärde&quot;, &quot;SD&quot;) rownames(table1_cont_vars) &lt;- c(&quot;Längd (cm)&quot;, &quot;Vikt (kg)&quot;, &quot;Systoliskt blodtryck (mmHg)&quot;, &quot;Diastoliskt blodtryck (mmHg)&quot;) # Skapa Tabell 1b. Kategorivariabler --&gt; desc_sbp_bin &lt;- cbind(table(df$sbp_bin), 100*prop.table(table(df$sbp_bin))) desc_dbp_bin &lt;- cbind(table(df$dbp_bin), 100*prop.table(table(df$dbp_bin))) desc_psych_cat &lt;- cbind(table(df$psych), 100*prop.table(table(df$psych))) table1_cat_vars &lt;- rbind(desc_sbp_bin, desc_dbp_bin, desc_psych_cat) colnames(table1_cat_vars) &lt;- c(&quot;Antal&quot;, &quot;%&quot;) rownames(table1_cat_vars) &lt;- c(&quot;Systoliskt blodtryck (mmHG &lt; 130)&quot;, &quot;Systoliskt blodtryck (mmHG &gt;= 130)&quot;, &quot;Diastoliskt blodtryck (mmHG &lt; 80)&quot;, &quot;Diastoliskt blodtryck (mmHG &gt;= 80)&quot;, &quot;Psykologisk bedömning: Kat 1&quot;, &quot;Psykologisk bedömning: Kat 2&quot;, &quot;Psykologisk bedömning: Kat 3&quot;, &quot;Psykologisk bedömning: Kat 4&quot;, &quot;Psykologisk bedömning: Kat 5&quot;, &quot;Psykologisk bedömning: Kat 6&quot;, &quot;Psykologisk bedömning: Kat 7&quot;, &quot;Psykologisk bedömning: Kat 8&quot;, &quot;Psykologisk bedömning: Kat 9&quot;) I R ser tabellerna ut som följer. table1_cont_vars Medelvärde SD Längd (cm) 179.3 6.58 Vikt (kg) 70.5 10.68 Systoliskt blodtryck (mmHg) 128.6 10.98 Diastoliskt blodtryck (mmHg) 66.9 9.83 table1_cat_vars Antal % Systoliskt blodtryck (mmHG &lt; 130) 519 51.9 Systoliskt blodtryck (mmHG &gt;= 130) 481 48.1 Diastoliskt blodtryck (mmHG &lt; 80) 900 90.0 Diastoliskt blodtryck (mmHG &gt;= 80) 100 10.0 Psykologisk bedömning: Kat 1 19 1.9 Psykologisk bedömning: Kat 2 67 6.7 Psykologisk bedömning: Kat 3 122 12.2 Psykologisk bedömning: Kat 4 150 15.0 Psykologisk bedömning: Kat 5 220 22.0 Psykologisk bedömning: Kat 6 200 20.0 Psykologisk bedömning: Kat 7 145 14.5 Psykologisk bedömning: Kat 8 65 6.5 Psykologisk bedömning: Kat 9 12 1.2 För exportera använder du som förut paketet xtable. print(xtable(table1_cont_vars, digits = 1), type=&quot;html&quot;, file=&quot;D:/table1_cont_vars.html&quot;) print(xtable(table1_cat_vars, digits = c(0,0,1)), type=&quot;html&quot;, file=&quot;D:/table1_cat_vars.html&quot;) "],
["figurer.html", "Kapitel 7 Figurer 7.1 Typer av figurer 7.2 Lådagram 7.3 Spridningsdiagram 7.4 Några frekvent förekommande diagram.", " Kapitel 7 Figurer R ger tillgång till omfattande möjligheter för datavisualisering. Dels ger basversionen i R stor frihet, dels finns det paket (exempelvis ggplot2 och lattice) som ger ytterligare funktioner, men som också förenklar skapandet av figurer. Det går att klassificera syftet med figurer enligt följande: Figurer primärt avsedda för dataanalytikern, där syftet är att studera data explorativt, kontrollera att förutsättningar är uppfyllda och förmedla preliminära resultat. Estetiska och pedagogiska aspekter hos sådana figurer är sekundär eftersom det Figurer avsedda att presenteras för en publik och ska finnas med i en rapport, vetenskaplig artikel eller ett bildspel. En sådan figur ska på ett tydligt och korrekt redovisa det väsentliga i en analys och den ska även vara estetiskt fullgod. Beroende på syfte tar det olika lång tid att skapa figurer. Det finns komplicerade figurer som kan ta flera timmar att skapa. Wilke delar in figurer i Oestetisk. Figurer är i många avseenden korrekt Dålig Fel insark &lt;- read.csv2(&quot;D:/conscriptiondata.csv&quot;) n &lt;- 10000 set.seed(12345) df &lt;- insark[sample(insark$id, n), ] names(insark) &gt; [1] &quot;id&quot; &quot;year&quot; &quot;height&quot; &quot;weight&quot; &quot;psych&quot; &gt; [6] &quot;muscle&quot; &quot;armstrength&quot; &quot;physical&quot; &quot;gripstrength&quot; &quot;legstrength&quot; &gt; [11] &quot;sbp&quot; &quot;dbp&quot; &quot;officer&quot; &quot;testa&quot; &quot;testb&quot; &gt; [16] &quot;testc&quot; &quot;testd&quot; df$year_cat &lt;- NA df$year_cat[(df$year &gt;= 1961) &amp; (df$year &lt; 1966)] &lt;- 1 df$year_cat[(df$year &gt;= 1966) &amp; (df$year &lt; 1970)] &lt;- 2 df$year_cat[(df$year &gt;= 1971) &amp; (df$year &lt; 1975)] &lt;- 3 df$year_cat &lt;- factor(df$year_cat) levels(df$year_cat) &lt;- c(&quot;1961-1965&quot;, &quot;1966-1970&quot;, &quot;1970-1975&quot;) df$testa_cat[df$testa &lt; 10] &lt;- 1 df$testa_cat[(df$testa &gt;= 10) &amp; (df$testa &lt; 20)] &lt;- 2 df$testa_cat[(df$testa &gt;= 20) &amp; (df$testa &lt; 30)] &lt;- 3 df$testa_cat[(df$testa &gt;= 30)] &lt;- 4 df$testa_cat &lt;- factor(df$testa_cat) df$testa_cat &lt;- NA df$testa_cat[df$testa &lt; 10] &lt;- 1 df$testa_cat[(df$testa &gt;= 10) &amp; (df$testa &lt; 20)] &lt;- 2 df$testa_cat[(df$testa &gt;= 20) &amp; (df$testa &lt; 30)] &lt;- 3 df$testa_cat[(df$testa &gt;= 30)] &lt;- 4 df$testa_cat &lt;- factor(df$testa_cat) df$testb_cat &lt;- NA df$testb_cat[df$testb &lt; 10] &lt;- 1 df$testb_cat[(df$testb &gt;= 10) &amp; (df$testb &lt; 20)] &lt;- 2 df$testb_cat[(df$testb &gt;= 20) &amp; (df$testb &lt; 30)] &lt;- 3 df$testb_cat[(df$testb &gt;= 30)] &lt;- 4 df$testb_cat &lt;- factor(df$testb_cat) df$testc_cat &lt;- NA df$testc_cat[df$testc &lt; 10] &lt;- 1 df$testc_cat[(df$testc &gt;= 10) &amp; (df$testc &lt; 20)] &lt;- 2 df$testc_cat[(df$testc &gt;= 20) &amp; (df$testc &lt; 30)] &lt;- 3 df$testc_cat[(df$testc &gt;= 30)] &lt;- 4 df$testc_cat &lt;- factor(df$testc_cat) df$testd_cat &lt;- NA df$testd_cat[df$testd &lt; 10] &lt;- 1 df$testd_cat[(df$testd &gt;= 10) &amp; (df$testd &lt; 20)] &lt;- 2 df$testd_cat[(df$testd &gt;= 20) &amp; (df$testd &lt; 30)] &lt;- 3 df$testd_cat[(df$testd &gt;= 30)] &lt;- 4 df$testd_cat &lt;- factor(df$testd_cat) par(mfrow=c(2,2)) freqtable_testa &lt;- table(df$testa_cat) barplot(freqtable_testa, col=&quot;lightblue&quot;, main=&quot;OK&quot;, ylab=&quot;Antal&quot;, xlab = &quot;Poäng test A&quot;, ylim=c(0,5000), border=&quot;white&quot;, names.arg = c(&quot;0-9&quot;, &quot;10-19&quot;, &quot;20-29&quot;, &quot;30-40&quot;)) grid(nx=NA, ny=NULL) barplot(freqtable_testa, col=&quot;lightblue&quot;, main=&quot;OK&quot;, ylab=&quot;Antal&quot;, xlab = &quot;Poäng test A&quot;, ylim=c(0,5000), border=&quot;white&quot;, names.arg = c(&quot;0-9&quot;, &quot;10-19&quot;, &quot;20-29&quot;, &quot;30-40&quot;), add=TRUE) barplot(freqtable_testa, main=&quot;Oestetisk&quot;, col=c(4,7,5,2), xlab = &quot;Poäng test A&quot;, ylab=&quot;Antal&quot;, ylim=c(0,5000), border=&quot;white&quot;, names.arg = c(&quot;0-9&quot;, &quot;10-19&quot;, &quot;20-29&quot;, &quot;30-40&quot;)) grid(nx=NA, ny=NULL) barplot(freqtable_testa, main=&quot;Dålig&quot;, col=&quot;lightblue&quot;, ylab=&quot;Antal&quot;, xlab = &quot;Poäng test A&quot;, ylim=c(0,20000), border=&quot;white&quot;, ) barplot(freqtable_testa, main=&quot;Felaktig&quot;, col=&quot;lightblue&quot;, ylab=&quot;&quot;, xlab = &quot;Test&quot;, ylim=c(0,10000), border=&quot;white&quot;, xaxt=&#39;n&#39;, yaxt=&#39;n&#39;) insark &lt;- read.csv2(&quot;D:/conscriptiondata.csv&quot;) n &lt;- 10000 set.seed(12345) df &lt;- insark[sample(insark$id, n), ] names(insark) &gt; [1] &quot;id&quot; &quot;year&quot; &quot;height&quot; &quot;weight&quot; &quot;psych&quot; &gt; [6] &quot;muscle&quot; &quot;armstrength&quot; &quot;physical&quot; &quot;gripstrength&quot; &quot;legstrength&quot; &gt; [11] &quot;sbp&quot; &quot;dbp&quot; &quot;officer&quot; &quot;testa&quot; &quot;testb&quot; &gt; [16] &quot;testc&quot; &quot;testd&quot; df$year_cat &lt;- NA df$year_cat[(df$year &gt;= 1961) &amp; (df$year &lt; 1966)] &lt;- 1 df$year_cat[(df$year &gt;= 1966) &amp; (df$year &lt; 1970)] &lt;- 2 df$year_cat[(df$year &gt;= 1971) &amp; (df$year &lt; 1975)] &lt;- 3 df$year_cat &lt;- factor(df$year_cat) levels(df$year_cat) &lt;- c(&quot;1961-1965&quot;, &quot;1966-1970&quot;, &quot;1970-1975&quot;) df$testa_cat[df$testa &lt; 10] &lt;- 1 df$testa_cat[(df$testa &gt;= 10) &amp; (df$testa &lt; 20)] &lt;- 2 df$testa_cat[(df$testa &gt;= 20) &amp; (df$testa &lt; 30)] &lt;- 3 df$testa_cat[(df$testa &gt;= 30)] &lt;- 4 df$testa_cat &lt;- factor(df$testa_cat) df$testa_cat &lt;- NA df$testa_cat[df$testa &lt; 10] &lt;- 1 df$testa_cat[(df$testa &gt;= 10) &amp; (df$testa &lt; 20)] &lt;- 2 df$testa_cat[(df$testa &gt;= 20) &amp; (df$testa &lt; 30)] &lt;- 3 df$testa_cat[(df$testa &gt;= 30)] &lt;- 4 df$testa_cat &lt;- factor(df$testa_cat) df$testb_cat &lt;- NA df$testb_cat[df$testb &lt; 10] &lt;- 1 df$testb_cat[(df$testb &gt;= 10) &amp; (df$testb &lt; 20)] &lt;- 2 df$testb_cat[(df$testb &gt;= 20) &amp; (df$testb &lt; 30)] &lt;- 3 df$testb_cat[(df$testb &gt;= 30)] &lt;- 4 df$testb_cat &lt;- factor(df$testb_cat) df$testc_cat &lt;- NA df$testc_cat[df$testc &lt; 10] &lt;- 1 df$testc_cat[(df$testc &gt;= 10) &amp; (df$testc &lt; 20)] &lt;- 2 df$testc_cat[(df$testc &gt;= 20) &amp; (df$testc &lt; 30)] &lt;- 3 df$testc_cat[(df$testc &gt;= 30)] &lt;- 4 df$testc_cat &lt;- factor(df$testc_cat) df$testd_cat &lt;- NA df$testd_cat[df$testd &lt; 10] &lt;- 1 df$testd_cat[(df$testd &gt;= 10) &amp; (df$testd &lt; 20)] &lt;- 2 df$testd_cat[(df$testd &gt;= 20) &amp; (df$testd &lt; 30)] &lt;- 3 df$testd_cat[(df$testd &gt;= 30)] &lt;- 4 df$testd_cat &lt;- factor(df$testd_cat) par(mfrow=c(2,2)) freqtable_testa &lt;- table(df$testa_cat) barplot(freqtable_testa, col=&quot;lightblue&quot;, main=&quot;OK&quot;, ylab=&quot;Antal&quot;, xlab = &quot;Poäng test A&quot;, ylim=c(0,5000), border=&quot;white&quot;, names.arg = c(&quot;0-9&quot;, &quot;10-19&quot;, &quot;20-29&quot;, &quot;30-40&quot;)) grid(nx=NA, ny=NULL) barplot(freqtable_testa, col=&quot;lightblue&quot;, main=&quot;OK&quot;, ylab=&quot;Antal&quot;, xlab = &quot;Poäng test A&quot;, ylim=c(0,5000), border=&quot;white&quot;, names.arg = c(&quot;0-9&quot;, &quot;10-19&quot;, &quot;20-29&quot;, &quot;30-40&quot;), add=TRUE) barplot(freqtable_testa, main=&quot;Oestetisk&quot;, col=c(4,7,5,2), xlab = &quot;Poäng test A&quot;, ylab=&quot;Antal&quot;, ylim=c(0,5000), border=&quot;white&quot;, names.arg = c(&quot;0-9&quot;, &quot;10-19&quot;, &quot;20-29&quot;, &quot;30-40&quot;)) grid(nx=NA, ny=NULL) barplot(freqtable_testa, main=&quot;Dålig&quot;, col=&quot;lightblue&quot;, ylab=&quot;Antal&quot;, xlab = &quot;Poäng test A&quot;, ylim=c(0,20000), border=&quot;white&quot;, ) barplot(freqtable_testa, main=&quot;Felaktig&quot;, col=&quot;lightblue&quot;, ylab=&quot;&quot;, xlab = &quot;Test&quot;, ylim=c(0,10000), border=&quot;white&quot;, xaxt=&#39;n&#39;, yaxt=&#39;n&#39;) Den första figuren är OK eftersom den redovisar stapeldiagramen utan felaktigheter. Den andra figuren har oestetisk beträffande färgval och har hjälplinjer som löper över staplarna istället för bakom. Figuren som klassas som dålig är korrekt, men det är svårt att urskilja detaljer i den. Den felaktiga figuren visar staplarna men ingen övrigr information som gör figuren möjlig att tolka. Notera att distinktionen oestetisk-dålig-felaktig är flytande. Färgvalet kan innebär att faktiskt är dålig eftersom . Att ha olika färger på staplar innebär att tolkningen av innebär att läsaren kan föranledas att tro att det ytterligare information som inte finns. En korrekt figur som är dålig, kanske är så dålig att den misstolkasm vilket innebär att den egentligen är felaktig. 7.1 Typer av figurer 7.1.1 Presentation av aggregerade data Aggregerade data (summor, antal, medelvärden, andelar) presenteras ofta i stapeldiagram, där R använder funktionen barplot(). punktdiagram, där R använder funktionen dotchart(). I princip redovisas grafiskt värden presenteras i en tabell, men en grafisk presentation blir enklare att avläsa. På grund av relationen mellan stapeldiagram och tabeller används i R ett skapat tabellobjekt i stapeldiagramsfunktionen barplot för att skapa stapeldiagram. Det finns olika typer av stapeldiagram. library(&quot;WDI&quot;) wdi_dat &lt;- WDI(indicator = c(&quot;SP.POP.TOTL&quot;, &quot;NY.GDP.PCAP.KD&quot;, &quot;SP.DYN.IMRT.IN&quot;), start = 2018, end = 2018, extra = TRUE) wdieu &lt;- subset(wdi_dat, country %in% c(&quot;Denmark&quot;, &quot;Finland&quot;, &quot;Iceland&quot;, &quot;Norway&quot;, &quot;Sweden&quot;)) dotchart(wdieu$SP.POP.TOTL, labels = wdieu$country, cex=1.1) dotchart(sort(wdieu$SP.POP.TOTL/1000000), labels = wdieu$country[order(wdieu$SP.POP.TOTL)], xlab = &quot;Population (million)&quot;) help(t.test) freqtable_psych &lt;- table(df$psych) kable(freqtable_psych, format =&quot;html&quot;) Error in kable(freqtable_psych, format = &quot;html&quot;): could not find function &quot;kable&quot; barplot(freqtable_psych, colnames = c(&quot;Kategori&quot;, &quot;Antal&quot;)) Warning in plot.window(xlim, ylim, log = log, ...): &quot;colnames&quot; is not a graphical parameter Warning in axis(if (horiz) 2 else 1, at = at.l, labels = names.arg, lty = axis.lty, : &quot;colnames&quot; is not a graphical parameter Warning in title(main = main, sub = sub, xlab = xlab, ylab = ylab, ...): &quot;colnames&quot; is not a graphical parameter Warning in axis(if (horiz) 1 else 2, cex.axis = cex.axis, ...): &quot;colnames&quot; is not a graphical parameter barplot(freqtable_psych, horiz = TRUE) dotchart(freqtable_psych) Warning in dotchart(freqtable_psych): &#39;x&#39; is neither a vector nor a matrix: using as.numeric(x) library(&quot;WDI&quot;) wdi_dat &lt;- WDI(indicator = c(&quot;SP.POP.TOTL&quot;, &quot;NY.GDP.PCAP.KD&quot;, &quot;SP.DYN.IMRT.IN&quot;), start = 2018, end = 2018, extra = TRUE) wdieu &lt;- subset(wdi_dat, country %in% c(&quot;Belgium&quot;, &quot;Bulgaria&quot;, &quot;Czech Republic&quot;, &quot;Denmark&quot;, &quot;Germany&quot;, &quot;Estonia&quot;, &quot;Ireland&quot;, &quot;Greece&quot;, &quot;Spain&quot;, &quot;France&quot;, &quot;Croatia&quot;, &quot;Italy&quot;, &quot;Cyprus&quot;, &quot;Latvia&quot;, &quot;Lithuania&quot;, &quot;Luxembourg&quot;, &quot;Hungary&quot;, &quot;Malta&quot;, &quot;Netherlands&quot;, &quot;Austria&quot;, &quot;Poland&quot;, &quot;Portugal&quot;, &quot;Romania&quot;, &quot;Slovenia&quot;, &quot;Slovakia&quot;, &quot;Finland&quot;, &quot;Sweden&quot;, &quot;United Kingdom&quot;)) dotchart(wdieu$SP.POP.TOTL, labels = wdieu$country, cex=1.1) dotchart(sort(wdieu$SP.POP.TOTL/1000000), labels = wdieu$country[order(wdieu$SP.POP.TOTL)], xlab = &quot;Population (million)&quot;) Det finns lite riktlinjer proptable_psych &lt;- prop.table(freqtable_psych) freqtable_psych_year &lt;- table(factor(df$testa_cat), df$year_cat) barplot(freqtable_psych_year, beside=TRUE, ylab=&quot;Antal&quot;) proptable_psych_year &lt;- 100*prop.table(freqtable_psych_year, margin = 2 ) barplot(proptable_psych_year, beside=TRUE, ylab=&quot;Procent (%)&quot;) Some key rules for table layout are the following: Do not use vertical lines. Do not use horizontal lines between data rows. (Horizontal lines as separator between the title row and the first data row or as frame for the entire table are fine.) Text columns should be left aligned. Number columns should be right aligned and should use the same number of decimal digits throughout. Columns containing single characters are centered. The header fields are aligned with their data, i.e., the heading for a text column will be left aligned and the heading for a number column will be right aligned. 7.2 Lådagram Lådagram används främst när vi ska jämföra fördelningar uppdelat på kategorier. Att använda lådagram för en enda variabel är inte optimalt, utan histogram ger då mer information. Vi vill studera testresultat uppdelat på psykologisk bedämning boxplot(df$gripstrength~df$psych, xlab=&quot;Psykologisk bedömning (1-9)&quot;, ylab=&quot;Greppstyrka (Newton)&quot;) ## Histogram Histogram används för att visualisera en kontinuerlig variabel. Funktionen hist() skapar ett histogram. Nackdelen med histogram är att den är känslig för antalet klasser. Testa därför olika antal klasser. par(mfrow = c(2,2)) hist(df$gripstrength, xlab=&quot;Greppstyrka (Newton)&quot;, ylab=&quot;Antal&quot;, breaks=7, main=&quot;7 klasser&quot;) hist(df$gripstrength, xlab=&quot;Greppstyrka (Newton)&quot;, ylab=&quot;Antal&quot;, breaks=14, main=&quot;14 klasser&quot;) hist(df$gripstrength, xlab=&quot;Greppstyrka (Newton)&quot;, ylab=&quot;Antal&quot;, breaks=28, main=&quot;28 klasser&quot;) hist(df$gripstrength, xlab=&quot;Greppstyrka (Newton)&quot;, ylab=&quot;Antal&quot;, breaks=56, main=&quot;56 klasser&quot;) 7.3 Spridningsdiagram Den vanligaste funktionen i R för att skapa figurer är plot. Det finns många argument och i de närmaste obegränsade möjligher att anpassa figurerna plot(df$legstrength, df$armstrength, xlab = &quot;Benstyrka (Newton)&quot;, ylab = &quot;Armstyrka (Newton)&quot;) 7.4 Några frekvent förekommande diagram. I surveydata stöter vi ofta på uppdelade stapeldiagram. Dessa figurer har en inneboende problem eftersom kategorierna storlek kan vara svåra att relatera till varandra. Samtidigt är de en visualisering som gör det enkelt att jämföra fördelningar för många variabler av typen attitydfrågor. För att illustrera kategoriserar vi testresultat på begåvningstesterna i INSARK enligt nedanstående schema. df$testa_cat &lt;- NA df$testa_cat[df$testa &lt; 10] &lt;- 1 df$testa_cat[(df$testa &gt;= 10) &amp; (df$testa &lt; 20)] &lt;- 2 df$testa_cat[(df$testa &gt;= 20) &amp; (df$testa &lt; 30)] &lt;- 3 df$testa_cat[(df$testa &gt;= 30)] &lt;- 4 df$testa_cat &lt;- factor(df$testa_cat) df$testb_cat &lt;- NA df$testb_cat[df$testb &lt; 10] &lt;- 1 df$testb_cat[(df$testb &gt;= 10) &amp; (df$testb &lt; 20)] &lt;- 2 df$testb_cat[(df$testb &gt;= 20) &amp; (df$testb &lt; 30)] &lt;- 3 df$testb_cat[(df$testb &gt;= 30)] &lt;- 4 df$testb_cat &lt;- factor(df$testb_cat) df$testc_cat &lt;- NA df$testc_cat[df$testc &lt; 10] &lt;- 1 df$testc_cat[(df$testc &gt;= 10) &amp; (df$testc &lt; 20)] &lt;- 2 df$testc_cat[(df$testc &gt;= 20) &amp; (df$testc &lt; 30)] &lt;- 3 df$testc_cat[(df$testc &gt;= 30)] &lt;- 4 df$testc_cat &lt;- factor(df$testc_cat) df$testd_cat &lt;- NA df$testd_cat[df$testd &lt; 10] &lt;- 1 df$testd_cat[(df$testd &gt;= 10) &amp; (df$testd &lt; 20)] &lt;- 2 df$testd_cat[(df$testd &gt;= 20) &amp; (df$testd &lt; 30)] &lt;- 3 df$testd_cat[(df$testd &gt;= 30)] &lt;- 4 df$testd_cat &lt;- factor(df$testd_cat) Likert_table &lt;- 100*cbind( prop.table( table( df$testd_cat) ), prop.table( table( df$testc_cat) ), prop.table( table( df$testb_cat) ), prop.table( table( df$testa_cat) ) ) colnames(Likert_table) &lt;- c(&quot;Testa D&quot;, &quot;Test C&quot;, &quot;Test B&quot;, &quot;Test A&quot;) bar1 &lt;- barplot(Likert_table, horiz = TRUE, col = c(&quot;brown3&quot;, &quot;brown1&quot;, &quot;cadetblue1&quot;, &quot;cadetblue4&quot;), xlab=&quot;Procent (%)&quot;, las=1) abline(v=50) legend(&quot;top&quot;, fill = c(&quot;brown3&quot;, &quot;brown1&quot;, &quot;cadetblue1&quot;, &quot;cadetblue4&quot;), legend = c(&quot;Kategori 1&quot;, &quot;Kategori 2&quot;, &quot;Kategori 3&quot;, &quot;Kategori 4&quot;), horiz = TRUE, inset = c(0,-0.1), xpd = TRUE, bty=&quot;n&quot;) barplot(Likert_table, horiz = FALSE, beside=TRUE, col = c(&quot;brown3&quot;, &quot;brown1&quot;, &quot;cadetblue1&quot;, &quot;cadetblue4&quot;), xlab=&quot;Procent (%)&quot;, las=1) legend(&quot;top&quot;, fill = c(&quot;brown3&quot;, &quot;brown1&quot;, &quot;cadetblue1&quot;, &quot;cadetblue4&quot;), legend = c(&quot;Kategori 1&quot;, &quot;Kategori 2&quot;, &quot;Kategori 3&quot;, &quot;Kategori 4&quot;), horiz = TRUE, inset = c(0,-0.1), xpd = TRUE, bty=&quot;n&quot;) Ett alternativ är att använda paketet likert. Notera att som input hanterar den bara faktorer! Dessutom inkluderas inte variabler i form av en matris. Funktionen har mycket install.packages(\"likert\") library(&quot;likert&quot;) &gt; Loading required package: ggplot2 &gt; &gt; Attaching package: &#39;ggplot2&#39; &gt; The following objects are masked from &#39;package:psych&#39;: &gt; &gt; %+%, alpha &gt; Loading required package: xtable likertdata &lt;- likert(data.frame(df$testa_cat, df$testb_cat, df$testc_cat, df$testd_cat)) plot(likertdata) ?likert "]
]
