# Data, objekt och funktioner

För att kunna arbeta med statistik och dataanalys är det viktigt att inte enbart förstå den statistiska metoden och kunna lösa problem med hjälp av en miniräknare. I praktiken är det även nödvändigt att förstå hur data hanteras, lagras och struktureras. I detta kapitel introduceras typer av data som normalt hanteras i R, sedan följer avsnitt om de olika typer av objekt som finns i R. Kapitlet avslutas med se på vad en funktion i R är för något och hur funkioner kan användas för att hantera objekt. Detta är ett omfattande kapitel, men det är viktigt att du kan hantera *allt* som presenteras. Avsikten med kaptitlet är nämligen att ta upp de allra vanligaste. 

## Data och objekt
Utan data är statistik innehållslöst. På samma sätt är data grundläggande för arbete i R. De vanligaste datatyperna i R är

+ character (text), som anges med citationstecken t ex "a", "3".
+ numeric (decimaltal), t ex är 3, 32.1. Notera att 3 kan skriva 3.0.
+ integer (heltal). 3, 32. Skillnaden mellan numeric och integer är att inga decimaler sparas, vilket spar minne. 
+ logical (data indikerar om något är sant eller falskt, TRUE/FALSE).

Observera att dessa datatyper beskriver hur data är lagrad och hur R ska tolka data. Det säger sig kanske självt att det inte går att använda räkneoperation om data är character (text). 

Datatyper ska inte förväxlas med de datanivåer (nominal, ordinal, intervall och kvotskala) som man normalt förknippar med statistiska analyser. Datatyper ska inte heller förväxlas med om data är diskreta, kontinuerliga, kategorier eller kvantitativa. 

Det är **mycket viktigt** för alla som arbetar med statistiska analyser av data att kunna tillämpa alla ovanstående begrepp på rätt situation. Ofta överlappar begreppen, men det är vanligt att begreppen inte gör det. Tabellen nedan ger en översikt av begreppen som används, men notera att det finns undantag från denna klassificering och det finns andra sätt att klassificera. 

| Mätskala  | Variabeltyp                                 |  Datatyp i R                          |
|-----------|---------------------------------------------|---------------------------------------|
| Nominal   | Kategori, kvalitativ                        | Character, factor med ordered = FALSE |
| Ordinal   | Kategori, kvalitativ                        | Character, factor med ordered = TRUE  |
| Intervall | Kvantitativ, kontinuerlig, heltal, diskret  | Numeric, integer                      |
| Kvot      | Kvantitativ, kontinuerlig, heltal, diskret  | Numeric, integer                      |


Data hanteras och sparas som **objekt**. För att skapa ett objekt används **assignment**-operatorn **<-**. Objektet sparas därmed i minnet i R, men inget resultat redovisas i Console. Om R stängs ner måste objektet skapas på nytt såvida användaren inte har angett att objektet ska sparas.

I regel arbetar man i R med flera olika objekt samtidigt. Objekten måste därför 
namnges och precis som Vid all programmering är noggrannhet a och o. Objektnamn inleds med en bokstav och får endast innehålla bokstäver, siffror, _ och ..
Dessutom skiljer R på versaler och gemener. Det är inte alltid enkelt att namnge objekt, men det
viktigaste är att vara konsekvent. På denna kurs rekommenderas följande principer för namngivning av objekt. Använd 

+ endast **gemener**.
+ **korta** och **logiska** namn, t ex kan objektet **population** förkortas till **pop**.
+ gärna understreck _ för sammanbinda långa objektnamn. Objektet ålder för kvinnor skulle kunna betecknas **age_women** och motsvarande för män är då **age_men**.
+ Använd inte å, ä och ö.
+ inte namn som redan är upptagna i R, t ex **exp** eller **log**.

Det tre vanligaste objekten för hantering av data är:

+ vektorer,
+ matriser,
+ data frames. 


## Vektorer 
En vektor är ett dataobjekt som är endimensionellt och består av $n$ element. En vektor skapas med kommandot **c()** (''Combine Values into a Vector''). Anta att vi observerar värdena $3,-1,1,5,0$. Med hjälp av nedanstående kod skapas ett vektor-objekt med med 5 element:

```{r, eval=TRUE}
# Skapa din första numeriska vektor
my__first_vec <- c(3, -1, 1, 5, 0)

```

Notera att inget visas i Console, men att objektet finns sparat i minnet upptäcker man i RStudio genom att observera den övre högra panelen under fliken **Environment**. Där listas alla objekt som finns sparade i minnet i R. För att titta på objektet exekveras objektet genom att köra nedanstående kod. 

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Visa din första numeriska vektor
my__first_vec 

```


Du ska nu skapa ett antal vektorobjekt som sedan på olika sätt ska manipuleras. 

1. Skapa ett script som heter **kap3_objekt_och_funktioner.R** genom att välja *File > New File > R Script* och sedan direkt spara scriptet med *File > Save As* i mappen **A5Rkod**.  
2. Skriv in koden nedan i scriptet och spara med *File > Save*. Det är bra att få rutin på att ofta spara sitt script så att inte kod råkar försvinna.

```{r, eval=TRUE}
# Skapar två numeriska vektorer
x <- c(3, 1, 1, 5, 0)
y <- c(2, 3, 5, 6, 9)
# Kombinera vektorer till en ny vektor
z <- c(x, y)
```

Generellt gäller i R att om $x$ är en vektor bestående av $k$ element
$$x = (x_1,x_2,\ldots,x_k)$$
och $y$ är en vektor bestående av $l$ element
$$y = (y_1,y_2,y_3,y_4,y_5)$$
så skapar kommandot 

```{r, eval=FALSE} 
z <- c(x,y)
``` 

en vektor med $k + l$ element, 
$$z= (x_1,x_2,\ldots,x_k,y_1,y_2,\ldots,y_l)=(z_1,z_2,\ldots,z_{k+l}).$$
För att se om detta stämmer tittar vi på objekten genom att exekvera dem. 

3. Fortsätt scriptet genom att skriva in nedanstående kod. Spara och kör koden.

```{r, eval = FALSE}
x
y
z
```

I Console ser du då följande: 

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
x
y
z
```

Både $x$, $y$ och $z$ är numeriska vektorer. Det går även att skapa en vektor bestående av bokstäver. För att skapa en sådan vektor (character vector) sätts de enskilda elementen inom citationstecken.

4. Fortsätt scriptet och skriv in nedanstående kod i scriptet, spara och kör koden.

```{r, eval=FALSE}
# Skapar en vektor med ord
nordic_countries <- c("Denmark", "Finland", "Iceland", "Norway", "Sweden")
nordic_countries
```

I Console ser du då följande resultat.

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Skapar en vektor med ord
nordic_countries <- c("Denmark", "Finland", "Iceland", "Norway", "Sweden")
nordic_countries
```

Kombineras en numerisk och en character-vektor blir hela vektorn en character-vector.  

5. Skriv följande kod i scriptet, spara och kör koden.


```{r, eval=FALSE}
# Kombinera en numerisk vektor med en vektor med ord
x_nordic_countries <- c(x, nordic_countries )
x_nordic_countries
```

I Console erhålls följande output och vi ser att de tidigare numeriska värdena nu omges av citationstecken.

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Kombinera en numerisk vektor med en vektor med ord
x_nordic_countries <- c(x, nordic_countries )
x_nordic_countries
```

Om en numerisk vektor kombineras med en vektor med bokstäver så blir hela vektorn en character-vektor. R tolkas alltså siffrorna som bokstäver/tecken utan relation till numeriska värden. Det ser vi genom att 
det finns finns citationstecken kring siffrorna. 


Vi ska nu se introducera hur man på andra sätt kan skapa vektorer typer av vektorer.

6. Skriv in nedanstående kod i scriptet och spara. Kör koden.

```{r, eval=FALSE}
# Skapar en vektor med värdena 1,2,3,4,5
v <- 1:5
# Skapar en vektor med endast ett element
u <- 150
# Skapar en vektor med ett bortfall. 
ymis <- c(3, NA, 6, 3, 6)
```

I Console visas

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Skapar en vektor med värdena 1,2,3,4,5
v <- 1:5
# Skapar en vektor med endast ett element
u <- 150
# Skapar en vektor med ett bortfall. 
ymis <- c(3, NA, 6, 3, 6)
```


För att sammanfatta så har vi har hittills skapat numeriska vektorer, vektorer som enbart innehåller bokstäver och vektorer som skapats genom  sekvenser. Vidare finns vektorer med bortfall anges med `NA` (Not Available).


<style>
div.green{ background-color:#abd4b3; border-radius: 5px; padding: 20px;}
</style>
<div class = "green">

 <font size="5">  </font>
```{r, echo = FALSE, out.width = "5%", dpi = 72}
knitr::include_graphics("docs/images/important.png")
```

+ En vektor som innehåller enbart en datatyp kallas för **atomic**. Detta kan vara värt att känna till eftersom eftersom det är vanligt att felmeddelande referar till just att en vektor inte är atomic.  
+ Inled en rad med # för att kommentera kod. *Kommentera alltid kod!*. Vid all programmering är det viktigt att förklara kod så att du själv och andra snabbt förstår vad koden gör.  Det är viktigt att få rutin på att kommentera, kommentera därför även enkel kod.
</div>

Nya vektorer kan skapas med räkneoperationer. Beräkningarna sker då **elementvis**, till exempel adderas elementvärden i en vektor till elementvärden i en annan vektor som har motsvarade position. Vektorerna måste

+ antingen **ha lika många element** eller
+ att den enda vektorna består av **en** konstant.

7. Skriv in nedanstående i ditt script, spara och kör.

```{r, eval=FALSE}
# Addition av x och y
x + y
# Multiplikation av x och y
x * y
# Potenser skrivs med a^b
y^2
# En konstant u adderas till alla element i vektorn
x + u 
# Räkneoperationer med NA ger NA
x + ymis 
# Division med 0 är ej definierat. R anger det som Inf (infinity) 
# eller NaN (Not a Number) om det är 0/0.
x/0
# Exempel på längre räkneoperationer. 
# Notera att alla beräkningar är elementvisa.
w <- x + (y^2 - u)/v
w

```

I Console visas 

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Addition av x och y
x + y
# Multiplikation av x och y
x * y
# Potenser skrivs med a^b
y^2
# En konstant u adderas till alla element i vektorn
x + u 
# Räkneoperationer med NA ger NA
x + ymis 
# Division med 0 är ej definierat. R anger det som Inf (infinity) 
# eller NaN (Not a Number) om det är 0/0.
x/0
# Exempel på längre räkneoperationer. 
# Notera att alla beräkningar är elementvisa.
w <- x + (y^2 - u)/v
w
```

Ovanstående illustrerar att genom att användning av objekt kan  beräkningar förenklas.

Nu ska vi se vad som händer om elemementen består av olika antal element. **Skriv i Console** in nedanstående kod och tryck enter.

```{r, eval = FALSE}
x + c(2,5,6)
```

I Console visas

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
x + c(2,5,6)
```


Detta innebär att om vektorn $x$ (innehållande 5 element) adderas till en vektor bestående av endast 3 element, dvs antalet element skiljer sig åt, erhålls ett felmeddelande. Det gäller oavsett räknesätt. Om däremot den ena vektorn är en konstant, som i exemplet med vektorn $u$ ovan, fungerar beräkningarna genom att konstanten beräknas för alla element i den större vektorn.

### Vektorer och indexering

Vi ska nu presentera hur enskilda element kan väljas ut i vektorer. Eftersom data i praktiken alltid måste anpassas för planerade analyser är detta nödvändigt. Det mest grundläggande i hantering av vektorer  är att konstatera att varje element i en vektor har en position. Med hakparenteser `[]` erhålls åtkomst till ett eller flera element.

1. Skriv in nedanstående i ditt script, spara och kör.


```{r, eval=FALSE}
# Visa element nummer 2 i vektorn x 
x[2]
# Visa element 2, 3 och 4 i vektorn y
y[c(2,3,4)]
```

I Console redovisas 

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Visa element nummer 2 i vektorn x 
x[2]
# Visa element 2, 3 och 4 i vektorn y
y[c(2,3,4)]
```

Det går även att spara utvalda element till en ny vektor. 

2. Skriv in nedanstående i ditt script.

```{r, eval=FALSE}
# Spara element nummer 2 i vektorn x2 
x2 <- x[2]
x2
# Visa element 2, 3 och 4 i vektorn y234
y234 <- y[c(2,3,4)]
y234
```

I Console redovisas 

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Spara element nummer 2 till vektorn x2 
x2 <- x[2]
x2
# Spara element 2, 3 och 4 till vektorn y234
y234 <- y[c(2,3,4)]
y234
```

Det går att tillämpa **negativ indexering** för att **exkludera** angivna element. Resterande element i en vektor behålls då.

3. Skriv in nedanstående i scriptet, spara, och kör.

```{r, eval=FALSE}
# Spara element nummer 1,3,4,5 till vektorn x1345 
x1345 <- x[-2]
x1345
# Spara element 1 och 5 till vektorn y15
y15 <- y[-c(2,3,4)]
y15
```

I Console redovisas nedanstående.

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Spara element nummer 1,3,4,5 till vektorn x1345 
x1345 <- x[-2]
x1345
# Spara element 1 och 5 till vektorn y15
y15 <- y[-c(2,3,4)]
y15
```

En viktigt skäl till att identifiera element är att användaren då på ett enkelt sätt kan hantera värden som identifierade element har.

4. Skriv i nedanstående i scriptet, spara och kör.

```{r, eval=FALSE}
# Ändra element 3 från 1 till 4
x_new <- x
x_new[3] <- 4
x_new 
# Ändra element 3 från "Iceland" till 4
nordic_countries_new <- nordic_countries
nordic_countries_new[3] <- 4
nordic_countries_new 
```

I Console redovisas nedanstående.

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Ändra element 3 från 1 till 4
x_new <- x
x_new[3] <- 4
x_new 
# Ändra element 3 från "Iceland" till 4
nordic_countries_new <- nordic_countries
nordic_countries_new[3] <- 4
nordic_countries_new 
```


Ovanstående kod illustrerar två vanliga företeelser: 

+ Vektorerna *x_new* och *nordic_countries_new* skapas på grund av att användaren ofta önskar behålla originalvektorerna *x* och  *nordic_countries*. Detta är ofta önskvärt.
+ Om ett numeriskt värde läggs till en vektor med bokstäver så tolkas det numeriska värdet som ett tecken, dvs *"4"*. Det illustrerar vikten av vara noga med om vektorerna är *numeriska* eller *character*


### Vektorer och logiska operatorer
Istället för att  direkt identifiera positionen i vektorn kan man använda **logiska operatorer**. Några vanliga och viktiga logiska operatorer är:

+ `<` är mindre än.
+ `>` är mindre än.
+ `>=` större än eller lika med	
+ `<=` mindre än eller lika med	
+ `==` lika med.
+ `!=` är ej lika med
+ `x|y` $x$ eller $y$
+ `x & y` $x$ och $y$

Genom att använda dessa kan användaren direkt hantera  data i vektorn. 

1. Fortsätt scriptet genom att skriva in nedanstående kod. Spara och kör koden.

```{r, eval=FALSE}
# Visa element i vektor y som är större än 6
y[y > 6]
# Visa element i vektor y som är större än eller lika med 6
y[y >= 6]
# Visa element i vektor y från positioner där x har värden lika med 1. 
# (Kräver att x och y har lika många element) 
y[x == 1]
# Visa element i vektor där x är ej lika med 1.
y[x != 1]
# Visa element i vektor y från positioner där nordic_countries == "Finland"
y[nordic_countries == "Finland"]

```

I Console visas 

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Visa element i vektor y som är större än 6
y[y > 6]
# Visa element i vektor y som är större än eller lika med 6
y[y >= 6]
# Visa element i vektor y från positioner där x har värden lika med 1. 
# (Kräver att x och y har lika många element) 
y[x == 1]
# Visa element i vektor där x är ej lika med 1.
y[x != 1]
# Visa element i vektor y från positioner där nordic_countries == "Finland"
y[nordic_countries == "Finland"]

```

Precis som förut skapas i regel nya vektorer när logiska operatorer tillämpas.

2. Skriv in nedanstående i scriptet, spara och kör koden.

```{r, eval=FALSE}
# Välj vektorn som är större än eller lika med 6
ysub <- y[y >= 6] 

# Skapa en binär vektor x_bin som är 1 om x är större än eller lika med 3 och 0
# om x är mindre än 3. Börja med att skapa en tom vektor med motsvarande antal element
# och fyll sedan denna med saknade värden.
x_bin <- c(NA, NA, NA, NA, NA)
x_bin[x >=3] <- 1
x_bin[x < 3] <- 0

# Skapa en tom vektor med 5 element och fyll därefter denna vektor med
# data om landet är skandinaviskt eller ej
scandinavia <- c(NA, NA, NA, NA, NA) 
scandinavia[nordic_countries == "Finland"] <- "Not scandinavia"
scandinavia[nordic_countries == "Denmark"] <- "Scandinavia"
scandinavia[nordic_countries == "Sweden"] <- "Scandinavia"
scandinavia[nordic_countries == "Norway"] <- "Scandinavia"
scandinavia[nordic_countries == "Iceland"] <- "Not scandinavia"
scandinavia
  
```

I Console visas 

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Välj vektorn som är större än eller lika med 6
ysub <- y[y >= 6] 

# Skapa en binär vektor x_bin som är 1 om x är större än eller lika med 3 och 0
# om x är mindre än 3. Börja med att skapa en tom vektor med motsvarande antal element
# och fyll sedan denna med saknade värden.
x_bin <- c(NA, NA, NA, NA, NA)
x_bin[x >=3] <- 1
x_bin[x < 3] <- 0
x
x_bin
# Skapa en tom vektor med 5 element och fyll därefter denna vektor med
# data om landet är skandinaviskt eller ej
scandinavia <- c(NA, NA, NA, NA, NA) 
scandinavia[nordic_countries == "Finland"] <- "Not scandinavia"
scandinavia[nordic_countries == "Denmark"] <- "Scandinavia"
scandinavia[nordic_countries == "Sweden"] <- "Scandinavia"
scandinavia[nordic_countries == "Norway"] <- "Scandinavia"
scandinavia[nordic_countries == "Iceland"] <- "Not scandinavia"
scandinavia
  
```
OVanstående moment är **viktigt**. Här illustreras nämligen en grundläggande princip för skapandet av nya variabel, dvs först skapa en tom vektor som sedans fylls med information. Även om det finns alternativa kompaktare sätt att koda om vektorer (och följaktligen variabler), är det ovanstående tillvägagångssätt som rekommenderas starkt på denna kurs.

Nästa steg är att använda den logiska operatorn *&*.

3. Skriv in nedanstående i scriptet, spara och kör koden.


```{r, eval=FALSE}
# Skapa en vektor z_trinary som är
# 1 om z är mindre än eller lika med 1
# 2 om z är större än 1 eller mindre än eller lika med 5 
# 3 om z är större än 5 
z_trinary <- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA)
z_trinary[z <= 1] <- 1
z_trinary[(z > 1) & (z <=5)] <- 2
z_trinary[z > 5] <- 3
z
z_trinary

# Skapa en binära variabler z1, z2 och z3
z1 <- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA)
z1[z_trinary == 1] <- 1
z1[z_trinary == 2] <- 0
z1[z_trinary == 3] <- 0

z2 <- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA)
z2[z_trinary == 1] <- 0
z2[z_trinary == 2] <- 1
z2[z_trinary == 3] <- 0

z3 <- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA)
z3[z_trinary == 1] <- 0
z3[z_trinary == 2] <- 0
z3[z_trinary == 3] <- 1
z1
z2
z3

```

I Console redovisas följande.

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Skapa en vektor z_trinary som är
# 1 om z är mindre än eller lika med 1
# 2 om z är större än 1 eller mindre än eller lika med 5 
# 3 om z är större än 5 
z_trinary <- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA)
z_trinary[z <= 1] <- 1
z_trinary[(z > 1) & (z <= 5)] <- 2
z_trinary[z > 5] <- 3
z
z_trinary

# Skapa en binära variabler z1, z2 och z3
z1 <- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA)
z1[z_trinary == 1] <- 1
z1[z_trinary == 2] <- 0
z1[z_trinary == 3] <- 0

z2 <- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA)
z2[z_trinary == 1] <- 0
z2[z_trinary == 2] <- 1
z2[z_trinary == 3] <- 0

z3 <- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA)
z3[z_trinary == 1] <- 0
z3[z_trinary == 2] <- 0
z3[z_trinary == 3] <- 1
z1
z2
z3

```


Några viktiga punkter att komma ihåg är 

+ Arbetsgången är att en ny vektor skapas, vilken sedan fylls på. För en binär variabel skulle vi teoretiskt kunna använda operatorn *!=*, men detta kan dels leda till att NA i en vektor kodas till 0, dels att datatvätten blir mindre noggrann.
+ Parenteser ska användas, som till exempel var fallet med *(z > 1) & (z <= 5)*. 

Avslutningsvis ska vi använda den logiska operatorn *|*.

4. Skriv in nedanstående i scriptet, spara och kör koden.


```{r, eval=FALSE}
# Om z1 = 1 eller z3 = 1, så ska w_bin = 1.
# Om z2 = 1 så ska d_bin = 0.

# Skapa en tom vektor w_bin
d_bin <- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA)
d_bin[(z1 == 1) | (z3 == 1)] <- 1
d_bin[z2 == 1] <- 0
z1
z2
z3
w_bin


# Om landet är Norge eller Island och x > 4 eller w > -50 så ska vi sätta NA
y_new <- y
y_new[( (nordic_countries == "Iceland") | (nordic_countries == "Norway") ) & 
        ( (x > 4) | (w > -50) ) ] <- NA
nordic_countries
x
w
y_new

```

I Console ser vi utskrifterna. Om du inte har förstått koden, så kan du jämföra vektorerna och se varför *w_bin* och *y_new* har fått de värden som de har.

```{r, eval=FALSE}
# Om z1 = 1 eller z3 = 1, så ska w_bin = 1.
# Om z2 = 1 så ska d_bin = 0.

# Skapa en tom vektor w_bin
d_bin <- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA)
d_bin[(z1 == 1) | (z3 == 1)] <- 1
d_bin[z2 == 1] <- 0
z1
z2
z3
w_bin


# Om landet är Norge eller Island och x > 4 eller w > -50 så ska vi sätta NA
y_new <- y
y_new[( (nordic_countries == "Iceland") | (nordic_countries == "Norway") ) & 
        ( (x > 4) | (w > -50) ) ] <- NA
nordic_countries
x
w
y_new

```

Ovanstående sätt att förändra och skapa vektorer används **mycket ofta** i R och kan hantera mycket av den praktiska datahantering som du kommer att stöta på under denna kurs, men också ute i arbetslivet. Som tidigare nämnts  finns andra sätt att åstadkomma samma resultat, som kanske till och med i specifika avseenden bättre, men utgå på denna kurs från kod som presenteras här. 

Det bör nämnas att det naturligtvis finns mycket mer att lära sig om hur logiska operatorer fungerar. Till exempel skapar nedanstående kod den sista datatypen som nämndes inledningsvis, dvs logical data. 

5. Skriv in nedanstående i scriptet, spara och kör koden.

```{r eval=TRUE}
# Ger en logisk vektor
(x > 4) 
# Multiplikation med en logisk vektor
1*(x > 4) 
4*(x > 4) 
```

Spara scriptet **kap3_objekt_och_funktioner.R**.


### Matriser
En matris är ett tvådimensionellt dataobjekt bestående av **rader** och **kolumner**. Notera ordningen, dvs en matris storlek anges **först** med rader, **sedan** med kolumner. Analogt med **c()**, som kombinerar element till en vektor, används **rbind()** och **cbind()** för att binda ihop vektorer radvis eller kolumnvis till matriser. En matris måste innehålla element av samma datatyp, vilket innebär att det **inte**  går att binda samman numeriska vektorer som med vektorer som innehåller bokstäver. En matris kan även skapas direkt med kommandot **matrix()** som transformerar en vektor med $k$ antal element till en matris bestående motsvarande antal element fördelat på antal rader och kolumner. 

1. Fortsätt scriptet **kap3_objekt_och_funktioner.R** och skriv in nedanstående kod. Spara scriptet och kör.

```{r, eval=FALSE}
# Skapa en matris genom att binda samman x och y radvis. Matrisen får 2 rader och 5 kolumner
m1 <- rbind(x, y)
m1
# Skapa en matris genom att binda samman x, y, n och x radvis. Matrisen får 5 rader och 4 kolumner. 
m2 <- cbind(x, y, n, x)
m2
# Skapa en matris genom att binda samman x och ymis radvis. Matrisen får 5 rader och 2 kolumner. 
m3 <- rbind(x, ymis)
m3
# Skapa med matrix() en matris med två rader och 5 kolumner. 
# Matrisen fylls på kolumnvis och notera att detta inte blir samma som m1. 
m4 <- matrix(z, 2, 5)
m4
# Skapa med matrix() en matris med fem rader och 2 kolumner.
# I detta fall är de två första kolumnerna i m2 samma som m5.
m5 <- matrix(z, 5, 2)
m5
```

I Console visas 

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Skapa en matris genom att binda samman x och y radvis. Matrisen får 2 rader och 5 kolumner
m1 <- rbind(x, y)
m1
# Skapa en matris genom att binda samman x, y, n och x radvis. Matrisen får 5 rader och 4 kolumner. 
m2 <- cbind(x, y, u, x)
m2
# Skapa en matris genom att binda samman x och ymis radvis. Matrisen får 5 rader och 2 kolumner. 
m3 <- rbind(x, ymis)
m3
# Skapa med matrix() en matris med två rader och 5 kolumner. 
# Matrisen fylls på kolumnvis och notera att detta inte blir samma som m1. 
m4 <- matrix(z, 2, 5)
m4
# Skapa med matrix() en matris med fem rader och 2 kolumner.
# I detta fall är de två första kolumnerna i m2 samma som m5.
m5 <- matrix(z, 5, 2)
m5
```

<style>
div.green{ background-color:#abd4b3; border-radius: 5px; padding: 20px;}
</style>
<div class = "green">

 <font size="5">  </font>

```{r, echo = FALSE, out.width = "5%", dpi = 72}
knitr::include_graphics("docs/images/tip.png")
```

Använd på denna kurs **rbind()** och **cbind()** vid skapande av matriser. Det är då mindre risk för
för missförstånd var elementen hamnar i matrisen.

</div>

För åtkomst till element krävs nu, eftersom matriser består av rader och kolumner, att bägge dimensionerna anges. Först anges
radnummer, sedan kolumnnummer.

2. Skriv in nedanstående kod i scriptet, spara och kör. 


```{r, eval=FALSE}
# Visa element på rad 2 och kolumn 3
m1[2,3]
# Visa element på rad 2 och alla kolumner
m1[2,]
# Visa element på alla rader och kolumner 3
m1[,3]
# Visa 
m2[c(1,2),]
```

I Console visas

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Visa element på rad 2 och kolumn 3
m1[2,3]
# Visa element på rad 2 och alla kolumner
m1[2,]
# Visa element på alla rader och kolumner 3
m1[,3]
# Visa 
m2[c(1,2),]
```

Precis som vad gäller vektorer går det att utföra elementvisa beräkningar. Det kräver att matriserna har samma antal rader och kolumner. Det går även att utföra räkneoperationer med en konstant. Observera att elementvis multiplikation **inte** är detsamma som matematikens **matrismultiplikation**. Det är naturligtvis inga problem att i R använda matrismultiplikation, men detta går utanför kursens avgränsning.

3. För att exemplfiera räkneoperationer med matriser, skriv in nedanstående kod i scriptet, spara och kör. 

```{r, eval = FALSE}
# Addera element i matris 1 med element i matris 3
m1 + m3
# Multiplicera element i matris 1 med element i matris 3. OBS! Detta är inte matrismultiplikation!
m1 * m3
# Dividera element i matris 1 med en konstant u
m1 / u
# Nedanstående är INTE det som inom matematiken benämns inversen av en matris, utan är 1/elementvärde
1/m1 
```

I Console visas

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Addera element i matris 1 med element i matris 3
m1 + m3
# Multiplicera element i matris 1 med element i matris 3. OBS! Detta är inte matrismultiplikation!
m1 * m3
# Dividera element i matris 1 med en konstant n
m1 / u
# Nedanstående är INTE det som inom matematiken benämns inversen av en matris, utan är 1/elementvärde
1/m1
```

Spara scriptet **kap3_objekt_och_funktioner.R**.

Det går att tillämpa logiska operatorer även på matriser, men den extra dimensionen gör detta omständligt. Dessutom konstaterade vi att matrisen endast kan hantera en datatyp. Därför introduceras en tredje typ av dataobjekt som bättre sätt hanterar datamaterial. Det är dock bra att känna till att vid mer avancerad användning av R är matriser dock ett mycket viktigt verktyg. 


### Data frames
En **data frame** är i praktiken det vanligaste objektet för dataanalys. En data frame har två dimensioner (rader och kolumner), men kan till skillnad från matrisen innehålla element med olika datatyper, t ex både numeriska värden och bokstäver. Vidare innehåller en data frame detaljerad information om exempelvis **variabelnamn** och **variabeltyp**. 

För att skapa en data frame används **data.frame()** och vi ska nu se på några exempel. Observera att en data frame även anger information om radnummer. Dessa nummer är dock inte definierade som en sepearat kolumn.

1. Skriv nedanstående kod i **kap3_objekt_och_funktioner.R**, spara och kör.


```{r, eval = FALSE}
# Skapa en data frame genom att ange vektorer 
df <- data.frame(x, y, nordic_countries)
df
# Skapa en data frame genom att transformera en matris.
data.frame(m3)
```


I Console erhålls följande resultat.

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Skapa en data frame genom att ange vektorer 
df <- data.frame(x, y, nordic_countries)
df
# Skapa en data frame genom att transformera en matris.
data.frame(m3)
```

För åtkomst till element finns nu flera alternativ.

+ Dels kan används precis som förut hakparenteserna ´[]´ 
+ Dels finns nu möjlighet att använda `$` för att komma åt data genom att använda variabelnamn. 

Nedanstående kod illustrerar de bägge metoderna.

2. Skriv nedanstående kod i **kap3_objekt_och_funktioner.R**, spara och kör.


```{r, eval = FALSE}
# Visa kolumn 3 
df[,3]
df$nordic_countries
# Visa värdet i rad 2 och kolumn 1 
df[2,1]
df$x[2]
```

I Console erhålls följande resultat.

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Visa kolumn 3 
df[,3]
df$nordic_countries
# Visa värdet i rad 2 och kolumn 1 
df[2,1]
df$x[2]
```

Anvädning av enbart hakparentes är alltså ekvivalent med datahantering med hjälp av `$` och sedan position.

Vi kan med  `$` även enkelt addera nya kolumner, dvs variabler, till en data frame.

3. Skriv nedanstående kod i **kap3_objekt_och_funktioner.R**, spara och kör.

```{r, eval = FALSE}
# Skapa variabeln sample_size baserat på n som bara har ett värde
df$sample_size <- u
df
# Skapa en variabel som heter ysq baserat på y i samma data frame.
df$ysq <- df$y^2
df
# Skapa en tom variabel som heter x_cat
df$x_cat <- NA
df
```

I Console visas nedanstående.

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Skapa variabeln sample_size baserat på n som bara har ett värde
df$sample_size <- u
df
# Skapa en variabel som heter ysq baserat på y i samma data frame.
df$ysq <- df$y^2
df
# Skapa en tom variabel som heter x_cat
df$x_cat <- NA
df
```

Med `$` förenklas även användningen av de logiska operatorerna och det är enkelt att transformera variabler och även skapa mindre data frames.  

4. Skriv nedanstående kod i **kap3_objekt_och_funktioner.R**, spara och kör.

```{r, eval = FALSE}
# Ändra värdet på sample_size för Danmark från 150 till 300
df$sample_size[df$nordic_countries == "Denmark"] <- 300
df
# Ändra värden från NA till 1 i x_cat om x är större än 2
df$x_cat[x > 2] <- 1
df
# Ändra värden från NA till 0 i x_cat om x är mindre än eller lika 2
df$x_cat[x <= 2] <- 0
df
# Skapa ett nytt data frame som vi kallas dfsub bestående av bara rader där x_cat är lika med 1
dfsub <- df[df$x_cat == 1, ]
dfsub
```

I Console visas nedanstående.

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Ändra värdet på sample_size för Danmark från 150 till 300
df$sample_size[df$nordic_countries == "Denmark"] <- 300
df
# Ändra värden från NA till 1 i x_cat om x är större än 2
df$x_cat[x > 2] <- 1
df
# Ändra värden från NA till 0 i x_cat om x är mindre än eller lika 2
df$x_cat[x <= 2] <- 0
df
# Skapa ett nytt data frame som vi kallas dfsub bestående av bara rader där x_cat är lika med 1
dfsub <- df[df$x_cat == 1, ]
dfsub
```

Vi kommer senare under kursen gång upprepade gånger att återkomma till data frames och titta närmare olika typer av sätt att hantera detta objekt.


<style>
div.green{ background-color:#abd4b3; border-radius: 5px; padding: 20px;}
</style>
<div class = "green">

 <font size="5">  </font>
```{r, echo = FALSE, out.width = "5%", dpi = 72}
knitr::include_graphics("docs/images/important.png")
```

Hantering av dataobjekt är moment som av förklarliga skäl är väldigt viktigt i R. Det tar inledningsvis tid att lära, men är samtidigt något som varje användare måste vara trygg med. Värt att nämna är att nästan alltid finns alternativa sätt arbeta med data i R och vad som presentas här är är endast ett alternativ. På denna kurs **rekommenderas starkt **att ni följer den metodik som presenteras här. Visserligen är den inte effektivast, varken i termer av beräkningstid eller längd på kod, men det är ett transparent och minimerar risken för att fel uppkommer. 

Datahanteringen är ofta en tidskrävande del i statistisk undersökning och stor noggrannhet är viktigt. Det går inte att tillräckligt betona hur betydelsefull datahanteringen är i en undersökning. En korrekt analys kräver ju korrekt data. 

</div>

## Funktioner 

En funktion utför operationer på objekt. Exakt vad funktionen gör beror på funktionen. Det vara allt från att utföra enkla räknaoperationer på data i en vektor, till komplicerade beräkningar och förändringar av data. Oftast sparas resultatet från en funktion som ett nytt objekt. En funktion har i regel också olika argument som gör det möjligt för användaren att anpassa vad funktionen gör. Den något mer avancerade R-användaren kan även enkelt skapa egna funktioner,  vilket är styrka eftersom R då blir väldigt flexibelt. Att skapa egna funktioner ingår emellertid inte på denna kurs utan analyserna som utförs på kurser kommer hanteras av redan implementerade funktioner i R. Denna introduktionen till funktioner är därför relativt kortfattad och det enklaste sättet att introducera funktion blir med hjälp av exempel.  

1. Skriv in nedanstående kod i scriptet **kap3_objekt_och_funktioner.R**, spara och kör. 


```{r, eval = FALSE}
# sum() är en funktion för att summera värdera i en vektor. Summan sparas i objektet summax
summax <- sum(x)
summax
# length() beräknar antalet element i en vektor och spara i objektet n
n <- length(x)
n
```

I Console får erhålls följande.

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# sum() är en funktion för att summera värdera i en vektor. Summan sparas i objektet sumx
sumx <- sum(x)
sumx
# length() beräknar antalet element i en vektor och spara i objektet n
n <- length(x)
n
```

Du har nu tillämpad funktionen *sum()* som helt enkelt summerar alla elementvärden i en vektor, dvs $\sum_{i=1}^n x_i=x_1 + x_2 + \cdots + x_k$. Funktionen *length()* räknar antalet element.

Med hjälp av dessa funktioner går det nu att på enkelt sätt att beräkna 
 medelvärde, $\bar{x}=\dfrac{1}{n}\sum_{i=1}^n x_i$, och stickprovsvarians, $s^2=\dfrac{1}{n-1}\sum_{i=1}^n(x_i - \bar{x})^2$. Notera att standardavvikelsen är $s=\sqrt{s^2}$.

2. Skriv in nedanstående kod i scriptet **kap3_objekt_och_funktioner.R**, spara och kör. 

```{r, eval = FALSE}
# Beräkna medelvärdet av en vektor
sample.mean <- (1/n)*sumx
sample.mean

# Beräkna stickprovsvarians s^2 med det sum() samt de sparade objekten xbar och n
sample.variance <- (1/(n-1))*sum( (x - xbar)^2 )
sample.variance
```

I Console visas nedanstående.


```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Beräkna medelvärdet av en vektor
sample.mean <- (1/n)*sumx
sample.mean

# Beräkna stickprovsvarians s^2 med hjälp av sum() samt de sparade objekten xbar och n
sample.variance <-  (1/(n-1))*sum( (x - sample.mean)^2 )
sample.variance
```


3. Naturligtvis finns i R färdiga funktioner för både medelvärde och stickprovsvarians. Skriv in nedanstående kod i scriptet **kap3_objekt_och_funktioner.R**, spara och kör. 

```{r, eval = FALSE}
# Beräkna medelvärdet av en vektor
xbar <- mean(x)
xbar
# Beräkna stickprovsvariansen av en vektor
s2 <- var(x)
s2
```

I Console visas nedanstående.

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Beräkna medelvärdet av en vektor
xbar <- mean(x)
xbar
# Beräkna stickprovsvariansen av en vektor
s2 <- var(x)
s2
```

Resultatet är samma som det tidigare, enda skillnaden är att funktionerna *mean(x)* och *var()* förenklar ytterligare. Men vi genom detta också en förståelse för vilka formler som *mean()* och *var()* använder sig av.

4. Skriv in nedanstående kod i scriptet **kap3_objekt_och_funktioner.R**, spara och kör. 

```{r, eval = FALSE}
# Beräkna medelvärdet av ymis, en vektor med att bortfall
ymis.mean <- mean(ymis)
ymis.mean
# Beräkna medelvärdet av ymis, en vektor med att bortfall
#
ymisbar <- mean(ymis, na.rm = TRUE)
ymisbar

```

I Console presenteras följande.

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Beräkna medelvärdet av ymis, en vektor med att bortfall
ymis.mean <- mean(ymis)
ymis.mean
# Beräkna medelvärdet av ymis, en vektor med att bortfall
#
ymisbar <- mean(ymis, na.rm = TRUE)
ymisbar

```

Eftersom R ger att $y_1 + y_2 + NA + \cdots + y_k = NA$  blir även medelvärdet NA. Vi kan dock använda ett argument i funktionen som heter *na.rm* som vi sätter till *TRUE*. Om detta argument sätts till *TRUE* så tar funktionen före beräkning bort saknade värden. Default-inställningen är dock att detta argument är satt till *FALSE*. Det innebär att medelvärdet *ymisbar* är beräknat på de fyra värden som har observationer.

För att veta vilka argument en funktion har skriver använd funktionen **help()**. I exemplet med medelvärdet så skriver du `help(mean)`. I nedre högra panelen i Rstudio under fliken *Help* visas nu information om den funktion som vi ville veta mer om.

```{r, echo = FALSE, out.width = "100%", dpi = 72}
knitr::include_graphics("docs/images/helpmean.png")
```

I hjälpfilen står under *Usage* hur funktionen kan användas `mean(x, trim = 0, na.rm = FALSE)`  och under *Arguments* hittar beskrivs vad argumenten betyder. Till exempel står det  `na.rm	 a logical value indicating whether NA values should be stripped before the computation proceeds.`. Grundinställningen (default) satt till FALSE efter detta är angivet i *Usage*. Hjälpfilerna är ofta svåra att förstå, men exemplen längst ner i hjälpfilerna är i regel klargörande.

På denna kurs kommer funktioner att introduceras efterhand. Funktioner är nämligen något som man lär sig genom tillämpning och inte genom att lära sig utantill i förväg. Dock kan det vara bra att ha en lista över alla de vanliga funktionerna så man vet vilka möjligheter som finns.

https://cran.r-project.org/doc/contrib/Short-refcard.pdf

Vi börjar här med några grundläggande funktioner som är användbara.

5. Skriv in nedanstående kod i scriptet **kap3_objekt_och_funktioner.R**, spara och kör. 

```{r, eval = FALSE}
# Skapa en vektor som repeterar värde 3 fem gånger
x1 <- rep(3, 5)
x1
# Funktion som skapar en sekvens från 2 till 3 med steglängd 0.25
x2 <- seq(from = 2, to = 3, by = 0.25)
x2
# Skapa en en vektor av element som repeterats 
x3 <- c(rep(1, 3), rep(4, 2), rep(9, 10))
x3
# Funktion för att summera information i ett objekt
summary(ymis)
# Funktion skapar ett histogram
hist(x)
# Funktion som skapar ett spridningsdiagram
plot(x, y)

```

I Console visas

```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Skapa en vektor som repeterar värde 3 fem gånger
x1 <- rep(3, 5)
x1
# Funktion som skapar en sekvens från 2 till 3 med steglängd 0.25
x2 <- seq(from = 2, to = 3, by = 0.25)
x2
# Skapa en en vektor av element som repeterats 
x3 <- c(rep(1, 3), rep(4, 2), rep(9, 10))
x3
# Funktion för att summera information i ett objekt
summary(ymis)
# Funktion skapar ett histogram
hist(x)
# Funktion som skapar ett spridningsdiagram
plot(x, y)

```


Avslutningsvis finns det ett antal viktiga funktioner för dataobjekt. Bekanta dig med dessa. 


```{r, collapse=TRUE, prompt=TRUE, comment='>'}
# Funktion för att beskriva datatyp 
class(y)
class(nordic_countries)
# Funktion för att beskriva objekt 
str(y)
str(nordic_countries)
# Funktion för att ta reda på storleken på matris eller data frame
dim(m1)
dim(df)
dim(df)[1]
dim(df)[2]
# Funktion för att beräkna längden av en vektor
length(x)
# Funktionen ls() listar alla objekt i minnet
ls()
# Funktionen rm() raderar ett objekt
rm(y)
# Se om objektet y finns kvar
ls()
```


Avslutningsvis finns en viktig funktion som används för att **radera alla objekt**. Det är 

+ `rm(list = ls())`. 

Var försiktig med denna funktion eftersom alla objekt i minnet försvinner! Emellertid är god idé inleda en dataanlys med denna kod för att säkerställa att  minnet är tomt innan data läses in. På så vis undviker vi konflkter mellan objekt. Förslagsvis används denna funktion inför **varje ny** övningsuppgift, såvida inte uppgiftern bygger på information från tidigare uppgifter.


## Avslutande kommentarer

+ Bortfall är speciellt och hanteras separat i kapitlet om bortfall.
+ På denna kurs används baspaketen i R för datahantering. I R-universumet finns även en uppsättning paket som tillhör det så kallade *tidyverse()*. Här finns paket med funktioner som kan förenkla en del datahantering betydligt och som också följer en logik som många uppskattar.  
+ Kategorivariabler kallas faktorer och faktorer kommer att hanteras utförligt i kapitlet om faktorer. Att ha en förståelse för hur man hanterar faktorer är nödvändigt inom all dataanlys.
+ I R används även typiska programmeringssatser innehållande *for*, *if*, *else*, *while*. Detta är emellertid inte något som vi kommer att arbeta med på denna kurs.


***

## Sammanfattning

<style>
div.red{ background-color:#F5B7B1; border-radius: 5px; padding: 20px;}
</style>
<div class = "red">

 <font size="5">  </font>
Du ska kunna

- känna till de viktigaste datatyper som R arbetar med.
- känna till de tre olika typerna av dataobjekt.
- genomföra enklare datahantering, till exempel förändra ett specifikt elements värde i ett dataobjekt eller att med logiska operationer välja ut data från ett objekt 
- använda `$` i data frames.
- tillämpa en funktion i R samt informera dig om vad en funktion gör genom att använda hjälp-filen.
- känna till viktiga funktioner i R som beskriver dataobjekt.

</div>

***

## Övningar

### Övning 3.1 {-}
Du har ett stickprov betående av observationerna $4,-2,5,6,8$. 

a) Beräkna medelvärdet.
b) Beräkna standardavvikelsen.
c) Beräkna variationsbredden.
d) Beräkna det geometriska medelvärdet för de positiva värden $4, 5, 6, 8$.
e) Beräkna det geometriska medelvärdet för alla värden $4, -2, 5, 6, 8$.

### Svar 3.1 {-}
a)

```{r, echo=TRUE, collapse=TRUE, prompt=FALSE, comment=''} 
# Töm minnet inför denna Övning 3.1 
rm(list = ls())
x <- c(4,-2,5,6,8)
mean(x)
```

* Svar: Medelvärdet är `r 
x <- c(4,-2,5,6,8)
mean(x)`

b) Standardavvikelsen $s=\sqrt{\dfrac{\sum_{i=1}^n (x_i -\bar{x})^2}{n-1}}$ beräknas med

```{r, echo=TRUE, collapse=TRUE, prompt=FALSE, comment=''} 
sd(x)
```

* Svar: Standardavvikelsen är `r 
round(sd(x), 3)`

c) Variationsbredden, dvs skillnaden mellan det största och det minsta värdet är

```{r}
max(x) - min(x)
```


* Svar: Variationsbredden är är `r max(x) - min(x)`.

d) Det geometriska medelvärdet $\bar{x}_g=(x_1\cdot x_2 \cdot \cdots \cdot x_n)^{1/n}$ kan i R beräknas med 

```{r}
# Välj enbart positiva värden
xpos <- x[x > 0] 
# Du kan beräkna det geometriska medelvärdet med
exp( mean(log(xpos)) )
# Alternativt kan du funktionen geometric.mean() 
# i paketet psych. Aktivera paketet och beräkna.
library("psych")
geometric.mean(xpos)
```

* Svar: Det geometriska medelvärdet är `r round( (4 * 5 * 6 * 8)^(1/5), 2)`.

e) Det geometriska medelvärdet $$\bar{x}_g=(x_1\cdot x_2 \cdot \cdots \cdot x_n)^{1/n}$$ kan i R beräknas med 

```{r}
(4  * (-2) * 5 * 6 * 8)^(1/5)
geometric.mean(x)
```

* Svar: Eftersom en observation är negativ   blir `r (4  * (-2) * 5 * 6 * 8)^(1/5)`, vilket betyder ''Not a Number''. Det går alltså inte att beräkna. 



### Övning 3.2 {-}
Ett slumpmässigt urval ger följande observationer $0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1$,där $1=Arbetslös$ och $0=Förvärvsarbetande$.
Beräkna andelen arbetslösa i stickprovet.


### Svar 3.2 {-}
Andelen arbetslösa beräkna i R med
```{r} 
# Töm minnet inför denna Övning 3.2 
rm(list = ls())
x <- c(0,  1,  1, 0,  0,  0,  0,  0, 1,  0,  1,  0,  1) 
mean(x)
```

* Svar: Andelen arbetslösa i stickprovet är `r round(mean(x), 2)`.



### Övning 3.3 {-}
Kosumentpriset 2006-2011  är 

```{r,  echo = FALSE}
knitr::kable(
  cbind(c(2006, 2007, 2008, 2009, 2010, 2011),
        c(284.22, 290.51, 300.61, 299.66, 303.46, 311.423)), digits = c(0, 1), caption = "Konsumentprisindex (KPI) 2006-2011")  
```

Med hur många procent har prisnivån förändrats från 2007 till 2010?

### Svar 3.3 {-}
Beräkning i R ger
```{r} 
# Töm minnet inför denna Övning 3.2 
rm(list = ls())
year <- c(2006, 2007, 2008, 2009, 2010, 2011)
kpi <- c(284.22, 290.51, 300.61, 299.66, 303.46, 311.423)
percent_change <- 100*(kpi[year == 2010]/kpi[year == 2007])-100
```

* Svar: Prisnivån har ökat med `r round(percent_change,3)`%.



### Övning 3.4  {-}
Låt observationerna $4,-2,5,6,8$ vara obundet slumpmässigt urval från en normalfördelad population. Genomför en hypotesprövning på 5\% signifikansnivå för att testa medelvärdet i population är skild från 1.


### Svar 3.4 {-}
1. Vi observerar $x=\{4,-2,5,6,8\}.$
2. Hypoteser: $H_0:\mu=1$ vs $H_1:\mu \neq 1$ 
3. Antaganden: Variabeln $x$ är normalfördelad i populationen. Populationsvariansen $\sigma^2$ är okänd i populationen. Vi har ett litet stickprov, $n=5$.
4. Testfunktionen ges av $t=\dfrac{\bar{x}-\mu}{\sqrt{s^2/n}}$. Denna teststatistika är $t$-fördelad med $n-1$ frihetsgrader om nollhypotesen är sann. 
5. Beslutregel: $\alpha=0.05$. Tvåsidigt test, förkasta därför $H_0$ om $|t_{obs}| > t_{krit} = t_{4,\alpha/2=0.025} = 2.776$

```{r, echo=TRUE, collapse=TRUE, prompt=FALSE, comment=''} 
# Töm minnet inför uppgift 3.4
rm(list = ls())
# Vi ska lösa uppgiften först illusterat med objekt i R
# Sedan löser vi den med den inbyggda funktionen för t-test

# Bestäm värden som ska in i testfunktionen
x <- c(4,-2,5,6,8)
n <- length(x)
xbar <- mean (x)
s2 <- var(x)
mu <- 1
# Beräkna testfunktionen
tobs <- (xbar - mu)/sqrt(s2/n)
# Se var testfunktionensvärde hamnar i en t-fördelning med n-1 frihetsgrader
# Funktionen pt() ger för ett givet t-värde vänstersvanssannolikheter i en t-fördelning med n-1 frihetsgrader 
# Eftersom vi vill ha sannolikheten i högra svansen måste vi därför ta 1-pt().
# Slutligen, eftersom mothypotesen är två-sidig multipliceras p-värdet med 2.
p_value <- 2*(1 - pt(tobs, (n-1)))
p_value

t.test(x, mu = 1)
t.test(x, mu = 1)$p.value

```

* Svar: Efterom $p=0.13$ kan vi  på 5% signifikansnivå inte påvisa att medelvärdet i populationen är skilt från 1. Notera att detta **inte** innebär att vi visar att medelvärdet är 1.


### Övning 3.5  {-}
Du observerar följande vektorer $x = \{4,7,2,4,6,NA,89\}$ och $y=\{7,3, 2, 5,6, 5 , 7\}$ och $z=\{Alfa, bravo, Charlie, delta, Echo, Foxtrot, Golf\}$

a) Använd indexering för att summera element 2 och 3 i $x$ med element 6 och 7 i $y$.
b) Använd indexering för att ändra NA i $x$ till 999.
c) Använd indexering för att korrigera så att bravo och delta inleds med versaler.
d) Exkludera Echo och Foxtrot från $z$.

### Svar 3.5  {-}
```{r, collapse=TRUE, prompt=FALSE, comment=''}
# Töm minnet inför uppgift 3.5 
rm(list = ls())
# a)
x <- c(4,7,2,4,6,NA,89)
y <- c(7,3,2,5,6,5,7)
sumxy <- x[c(2,3)] + y[c(6,7)]
sumxy
# b)
x[6] <- 999
x
# c)
z <- c("Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf")
z[2] <- "Bravo"
z[4] <- "Delta"
z
# d)
zsub <- z[-c(5,6)]
zsub
```




### Svar 3.5  {-}
a) Riktningskoefficienten ges av
$$b=\dfrac{\sum_{i=1}^n(x_i-\bar{x})(y_i-\bar{y})}{\sum_{i=1}^n(x_i - \bar{x})^2}$$
och interceptet ges av
$$ a = \bar{y} - b \bar{x}$$. Vi tillämpar formlerna i R.






### Övning 3.5  {-}
Du observerar följande datapunkter $x = \{4,7,2,4,6\}$ och $y=\{7,3, 2, 5,6\}$.

```{r, echo=FALSE}
x <- c(4,7,2,4,6)
y <- c(7,3, 2, 5,6)
plot(x,y, xlim = c(0, 10), ylim=c(0,10))

```



a) Använd minsta-kvadratmetoden och beräkna koefficienterna $a$ och $b$ i regressionslinjen $y=a + bx$.
b) Använd koefficienterna och ge en prediktion för $y$ givet att $x=7$.
c) Beräkna residualen för $x=7$
d) Beräkna residualspridningen.


### Svar 3.5  {-}
a) Riktningskoefficienten ges av
$$b=\dfrac{\sum_{i=1}^n(x_i-\bar{x})(y_i-\bar{y})}{\sum_{i=1}^n(x_i - \bar{x})^2}$$
och interceptet ges av
$$ a = \bar{y} - b \bar{x}$$. Vi tillämpar formlerna i R.

```{r, collapse=TRUE, prompt=FALSE, comment=''}
# Töm minnet inför uppgift 3.5
rm(list = ls())
x <- c(4,7,2,4,6)
y <- c(7,3, 2, 5,6)
xbar <- mean(x)
ybar <- mean(y)
b <- sum( (x - xbar)*(y - ybar))/sum( (x - xbar)^2)
b
a <- ybar - b*xbar
a
# Det finns en inbyggd funktion i R för regressionsanalys, vilken används senare på kursen.
```
* Svar: Riktningskoefficienten beräknas till $b=0.2105$, vilket tolkas som att om $x$ ökar en enhet så ökar $y$ i *genomsnitt* med $0.2105$  enheter. Interceptet beräknas till $a=3.632$, vilket tolkas som medelvärdet för $y$ när $x=0$. Notera att det i beräkningarna 

b) Använd koefficienterna från regressionslinjen och sätt in värdet $x=7$.
```{r, collapse=TRUE, prompt=FALSE, comment=''}
xp <- 7
yhat <- a   +    b*xp  
yhat
```

* Svar: Prediktionen $\hat{y}=$ `r round(yhat, 3)`. Detta är punkten på regressionslinjen när $x=7$ och vår bästa gissning för det $y$-värde en individ med värdet $x=7$ kommer att ha.   


c) En residual är skillnaden mellan ett predicerat värde och det faktiska observerade värdet, $\hat{\varepsilon}=y_i - \hat{y}$.
Eftersom $y=3$ när $x=7$ så residualen  

```{r, collapse=TRUE, prompt=FALSE, comment=''}
residual <- y[x == xp] - yhat
```

* Svar: Residualen för $x=7$ är `r round(residual, 3)`.

d)
Residualspridningen ges av $$s_\varepsilon=\sqrt{\dfrac{\sum_{i=1}^n(y_i - \hat{y}_i)^2}{n-2}}= \sqrt{\dfrac{\sum_{i=1}^n\hat{\varepsilon}_i^2}{n-2}}$$. Vi beräknar på samma sätt som i c) övriga residualer, kvadrerar och summerar. 


```{r, collapse=TRUE, prompt=FALSE, comment=''}
residuals <- y - (3.6316   +    0.2105*x)
n <- length(residuals)
residual_spridning <- sqrt( sum(residuals^2)/(n-2) )
residual_spridning
```

* Svar: Residualspridningen är `r round( residual_spridning, 3)`
  
(Notera att $\sum_{i=1}^n \varepsilon_i^2$ kallas för *residualkvadratsumman*.)




### Övning 3.6  {-}
Du observerar följande data frame


```{r, eval=FALSE}
income <- c(4,7,2,3,6,7,8,6)
education <- c("Low", "Medium", "Low", "High", "High", "Low", "Medium", "High")
df <- data.frame(income, education)
```

Skapa en ny variabel som heter high_edu som tar värdet 1 om education är "High" och 0 annars.

### Svar 3.6  {-}

```{r, collapse=TRUE, prompt=FALSE, comment=''}
# Töm minnet inför uppgift 3.6
rm(list = ls())
income <- c(4,7,2,3,6,7,8,6)
education <- c("Low", "Medium", "Low", "High", "High", "Low", "Medium", "High")
df <- data.frame(income, education)
df$high_edu <- NA
df$high_edu[df$education == "High"] <- 1
df$high_edu[df$education == "Low"] <- 0
df$high_edu[df$education == "Medium"] <- 0
df

```


### Övning 3.7  {-}
Ett oljebolag är intresserat av att för ett äldre bostadsområde med $2\,000$ hus skatta andelen hus utan oljeeldning. Sakkunskapen säger att det sanna antalet hus utan oljeeldning är mellan 300 och 800 stycken. Precisionskravet är formulerat så att ett 95\% konfidensintervall för andelen hus utan oljeeldning inte får
bli längre än 0.05 procentenheter.

a) Beräkna urvalsstorleken vid OSU om dragningen sker med återläggning.

### Svar 3.7  {-}

* Mål: Beräkna den nödvändiga stickprovsstorleken $n$ om längden för ett 95\% konfidensintervall för andelen i populationen får vara maximalt 0.05.

* Parameter: $p$ = andelen hus utan oljeeldning i populationen.

* Estimator: $\hat{p}$ = andelen hus utan oljeeldning i stickprovet.

* Förutsättningar: 
1. OSU-MÅ ger att $E(\hat{p})=p$. Detta säger oss att andelen i stickprovprovet kan skatta andelen i populationen väntevärdesriktigt.
2. $V(\hat{p})=\frac{p(1-p)}{n}$. Detta är variansen i andelsestimatorns samplingfördelning.
3. Vi antar att $p=\dfrac{800}{2000}=0.4$ eftersom detta ger störst varians givet den information vi har.
4. Vi utgår från att $np(1-p)>5$ kommer att vara uppfyllt. Vi måste sedan kontrollera att antagandet faktiskt är uppfyllt! Annars gäller inte CGS och approximativ normalfördelning.

Precisionskravet i termer av konfidensintervallets längd kan nu formuleras
$$
	0.05\geq 2\cdot 1.96\sqrt{\frac{0.4(1-0.4)}{n}}.
$$

Det går att ändra värdena på $n$ i R för att se vilket $n$ som ger vår önskade minsta stickprovsstorlek. Vi vill att uttrycket nedan ska vara lika med eller mindre än 0.05.

```{r, collapse=TRUE, prompt=FALSE, comment=''}
# Töm minnet inför uppgift 3.7
rm(list = ls())
n <- seq(10, 10000, 1)
p <- 0.4
# Z-värdet från fördelning N(0,1) med sannolikheten 0.025 i högre svansen.
z <- qnorm(0.975)
# Längden för ett konfidensintervall ges av följande formel:
KIlength <- 2 * z * sqrt(  ( p*(1-p)  ) / n   )
# Illustration över olika KIlength för olika värden stickprovsstorlekar n 
plot(n, KIlength, type = "l")
# Välj den minsta stickprovsstorleken som uppfyller precisionskravet KIlength < 0.05
min( n[KIlength < 0.05] )
```

* Svar: För att uppnå precisionskravet behövs ett stickprov med minst 1476 hus. Glöm inte att kontrollera CGS: $np(1-p)=1476\cdot 0.4(1-0.4)=354.24 > 5$ så antagandet är uppfyllt. Det går även att lösa denna uppgift algebraiskt, genom att lösa ut $n i formeln ovan.


### Övning 3.8  {-}
En rikstäckande butikskedja säljer bland annat kompletta datorpaket. För ett visst paket tillåter man butikscheferna att själva sätta priset. För att centralt i företaget få en uppfattning om hur efterfrågan påverkas av priset gör man ett slumpmässigt urval om åtta butiker och inhämtar uppgifter om pris och försäljning under den närmast föregående månaden:

```{r}
pris <- c(5500, 6000, 6500, 6000, 5000, 6500, 4500, 5000)
antal <- c(41, 38, 35, 40, 44, 38, 45, 42)
```

Beräkna korrelationskoefficienten. 

### Svar 3.8  {-}
Korrelationskoefficentens ges av

$$r=\dfrac{\sum_{i=1}^n(x_i - \bar{x})(y_i-\bar{y})}{\sqrt{\sum_{i=1}^n(x_i - \bar{x})^2 \sum_{i=1}^n(y_i - \bar{y})^2}}.$$

Vi kan enkelt tillämpa formeln.

```{r, collapse=TRUE, prompt=FALSE, comment=''}
# Töm minnet inför uppgift 3.8
rm(list = ls())
x <- c(5500, 6000, 6500, 6000, 5000, 6500, 4500, 5000)
y <- c(41, 38, 35, 40, 44, 38, 45, 42)
xbar <- mean(x)
ybar <- mean(y)
sdx <- sd(x)
sdy <- sd(y)
r <- sum( (x - xbar)*(y - ybar) ) /sqrt( sum( (x - xbar)^2)*sum( (y - ybar)^2) ) 
r
```

* Svar: Pearsons produktmomentkorrelationskoefficient är $-0.94$, vilket tyder på ett mkt starkt negativt samband mellan pris och antal.


### Övning 3.9  {-}
Betrakta nedanstående vektor:

```{r, eval = FALSE}
some_letters <- c("A", "B", "C", "B", "D", "A", "D", "A")
```

Använd R för att räkna hur många B det finns i vektorn.
 

### Svar 3.9  {-}

```{r, collapse=TRUE, prompt=FALSE, comment=''}
# Töm minnet inför uppgift 3.8
rm(list = ls())
some_letters <- c("A", "B", "C", "B", "D", "A", "D", "A")
length( some_letters[some_letters == "B"] )
```

### Övning 3.10  {-}
Betrakta nedanstående vektorer:

```{r, eval = FALSE}
some_numbers <- c("1", "3", "1", "3", "3")
some_numbers_and_letters <- c("2", "4", "-1", "3", "3", "A", "D")
```

Använd R för att summera alla värdena i respektive vektor. Tips: Använd funktionen *as.numeric()*.
 

### Svar 3.10  {-}

```{r, collapse=TRUE, prompt=FALSE, comment=''}
# Töm minnet inför uppgift 3.10
rm(list = ls())
some_numbers <- c("1", "3", "1", "3", "3")
some_numerics <- as.numeric( some_numbers )
class(some_numbers)
class(some_numerics)
sum(some_numerics)

some_numbers_and_letters <- c("2", "5", "-1", "3", "3", "A", "D")
some_numerics_2 <- as.numeric(some_numbers_and_letters)
sum(some_numerics_2, na.rm = TRUE)
```



### Övning 3.11  {-}
Betrakta nedanstående vektorer.

```{r, eval = FALSE}
x1 <- c(0.39,  0.76, -1.25,  0.28,  0.60,  0.66,  0.94, -0.18, -0.26, -1.83, -1.13,  0.45,  0.11, -1.03,  1.06, -0.08,  1.68, -1.02,  1.36,  1.58)
x2 <- c(-1.0,  1.5,  0.2, -0.5, -1.1, -0.2, -1.0, -1.3, -1.6, -1.2, -0.4, -1.3, -0.3, -0.7,  0.7, -2.5, -1.0,  2.1,  1.3, -1.3)
x3 <- c(5.94, -2.38, -0.16, 0.44, 0.70, 2.54, 2.12, 8.33, 0.57, 1.24, 0.05, -1.78, 2.53, -1.60, 2.77, 0.26, 1.48, 1.10, -8.00, 4.57)
```

a) Skapa variabeln $x = x_1 + x_2 + x_3$.
b) Skapa variabeln $z$, där $z=1$ om $x < 0$, $z=2$ om $0 \leq x  < 5$ och $z=3$ om $x \geq 5$.
c) Skapa de binära variblerna $v_1$ som är 1 om $x1 > 0$ och 0 annars,  $v_2$ som är 1 om $x2 > 0$ och 0 annars, och $v_3$ som är 1 om $x3 > 0$ och 0 annars
d) Skapa variabeln $v = v_1 + v_2 + v_3$ som är en summa av de binära variablerna.
e) Skapa en frekvenstabell för $v$.


### Svar 3.11  {-}

```{r, collapse=TRUE, prompt=FALSE, comment=''}
# Töm minnet inför uppgift 3.10
rm(list = ls())
x1 <- c(0.39,  0.76, -1.25,  0.28,  0.60,  0.66,  0.94, -0.18, -0.26, -1.83, -1.13,  0.45,  0.11, -1.03,  1.06, -0.08,  1.68, -1.02,  1.36,  1.58)
x2 <- c(-1.0,  1.5,  0.2, -0.5, -1.1, -0.2, -1.0, -1.3, -1.6, -1.2, -0.4, -1.3, -0.3, -0.7,  0.7, -2.5, -1.0,  2.1,  1.3, -1.3)
x3 <- c(5.94, -2.38, -0.16, 0.44, 0.70, 2.54, 2.12, 8.33, 0.57, 1.24, 0.05, -1.78, 2.53, -1.60, 2.77, 0.26, 1.48, 1.10, -8.00, 4.57)

# a)
x <- x1 + x2 + x3
# b)
# Skapa en variabeln som består av NA som är lika lång som x
z <- rep(NA, length(x))
z[x < 0] <- 1
z[(x >= 0) & (x < 10)  ] <- 2
z[x > 10] <- 3
z
# c)
v1 <- rep(NA, length(x1))
v1[x1 > 0] <- 1
v1[x1 <= 0] <- 0
v2 <- rep(NA, length(x1))
v2[x2 > 0] <- 1
v2[x2 <= 0] <- 0
v3 <- rep(NA, length(x1))
v3[x3 > 0] <- 1
v3[x3 <= 0] <- 0
# d)
v <- v1 + v2 + v3
v
# e)
sumv0 <- sum(v == 0)
sumv1 <- sum(v == 1)
sumv2 <- sum(v == 2)
sumv3 <- sum(v == 3)
frequencies <- c(sumv0, sumv1, sumv2, sumv3)
values <- c(0, 1, 2, 3)
frequency.table <- cbind(values, frequencies)
frequency.table 
# Det finns i R också en inbyggd funktion table(), som vi ska använda oss av senare på kursen.
```





